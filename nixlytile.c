/*
 * See LICENSE file for copyright and license details.
 */
#define _DEFAULT_SOURCE

#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <dirent.h>
#include <ifaddrs.h>
#include <net/if.h>
#include <systemd/sd-bus.h>
#include <limits.h>
#include <getopt.h>
#include <libinput.h>
#include <cairo/cairo.h>
#include <librsvg/rsvg.h>
#include <linux/input-event-codes.h>
#include <linux/input.h>
#include <math.h>
#include <glib.h>
#include <drm_fourcc.h>
#include <xf86drm.h>
#include <xf86drmMode.h>
#include <fcft/fcft.h>
#include <pixman.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <strings.h>
#include <ctype.h>
#include <pwd.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/inotify.h>
#include <fcntl.h>
#include <stdint.h>
#include <time.h>
#include <unistd.h>
#include <wayland-server-core.h>
#include <wlr/backend.h>
#include <wlr/backend/libinput.h>
#include <wlr/render/allocator.h>
#include <wlr/render/wlr_renderer.h>
#include <wlr/render/drm_format_set.h>
#include <wlr/interfaces/wlr_buffer.h>
#include <wlr/types/wlr_buffer.h>
#include <wlr/types/wlr_alpha_modifier_v1.h>
#include <wlr/types/wlr_compositor.h>
#include <wlr/types/wlr_content_type_v1.h>
#include <wlr/types/wlr_cursor.h>
#include <wlr/types/wlr_cursor_shape_v1.h>
#include <wlr/types/wlr_data_control_v1.h>
#include <wlr/types/wlr_data_device.h>
#include <wlr/types/wlr_drm.h>
#include <wlr/backend/drm.h>
#include <wlr/types/wlr_export_dmabuf_v1.h>
#include <wlr/types/wlr_fractional_scale_v1.h>
#include <wlr/types/wlr_gamma_control_v1.h>
#include <wlr/types/wlr_idle_inhibit_v1.h>
#include <wlr/types/wlr_idle_notify_v1.h>
#include <wlr/types/wlr_input_device.h>
#include <wlr/types/wlr_keyboard.h>
#include <wlr/types/wlr_keyboard_group.h>
#include <wlr/types/wlr_layer_shell_v1.h>
#include <wlr/types/wlr_linux_dmabuf_v1.h>
#include <wlr/types/wlr_linux_drm_syncobj_v1.h>
#include <wlr/types/wlr_output.h>
#include <wlr/types/wlr_output_layout.h>
#include <wlr/types/wlr_output_management_v1.h>
#include <wlr/types/wlr_output_power_management_v1.h>
#include <wlr/types/wlr_pointer.h>
#include <wlr/types/wlr_pointer_constraints_v1.h>
#include <wlr/types/wlr_presentation_time.h>
#include <wlr/types/wlr_primary_selection.h>
#include <wlr/types/wlr_primary_selection_v1.h>
#include <wlr/types/wlr_relative_pointer_v1.h>
#include <wlr/types/wlr_scene.h>
#include <wlr/types/wlr_screencopy_v1.h>
#include <wlr/types/wlr_seat.h>
#include <wlr/types/wlr_server_decoration.h>
#include <wlr/types/wlr_session_lock_v1.h>
#include <wlr/types/wlr_single_pixel_buffer_v1.h>
#include <wlr/types/wlr_subcompositor.h>
#include <wlr/types/wlr_tearing_control_v1.h>
#include <wlr/types/wlr_text_input_v3.h>
#include <wlr/types/wlr_viewporter.h>
#include <wlr/types/wlr_virtual_keyboard_v1.h>
#include <wlr/types/wlr_virtual_pointer_v1.h>
#include <wlr/types/wlr_xcursor_manager.h>
#include <wlr/types/wlr_xdg_activation_v1.h>
#include <wlr/types/wlr_xdg_decoration_v1.h>
#include <wlr/types/wlr_xdg_output_v1.h>
#include <wlr/types/wlr_xdg_shell.h>
#include <wlr/util/log.h>
#include <wlr/util/region.h>
#include <xkbcommon/xkbcommon.h>
#ifdef XWAYLAND
#include <wlr/xwayland.h>
#include <xcb/xcb.h>
#include <xcb/xcb_icccm.h>
#endif
#include <tllist.h>
#include "content-type-v1-protocol.h"

#ifndef SD_BUS_EVENT_READABLE
#define SD_BUS_EVENT_READABLE 1
#endif
#ifndef SD_BUS_EVENT_WRITABLE
#define SD_BUS_EVENT_WRITABLE 2
#endif

#include "util.h"

/* macros */
#ifndef MAX
#define MAX(A, B)               ((A) > (B) ? (A) : (B))
#endif
#ifndef MIN
#define MIN(A, B)               ((A) < (B) ? (A) : (B))
#endif
#define UNUSED __attribute__((unused))
#define CLEANMASK(mask)         (mask & ~WLR_MODIFIER_CAPS)
#define VISIBLEON(C, M)         ((M) && (C)->mon == (M) && (((C)->tags & (M)->tagset[(M)->seltags]) || (C)->issticky))
#define LENGTH(X)               (sizeof X / sizeof X[0])
#define END(A)                  ((A) + LENGTH(A))
#define TAGMASK                 ((1u << TAGCOUNT) - 1)
#define MAX_TAGS                32
#define STATUS_FAST_MS          3000
#define LISTEN(E, L, H)         wl_signal_add((E), ((L)->notify = (H), (L)))
#define LISTEN_STATIC(E, H)     do { struct wl_listener *_l = ecalloc(1, sizeof(*_l)); _l->notify = (H); wl_signal_add((E), _l); } while (0)

struct GlyphRun {
	const struct fcft_glyph *glyph;
	int pen_x;
	uint32_t codepoint;
};

struct StatusFont {
	struct fcft_font *font;
	int ascent;
	int descent;
	int height;
};

/* enums */
enum { CurNormal, CurPressed, CurMove, CurResize }; /* cursor */
enum { XDGShell, LayerShell, X11 }; /* client types */
enum { LyrBg, LyrBottom, LyrTile, LyrFloat, LyrTop, LyrFS, LyrOverlay, LyrBlock, NUM_LAYERS }; /* scene layers */
#define MODAL_MAX_RESULTS 512
#define MODAL_RESULT_LEN 256

typedef union {
	int i;
	uint32_t ui;
	float f;
	const void *v;
} Arg;

typedef struct {
	unsigned int mod;
	unsigned int button;
	void (*func)(const Arg *);
	const Arg arg;
} Button;

typedef struct LayoutNode LayoutNode;
typedef struct Monitor Monitor;
typedef struct StatusBar StatusBar;
typedef struct StatusModule StatusModule;
struct StatusModule {
	struct wlr_scene_tree *tree;
	struct wlr_scene_tree *bg;
	int width;
	int x;
	int box_x[MAX_TAGS];
	int box_w[MAX_TAGS];
	int box_tag[MAX_TAGS];
	int box_count;
	uint32_t tagmask;
	int hover_tag;
	float hover_alpha[MAX_TAGS];
};

typedef struct {
	pid_t pid;
	char name[64];
	double cpu;
	double max_single_cpu;
	int y;
	int height;
	int kill_x, kill_y, kill_w, kill_h;
	int has_kill;
} CpuProcEntry;

typedef struct {
	struct wlr_scene_tree *tree;
	struct wlr_scene_tree *bg;
	int width;
	int height;
	int visible;
	int hover_idx;
	int refresh_data;
	uint64_t last_fetch_ms;
	uint64_t last_render_ms;
	uint64_t suppress_refresh_until_ms;
	uint64_t hover_start_ms;
	int proc_count;
	CpuProcEntry procs[10];
} CpuPopup;

typedef struct {
	pid_t pid;
	char name[64];
	unsigned long mem_kb;  /* memory in KB */
	int y;
	int height;
	int kill_x, kill_y, kill_w, kill_h;
	int has_kill;
} RamProcEntry;

typedef struct {
	struct wlr_scene_tree *tree;
	struct wlr_scene_tree *bg;
	int width;
	int height;
	int visible;
	int hover_idx;
	int refresh_data;
	uint64_t last_fetch_ms;
	uint64_t last_render_ms;
	uint64_t suppress_refresh_until_ms;
	uint64_t hover_start_ms;
	int proc_count;
	RamProcEntry procs[15];
} RamPopup;

typedef struct {
	struct wlr_scene_tree *tree;
	struct wlr_scene_tree *bg;
	int width;
	int height;
	int visible;
	int refresh_data;
	uint64_t last_fetch_ms;
	uint64_t last_render_ms;
	uint64_t suppress_refresh_until_ms;
	uint64_t hover_start_ms;
	/* Cached battery info */
	int charging;           /* 1=charging, 0=discharging */
	double percent;         /* Battery percentage */
	double voltage_v;       /* Voltage in V */
	double power_w;         /* Power draw in W */
	double time_remaining_h; /* Time remaining in hours */
} BatteryPopup;

typedef struct {
	struct wlr_scene_tree *tree;
	struct wlr_scene_tree *bg;
	int visible;
	int x, y, width, height;
	int active_idx;
	char search[3][256];
	int search_len[3];
	char search_rendered[3][256]; /* last rendered search text */
	struct wlr_scene_tree *search_field_tree; /* cached search field for fast updates */
	struct wl_event_source *render_timer; /* timer for async rendering */
	int render_pending; /* flag to indicate render is needed */
	int result_count[3];
	char results[3][MODAL_MAX_RESULTS][MODAL_RESULT_LEN];
	int result_entry_idx[3][MODAL_MAX_RESULTS];
	int selected[3];
	int scroll[3];
	char file_results_name[MODAL_MAX_RESULTS][128];
	char file_results_path[MODAL_MAX_RESULTS][PATH_MAX];
	time_t file_results_mtime[MODAL_MAX_RESULTS];
	pid_t file_search_pid;
	int file_search_fd;
	int file_search_fallback;
	struct wl_event_source *file_search_event;
	size_t file_search_len;
	char file_search_buf[4096];
	char file_search_last[256];
	struct wl_event_source *file_search_timer;
	/* Git project search state */
	char git_results_name[MODAL_MAX_RESULTS][128];
	char git_results_path[MODAL_MAX_RESULTS][PATH_MAX];
	time_t git_results_mtime[MODAL_MAX_RESULTS];
	int git_result_count;
	pid_t git_search_pid;
	int git_search_fd;
	struct wl_event_source *git_search_event;
	size_t git_search_len;
	char git_search_buf[4096];
	int git_search_done;
	char git_search_last[256];
	/* Cached results scene for fast navigation */
	struct wlr_scene_tree *results_tree;
	int last_scroll;
	int last_selected;
	/* Cached highlight rects for instant navigation */
	struct wlr_scene_rect *row_highlights[MODAL_MAX_RESULTS];
	int row_highlight_count;
} ModalOverlay;

/* Nixpkgs package entry for install popup */
typedef struct {
	char name[128];
	char name_lower[128]; /* lowercase for case-insensitive search */
	char version[64];     /* package version */
	int installed;        /* 1 if package is in packages.nix */
} NixpkgEntry;

/* Nixpkgs install popup */
typedef struct {
	struct wlr_scene_tree *tree;
	struct wlr_scene_tree *bg;
	int visible;
	int x, y, width, height;
	char search[256];
	int search_len;
	char search_rendered[256]; /* last rendered search text */
	struct wlr_scene_tree *search_field_tree; /* cached search field for fast updates */
	int result_count;
	int result_indices[MODAL_MAX_RESULTS]; /* indices into nixpkg_entries */
	int selected;
	int scroll;
	/* Cached results scene for fast navigation */
	struct wlr_scene_tree *results_tree;
	int last_scroll;
	int last_selected;
	/* Cached highlight rects for instant navigation */
	struct wlr_scene_rect *row_highlights[MODAL_MAX_RESULTS];
	int row_highlight_count;
} NixpkgsOverlay;

typedef struct {
	char name[128];
	char exec[256];
	char name_lower[128];
	int used;
	int prefers_dgpu;  /* 1 if PrefersNonDefaultGPU=true or X-KDE-RunOnDiscreteGpu=true */
} DesktopEntry;

typedef struct {
	struct wlr_scene_tree *tree;
	struct wlr_scene_tree *bg;
	int width;
	int height;
	int visible;
	int anchor_x;
	int anchor_y;
	int anchor_w;
	uint64_t suppress_refresh_until_ms;
	uint64_t hover_start_ms;
} NetPopup;

typedef struct {
	void (*fn)(void);
	uint64_t next_due_ms;
} StatusRefreshTask;

static const float net_menu_row_bg[4] = {0.15f, 0.15f, 0.15f, 1.0f};
static const float net_menu_row_bg_hover[4] = {0.25f, 0.25f, 0.25f, 1.0f};
static const double status_icon_scale = 2.0;

typedef struct WifiNetwork {
	char ssid[128];
	int strength;
	int secure;
	struct wl_list link;
} WifiNetwork;

typedef struct VpnConnection {
	char name[128];
	char uuid[64];
	int active;  /* 1 = currently connected */
	struct wl_list link;
} VpnConnection;

typedef struct {
	struct wlr_scene_tree *tree;
	struct wlr_scene_tree *bg;
	struct wlr_scene_tree *submenu_tree;
	struct wlr_scene_tree *submenu_bg;
	int width, height;
	int submenu_width, submenu_height;
	int x, y;
	int submenu_x, submenu_y;
	int visible;
	int submenu_visible;
	int hover;           /* 0 = WiFi row, 1 = VPN row, -1 = none */
	int submenu_hover;
	int submenu_type;    /* 0 = WiFi submenu, 1 = VPN submenu */
	struct wl_list entries;   /* main menu entries */
	struct wl_list networks;  /* WifiNetwork list */
} NetMenu;

typedef struct {
	struct wlr_scene_tree *tree;
	struct wlr_scene_tree *bg;
	int visible;
	int width, height;
	char ssid[128];
	char password[256];
	int password_len;
	int cursor_pos;
	int button_hover;  /* 0 = none, 1 = connect button */
	int connecting;    /* 1 = connection in progress */
	int error;         /* 1 = last connection failed */
	int try_saved;     /* 1 = trying saved credentials first */
	pid_t connect_pid;
	int connect_fd;
	struct wl_event_source *connect_event;
} WifiPasswordPopup;

typedef struct {
	struct wlr_scene_tree *tree;
	struct wlr_scene_tree *bg;
	int visible;
	int width, height;
	char title[128];
	char password[256];
	int password_len;
	int cursor_pos;
	int button_hover;  /* 0 = none, 1 = OK button */
	int running;       /* 1 = command in progress */
	int error;         /* 1 = auth failed */
	char pending_cmd[1024];  /* command to run after auth */
	char pending_pkg[140];   /* package name for toast */
	pid_t sudo_pid;
	int sudo_fd;
	struct wl_event_source *sudo_event;
	struct wl_event_source *wait_timer; /* timer to poll child exit */
} SudoPopup;

/* On-screen keyboard for HTPC mode */
#define OSK_ROWS 5
#define OSK_COLS 12
typedef struct {
	struct wlr_scene_tree *tree;
	struct wlr_scene_tree *bg;
	int visible;
	int width, height;
	int sel_row, sel_col;        /* currently selected key */
	int shift_active;            /* 1 = shift/uppercase mode */
	int caps_lock;               /* 1 = caps lock on */
	char input_buffer[1024];     /* text being composed */
	int input_len;
	int input_cursor;
	void (*callback)(const char *text, void *data);  /* called when Enter pressed */
	void *callback_data;
	/* Target client for key injection */
	struct wlr_surface *target_surface;
} OnScreenKeyboard;

/* Gamepad menu item */
typedef struct {
	const char *label;
	const char *command;
} GamepadMenuItem;

/* Gamepad controller menu popup */
typedef struct {
	struct wlr_scene_tree *tree;
	struct wlr_scene_tree *bg;
	struct wlr_scene_tree *dim;  /* fullscreen dim overlay */
	int visible;
	int x, y;      /* position on screen */
	int width, height;
	int selected;  /* currently selected menu item (0-2) */
	int item_count;
} GamepadMenu;

/* PC Gaming service types */
typedef enum {
	GAMING_SERVICE_STEAM = 0,
	GAMING_SERVICE_HEROIC,
	GAMING_SERVICE_LUTRIS,
	GAMING_SERVICE_BOTTLES,
	GAMING_SERVICE_COUNT
} GamingServiceType;

/* Individual game entry */
typedef struct GameEntry {
	char id[64];           /* Unique ID (Steam appid, Epic app name, etc.) */
	char name[256];        /* Display name */
	char icon_path[512];   /* Path to icon/cover art */
	char launch_cmd[1024]; /* Command to launch the game */
	GamingServiceType service;
	int installed;         /* 1 if installed, 0 if in library but not installed */
	int playtime_minutes;  /* Total playtime in minutes */
	int is_game;           /* 1 if actual game, 0 if dlc/tool/etc */
	time_t acquired_time;  /* When the game was acquired (epoch seconds) */
	int controller_support; /* 0=none, 1=partial, 2=full */
	int deck_verified;     /* 0=unknown, 1=unsupported, 2=playable, 3=verified */
	int is_installing;     /* 1 if currently being installed */
	int install_progress;  /* Installation progress 0-100 */
	struct wlr_buffer *icon_buf;  /* Cached scaled icon buffer */
	int icon_w, icon_h;    /* Loaded icon dimensions */
	int icon_loaded;       /* 1 if icon was loaded (or attempted) */
	/* Per-game GPU-specific launch parameters (from config) */
	char launch_params_nvidia[512];  /* Launch params when NVIDIA dGPU detected */
	char launch_params_amd[512];     /* Launch params when AMD dGPU detected */
	char launch_params_intel[512];   /* Launch params when Intel dGPU detected */
	int has_custom_params;           /* 1 if game has custom params in config */
	struct GameEntry *next;
} GameEntry;

/* PC Gaming view state */
typedef struct {
	struct wlr_scene_tree *tree;
	struct wlr_scene_tree *bg;
	struct wlr_scene_tree *grid;
	struct wlr_scene_tree *sidebar;
	int visible;
	unsigned int view_tag;     /* Tag this view belongs to (for HTPC mode) */
	int width, height;
	int scroll_offset;     /* Vertical scroll offset in pixels */
	int selected_idx;      /* Currently selected game index */
	int hover_idx;         /* Mouse hover index */
	int game_count;
	int cols;              /* Number of columns in grid */
	int service_filter;    /* -1 = all, or specific GamingServiceType */
	GameEntry *games;      /* Linked list of games */
	int needs_refresh;     /* 1 if game list needs refresh */
	uint64_t last_refresh_ms;
	/* Install popup */
	struct wlr_scene_tree *install_popup;
	struct wlr_scene_tree *install_dim;
	int install_popup_visible;
	int install_popup_selected;  /* 0 = Install, 1 = Close */
	char install_game_id[64];
	char install_game_name[256];
	GamingServiceType install_game_service;
} PcGamingView;

/* Retro gaming console types */
typedef enum {
	RETRO_NES = 0,
	RETRO_SNES,
	RETRO_N64,
	RETRO_GAMECUBE,
	RETRO_WII,
	RETRO_SWITCH,
	RETRO_CONSOLE_COUNT
} RetroConsole;

static const char *retro_console_names[] = {
	"NES", "SNES", "Nintendo 64", "GameCube", "Wii", "Switch"
};

/* Retro gaming view */
typedef struct {
	struct wlr_scene_tree *tree;
	struct wlr_scene_tree *dim;
	struct wlr_scene_tree *menu_bar;
	int visible;
	unsigned int view_tag;     /* Tag this view belongs to (for HTPC mode) */
	int width, height;
	int selected_console;      /* Currently selected console */
	int target_console;        /* Target for animation */
	int anim_direction;        /* Animation direction: -1=left, 1=right, 0=none */
	float slide_offset;        /* Animation offset for smooth slide (-1.0 to 1.0) */
	uint64_t slide_start_ms;   /* Animation start time */
} RetroGamingView;

/* Media types for Movies/TV-shows grid views */
typedef enum {
	MEDIA_VIEW_MOVIES = 0,
	MEDIA_VIEW_TVSHOWS = 1
} MediaViewType;

/* Individual media entry (movie or TV episode) */
typedef struct MediaItem {
	int id;                    /* Database ID */
	int type;                  /* 0=movie, 1=tvshow, 2=episode */
	char title[256];           /* Display title */
	char show_name[256];       /* For episodes: parent show name */
	int season;                /* For episodes */
	int episode;               /* For episodes */
	int duration;              /* Duration in seconds */
	int year;
	float rating;              /* TMDB rating 0-10 */
	char poster_path[512];     /* Path to poster image */
	char backdrop_path[512];   /* Path to backdrop */
	char overview[2048];       /* Plot summary */
	char genres[256];
	char episode_title[256];   /* Episode title from TMDB */
	char filepath[1024];       /* Path to media file for playback */
	int tmdb_total_seasons;    /* Total seasons from TMDB */
	int tmdb_total_episodes;   /* Total episodes from TMDB */
	int tmdb_episode_runtime;  /* Typical episode runtime in minutes from TMDB */
	char tmdb_status[64];      /* "Returning Series", "Ended", "Canceled" */
	char tmdb_next_episode[16]; /* YYYY-MM-DD of next episode */
	struct wlr_buffer *poster_buf;  /* Cached scaled poster buffer */
	struct wlr_buffer *backdrop_buf; /* Cached scaled backdrop buffer */
	int poster_w, poster_h;    /* Loaded poster dimensions */
	int backdrop_w, backdrop_h;
	int poster_loaded;         /* 1 if poster was loaded (or attempted) */
	int backdrop_loaded;
	struct MediaItem *next;
} MediaItem;

/* Season info for TV shows */
typedef struct MediaSeason {
	int season;
	int episode_count;
	struct MediaSeason *next;
} MediaSeason;

/* Detail view focus area */
typedef enum {
	DETAIL_FOCUS_INFO = 0,     /* Main info area (play button) */
	DETAIL_FOCUS_SEASONS,      /* Season list (TV shows only) */
	DETAIL_FOCUS_EPISODES      /* Episode list (TV shows only) */
} DetailFocusArea;

/* Media grid view (used for Movies and TV-shows) */
typedef struct {
	struct wlr_scene_tree *tree;
	struct wlr_scene_tree *grid;
	struct wlr_scene_tree *detail_panel;  /* Right side panel with details */
	int visible;
	unsigned int view_tag;     /* Tag this view belongs to (for HTPC mode) */
	int width, height;
	int scroll_offset;         /* Vertical scroll offset */
	int selected_idx;          /* Currently selected item */
	int item_count;
	int cols;                  /* Number of columns in grid */
	MediaItem *items;          /* Linked list of items */
	MediaViewType view_type;   /* Movies or TV-shows */
	int needs_refresh;
	uint64_t last_refresh_ms;
	/* Server connection */
	char server_url[256];      /* http://localhost:8080 */
	/* Change detection */
	uint32_t last_data_hash;   /* Simple hash of last response to detect changes */

	/* Detail view state */
	int in_detail_view;        /* 1 if showing detail view, 0 for grid */
	MediaItem *detail_item;    /* Item being shown in detail view */
	DetailFocusArea detail_focus;  /* Current focus area in detail view */

	/* TV show detail view */
	MediaSeason *seasons;      /* List of seasons for current show */
	int season_count;
	int selected_season_idx;   /* Currently selected season */
	int selected_season;       /* Actual season number */
	MediaItem *episodes;       /* Episodes for selected season */
	int episode_count;
	int selected_episode_idx;  /* Currently selected episode */
	int season_scroll_offset;  /* Scroll offset for season list */
	int episode_scroll_offset; /* Scroll offset for episode list */
} MediaGridView;

/* Axis calibration info */
typedef struct AxisCalibration {
	int min, max, center;  /* Range and center value */
	int flat;              /* Deadzone (from device) */
} AxisCalibration;

/* Tracked gamepad device */
typedef struct GamepadDevice {
	int fd;
	char path[64];
	char name[128];
	char bluez_path[256];  /* Cached BlueZ D-Bus path for async disconnect */
	struct wl_event_source *event_source;
	struct wl_list link;
	/* Joystick axis values (raw from device) */
	int left_x, left_y;    /* Left stick */
	int right_x, right_y;  /* Right stick */
	/* Axis calibration (read from device) */
	AxisCalibration cal_lx, cal_ly;  /* Left stick */
	AxisCalibration cal_rx, cal_ry;  /* Right stick */
	/* Inactivity tracking */
	int64_t last_activity_ms;  /* Last input timestamp (monotonic ms) */
	int suspended;             /* 1 if gamepad is suspended/powered off */
	int grabbed;               /* 1 if EVIOCGRAB is active (exclusive access) */
} GamepadDevice;

typedef struct TrayMenuEntry {
	int id;
	int enabled;
	int is_separator;
	int depth;
	int has_submenu;
	int toggle_type;
	int toggle_state;
	int y;
	int height;
	char label[256];
	struct wl_list link;
} TrayMenuEntry;

typedef struct {
	struct wlr_scene_tree *tree;
	struct wlr_scene_tree *bg;
	int width;
	int height;
	int visible;
	int x;
	int y;
	char service[128];
	char menu_path[128];
	struct wl_list entries;
} TrayMenu;

struct StatusBar {
	struct wlr_scene_tree *tree;
	struct wlr_box area;
	StatusModule clock;
	StatusModule cpu;
	StatusModule battery;
	StatusModule net;
	StatusModule light;
	StatusModule mic;
	StatusModule volume;
	StatusModule ram;
	StatusModule tags;
	StatusModule traylabel;
	StatusModule bluetooth;
	StatusModule steam;
	StatusModule discord;
	CpuPopup cpu_popup;
	RamPopup ram_popup;
	BatteryPopup battery_popup;
	NetPopup net_popup;
	TrayMenu tray_menu;
	NetMenu net_menu;
	StatusModule sysicons;
};

typedef struct TrayItem {
	char service[128];
	char path[128];
	char label[64];
	char menu[128];
	int has_menu;
	int icon_tried;
	int icon_failed;
	int x;
	int w;
	int icon_w;
	int icon_h;
	struct wlr_buffer *icon_buf;
	struct wl_list link;
} TrayItem;

struct PixmanBuffer {
	struct wlr_buffer base;
	pixman_image_t *image;
	void *data;
	uint32_t drm_format;
	int stride;
	int owns_data;
};

struct CpuSample {
	unsigned long long idle;
	unsigned long long total;
};

static void
drawrect(struct wlr_scene_tree *parent, int x, int y,
		int width, int height, const float color[static 4])
{
	struct wlr_scene_rect *r;
	float col[4];

	if (!parent || width <= 0 || height <= 0)
		return;

	col[0] = color[0];
	col[1] = color[1];
	col[2] = color[2];
	col[3] = color[3];

	r = wlr_scene_rect_create(parent, width, height, col);
	if (r)
		wlr_scene_node_set_position(&r->node, x, y);
}

static void
drawhoverrect(struct wlr_scene_tree *parent, int x, int y,
		int width, int height, const float color[static 4], float fade)
{
	struct wlr_scene_rect *r;
	float col[4];

	if (!parent || width <= 0 || height <= 0)
		return;

	if (fade < 0.0f)
		fade = 0.0f;
	if (fade > 1.0f)
		fade = 1.0f;

	col[0] = color[0];
	col[1] = color[1];
	col[2] = color[2];
	col[3] = color[3] * fade;

	r = wlr_scene_rect_create(parent, width, height, col);
	if (r)
		wlr_scene_node_set_position(&r->node, x, y);
}

static void UNUSED
drawroundedrect(struct wlr_scene_tree *parent, int x, int y,
        int width, int height, const float color[static 4])
{
	int radius, yy, inset_top, inset_bottom, inset, start, h, w;
	struct wlr_scene_rect *r;

	if (!parent || width <= 0 || height <= 0)
		return;

	radius = MIN(4, MIN(width, height) / 4);

	yy = 0;
	while (yy < height) {
		inset_top = radius ? MAX(0, radius - yy) : 0;
		inset_bottom = radius ? MAX(0, radius - ((height - 1) - yy)) : 0;
		inset = MAX(inset_top, inset_bottom);
		start = yy;

		while (yy < height) {
			inset_top = radius ? MAX(0, radius - yy) : 0;
			inset_bottom = radius ? MAX(0, radius - ((height - 1) - yy)) : 0;
			if (MAX(inset_top, inset_bottom) != inset)
				break;
			yy++;
		}

		h = yy - start;
		w = width - 2 * inset;
		if (h > 0 && w > 0) {
			r = wlr_scene_rect_create(parent, w, h, color);
			if (r)
				wlr_scene_node_set_position(&r->node, x + inset, y + start);
		}
	}
}
typedef struct {
	/* Must keep this field first */
	unsigned int type; /* XDGShell or X11* */

	Monitor *mon;
	struct wlr_scene_tree *scene;
	struct wlr_scene_rect *border[4]; /* top, bottom, left, right */
	struct wlr_scene_tree *scene_surface;
	struct wl_list link;
	struct wl_list flink;
	struct wlr_box geom; /* layout-relative, includes border */
	struct wlr_box prev; /* layout-relative, includes border */
	struct wlr_box bounds; /* only width and height are used */
	union {
		struct wlr_xdg_surface *xdg;
		struct wlr_xwayland_surface *xwayland;
	} surface;
	struct wlr_xdg_toplevel_decoration_v1 *decoration;
	struct wl_listener commit;
	struct wl_listener map;
	struct wl_listener maximize;
	struct wl_listener unmap;
	struct wl_listener destroy;
	struct wl_listener set_title;
	struct wl_listener fullscreen;
	struct wl_listener set_decoration_mode;
	struct wl_listener destroy_decoration;
#ifdef XWAYLAND
	struct wl_listener activate;
	struct wl_listener associate;
	struct wl_listener minimize;
	struct wl_listener dissociate;
	struct wl_listener configure;
	struct wl_listener set_hints;
#endif
	unsigned int bw;
	uint32_t tags;
	int isfloating, isurgent, isfullscreen, issticky, was_tiled;
	uint32_t resize; /* configure serial of a pending resize */
	int pending_resize_w, pending_resize_h; /* last requested size while pending */
	struct wlr_box old_geom;
	char *output;
	/* Frame rate tracking for video detection */
	uint64_t frame_times[32];    /* circular buffer of commit timestamps (ms) */
	int frame_time_idx;          /* next write index */
	int frame_time_count;        /* number of samples collected */
	float detected_video_hz;     /* detected video Hz (0 = not video), exact value */
	struct wlr_buffer *last_buffer; /* track buffer changes for frame detection */
	int video_detect_retries;    /* retry counter for video detection (max 3) */
	int video_detect_phase;      /* 0=scanning, 1=analyzing, 2=done */
} Client;

typedef struct {
	uint32_t mod;
	xkb_keysym_t keysym;
	void (*func)(const Arg *);
	const Arg arg;
} Key;

typedef struct {
	struct wlr_keyboard_group *wlr_group;

	int nsyms;
	const xkb_keysym_t *keysyms; /* invalid if nsyms == 0 */
	uint32_t mods; /* invalid if nsyms == 0 */
	struct wl_event_source *key_repeat_source;

	struct wl_listener modifiers;
	struct wl_listener key;
	struct wl_listener destroy;
} KeyboardGroup;

typedef struct {
	struct wlr_text_input_v3 *text_input;
	struct wl_list link;
	struct wl_listener enable;
	struct wl_listener disable;
	struct wl_listener commit;
	struct wl_listener destroy;
} TextInput;

typedef struct {
	/* Must keep this field first */
	unsigned int type; /* LayerShell */

	Monitor *mon;
	struct wlr_scene_tree *scene;
	struct wlr_scene_tree *popups;
	struct wlr_scene_layer_surface_v1 *scene_layer;
	struct wl_list link;
	int mapped;
	struct wlr_layer_surface_v1 *layer_surface;

	struct wl_listener destroy;
	struct wl_listener unmap;
	struct wl_listener surface_commit;
} LayerSurface;

typedef struct {
	const char *symbol;
	void (*arrange)(Monitor *);
} Layout;

struct Monitor {
	struct wl_list link;
	struct wlr_output *wlr_output;
	struct wlr_scene_output *scene_output;
	struct wlr_scene_rect *fullscreen_bg; /* See createmon() for info */
	struct wl_listener frame;
	struct wl_listener destroy;
	struct wl_listener request_state;
	struct wl_listener destroy_lock_surface;
	struct wlr_session_lock_surface_v1 *lock_surface;
	struct wlr_box m; /* monitor area, layout-relative */
	struct wlr_box w; /* window area, layout-relative */
	struct wl_list layers[4]; /* LayerSurface.link */
	StatusBar statusbar;
	ModalOverlay modal;
	NixpkgsOverlay nixpkgs;
	WifiPasswordPopup wifi_popup;
	SudoPopup sudo_popup;
	OnScreenKeyboard osk;
	GamepadMenu gamepad_menu;
	PcGamingView pc_gaming;
	RetroGamingView retro_gaming;
	MediaGridView movies_view;
	MediaGridView tvshows_view;
	const Layout *lt[2];
	int gaps;
	int showbar;
	unsigned int seltags;
	unsigned int sellt;
	uint32_t tagset[2];
	float mfact;
	int gamma_lut_changed;
	int nmaster;
	char ltsymbol[16];
	int asleep;
	LayoutNode *root[MAX_TAGS];
	/* Video refresh rate matching */
	struct wlr_output_mode *original_mode; /* saved mode before video switch */
	int video_mode_active;                 /* 1 if currently in video-optimized mode */
	int vrr_capable;                       /* 1 if monitor supports VRR/FreeSync/G-Sync */
	int vrr_active;                        /* 1 if VRR is currently active for video */
	float vrr_target_hz;                   /* target Hz when using VRR for video */
	/* Dynamic game VRR - matches display to game framerate */
	int game_vrr_active;                   /* 1 if game VRR is currently active */
	float game_vrr_target_fps;             /* current target FPS for game VRR */
	float game_vrr_last_fps;               /* last stable FPS (for hysteresis) */
	uint64_t game_vrr_last_change_ns;      /* timestamp of last VRR adjustment */
	int game_vrr_stable_frames;            /* frames at current FPS (for stability) */
	/* Hz OSD for refresh rate changes */
	struct wlr_scene_tree *hz_osd_tree;
	struct wlr_scene_tree *hz_osd_bg;
	int hz_osd_visible;
	/* Frame timing tracking for optimal frame pacing (inspired by Gamescope) */
	uint64_t last_frame_ns;           /* timestamp of last frame commit */
	uint64_t last_commit_duration_ns; /* how long the last commit took */
	uint64_t rolling_commit_time_ns;  /* rolling average of commit times */
	int frames_since_content_change;  /* frames since last buffer change */
	/* Direct scanout tracking */
	int direct_scanout_active;        /* 1 if direct scanout is currently happening */
	int direct_scanout_notified;      /* 1 if we already showed the notification */
	/* Toast notification */
	struct wlr_scene_tree *toast_tree;
	struct wl_event_source *toast_timer;
	int toast_visible;
	/* Advanced frame pacing for games (compositor-controlled) */
	struct wl_listener present;       /* presentation feedback listener */
	uint64_t last_present_ns;         /* timestamp of last vblank/present */
	uint64_t present_interval_ns;     /* measured interval between presents */
	uint64_t target_present_ns;       /* when we want to present next frame */
	int pending_game_frame;           /* 1 if game submitted a frame we're holding */
	uint64_t game_frame_submit_ns;    /* when game submitted the pending frame */
	uint64_t game_frame_intervals[8]; /* circular buffer of game frame intervals */
	int game_frame_interval_idx;      /* index into circular buffer */
	int game_frame_interval_count;    /* count of samples */
	float estimated_game_fps;         /* estimated game framerate */
	int frame_pacing_active;          /* 1 if compositor frame pacing is active */
	/* Frame pacing statistics */
	uint64_t frames_presented;        /* total frames presented */
	uint64_t frames_dropped;          /* frames dropped due to late submission */
	uint64_t frames_held;             /* frames held for better timing */
	uint64_t total_latency_ns;        /* cumulative latency for averaging */
	/* FPS limiter */
	uint64_t fps_limit_last_frame_ns; /* timestamp of last frame_done sent */
	uint64_t fps_limit_interval_ns;   /* minimum interval between frames */
	/* Frame doubling/tripling for smooth low-FPS playback without VRR */
	int frame_repeat_enabled;         /* 1 if frame repeat is active */
	int frame_repeat_count;           /* how many times to show current frame (1=normal, 2=double, 3=triple) */
	int frame_repeat_current;         /* current repeat iteration (0 to repeat_count-1) */
	uint64_t frame_repeat_interval_ns; /* interval between repeated frames */
	uint64_t last_game_buffer_id;     /* track when game submits new buffer */
	uint64_t frames_repeated;         /* stats: total frames that were repeated */
	/* Adaptive frame pacing (non-VRR smoothing) */
	int adaptive_pacing_enabled;      /* 1 if adaptive pacing without VRR is active */
	float target_frame_time_ms;       /* ideal frame time based on game fps */
	uint64_t pacing_adjustment_ns;    /* fine-tune timing to reduce judder */
	int judder_score;                 /* 0-100, lower is better */
	/* Predictive frame timing */
	uint64_t predicted_next_frame_ns; /* when we expect game to submit next frame */
	uint64_t frame_variance_ns;       /* variance in frame times (jitter measure) */
	int frames_early;                 /* frames that arrived earlier than predicted */
	int frames_late;                  /* frames that arrived later than predicted */
	float prediction_accuracy;        /* 0-100%, how accurate our predictions are */
	/* Input latency tracking */
	uint64_t last_input_ns;           /* timestamp of last input event */
	uint64_t input_to_frame_ns;       /* time from input to frame commit */
	uint64_t min_input_latency_ns;    /* minimum observed input latency */
	uint64_t max_input_latency_ns;    /* maximum observed input latency */
	/* Memory pressure */
	int memory_pressure;              /* 0-100, current memory usage % */
	/* HDR and color depth support */
	int supports_10bit;               /* 1 if monitor supports 10-bit color */
	int render_10bit_active;          /* 1 if 10-bit rendering is currently active */
	int max_bpc;                      /* maximum bits per channel (8, 10, 12, 16) */
	int hdr_capable;                  /* 1 if monitor reports HDR support in EDID */
	int hdr_active;                   /* 1 if HDR is currently enabled */
	/* Stats panel (sliding overlay from right) */
	struct wlr_scene_tree *stats_panel_tree;
	struct wl_event_source *stats_panel_timer;
	struct wl_event_source *stats_panel_anim_timer;
	int stats_panel_visible;
	int stats_panel_target_x;         /* target X position for animation */
	int stats_panel_current_x;        /* current X position during animation */
	int stats_panel_width;            /* panel width (25% of screen) */
	uint64_t stats_panel_anim_start;  /* animation start time */
	int stats_panel_animating;        /* 1 if currently animating */
};

typedef struct {
	const char *name;
	float mfact;
	int nmaster;
	float scale;
	const Layout *lt;
	enum wl_output_transform rr;
	int x, y;
} MonitorRule;

/* Monitor position slots for runtime configuration */
typedef enum {
	MON_POS_MASTER = 0,      /* Primary/master monitor */
	MON_POS_LEFT,            /* Left of master */
	MON_POS_RIGHT,           /* Right of master */
	MON_POS_TOP_LEFT,        /* Top-left (above left) */
	MON_POS_TOP_RIGHT,       /* Top-right (above right) */
	MON_POS_BOTTOM_LEFT,     /* Bottom-left */
	MON_POS_BOTTOM_RIGHT,    /* Bottom-right */
	MON_POS_AUTO,            /* Auto-placement */
	MON_POS_COUNT
} MonitorPosition;

/* Runtime monitor configuration */
typedef struct {
	char name[64];           /* Output name pattern (e.g., "HDMI-A-1", "DP-*") */
	MonitorPosition position;/* Position slot */
	int width;               /* 0 = auto (use preferred mode) */
	int height;              /* 0 = auto */
	float refresh;           /* 0 = auto (highest available) */
	float scale;             /* Display scale (default 1.0) */
	float mfact;             /* Master factor (default 0.55) */
	int nmaster;             /* Number of masters (default 1) */
	int enabled;             /* 1 = enabled, 0 = disabled */
	int transform;           /* WL_OUTPUT_TRANSFORM_* value */
} RuntimeMonitorConfig;

typedef struct {
	struct wlr_pointer_constraint_v1 *constraint;
	struct wl_listener destroy;
} PointerConstraint;

typedef struct {
	const char *id;
	const char *title;
	uint32_t tags;
	int isfloating;
	int monitor;
} Rule;

typedef struct {
	struct wlr_scene_tree *scene;

	struct wlr_session_lock_v1 *lock;
	struct wl_listener new_surface;
	struct wl_listener unlock;
	struct wl_listener destroy;
} SessionLock;

/* function declarations */
static void applybounds(Client *c, struct wlr_box *bbox);
static void applyrules(Client *c);
static void arrange(Monitor *m);
static int htpc_view_is_active(Monitor *m, unsigned int view_tag, int visible);
static void htpc_views_update_visibility(Monitor *m);
static void arrangelayer(Monitor *m, struct wl_list *list,
		struct wlr_box *usable_area, int exclusive);
static void arrangelayers(Monitor *m);
static void axisnotify(struct wl_listener *listener, void *data);
static void buttonpress(struct wl_listener *listener, void *data);
static void handle_pointer_button_internal(uint32_t button, uint32_t state, uint32_t time_msec);
static void chvt(const Arg *arg);
static void checkidleinhibitor(struct wlr_surface *exclude);
static void cleanup(void);
static void cleanupmon(struct wl_listener *listener, void *data);
static void cleanuplisteners(void);
static void closemon(Monitor *m);
static void commitlayersurfacenotify(struct wl_listener *listener, void *data);
static void commitnotify(struct wl_listener *listener, void *data);
static void commitpopup(struct wl_listener *listener, void *data);
static void createdecoration(struct wl_listener *listener, void *data);
static void createidleinhibitor(struct wl_listener *listener, void *data);
static void createkeyboard(struct wlr_keyboard *keyboard);
static KeyboardGroup *createkeyboardgroup(void);
static void createlayersurface(struct wl_listener *listener, void *data);
static void createlocksurface(struct wl_listener *listener, void *data);
static void createmon(struct wl_listener *listener, void *data);
static void createnotify(struct wl_listener *listener, void *data);
static void createpointer(struct wlr_pointer *pointer);
static void createpointerconstraint(struct wl_listener *listener, void *data);
static void createpopup(struct wl_listener *listener, void *data);
static void cursorconstrain(struct wlr_pointer_constraint_v1 *constraint);
static void cursorframe(struct wl_listener *listener, void *data);
static void cursorwarptohint(void);
static void destroydecoration(struct wl_listener *listener, void *data);
static void destroydragicon(struct wl_listener *listener, void *data);
static void destroyidleinhibitor(struct wl_listener *listener, void *data);
static void destroylayersurfacenotify(struct wl_listener *listener, void *data);
static void destroylock(SessionLock *lock, int unlocked);
static void destroylocksurface(struct wl_listener *listener, void *data);
static void destroynotify(struct wl_listener *listener, void *data);
static void destroypointerconstraint(struct wl_listener *listener, void *data);
static void destroysessionlock(struct wl_listener *listener, void *data);
static void destroykeyboardgroup(struct wl_listener *listener, void *data);
static Monitor *dirtomon(enum wlr_direction dir);
static void focusclient(Client *c, int lift);
static void focusmon(const Arg *arg);
static void warptomonitor(const Arg *arg);
static void tagtomonitornum(const Arg *arg);
static void focusstack(const Arg *arg);
static Client *focustop(Monitor *m);
static void fullscreennotify(struct wl_listener *listener, void *data);
static void gpureset(struct wl_listener *listener, void *data);
static void handlesig(int signo);
static void initstatusbar(Monitor *m);
static void incnmaster(const Arg *arg);
static void inputdevice(struct wl_listener *listener, void *data);
static int keybinding(uint32_t mods, xkb_keysym_t sym);
static void keypress(struct wl_listener *listener, void *data);
static void keypressmod(struct wl_listener *listener, void *data);
static int keyrepeat(void *data);
static void killclient(const Arg *arg);
static void layoutstatusbar(Monitor *m, const struct wlr_box *area,
		struct wlr_box *client_area);
static void locksession(struct wl_listener *listener, void *data);
static void mapnotify(struct wl_listener *listener, void *data);
static void maximizenotify(struct wl_listener *listener, void *data);
static void monocle(Monitor *m);
static void motionabsolute(struct wl_listener *listener, void *data);
static void motionnotify(uint32_t time, struct wlr_input_device *device, double sx,
		double sy, double sx_unaccel, double sy_unaccel);
static void motionrelative(struct wl_listener *listener, void *data);
static void moveresize(const Arg *arg);
static void outputmgrapply(struct wl_listener *listener, void *data);
static void outputmgrapplyortest(struct wlr_output_configuration_v1 *config, int test);
static void outputmgrtest(struct wl_listener *listener, void *data);
static void pointerfocus(Client *c, struct wlr_surface *surface,
		double sx, double sy, uint32_t time);
static void printstatus(void);
static void powermgrsetmode(struct wl_listener *listener, void *data);
static void quit(const Arg *arg);
static struct wlr_buffer *statusbar_buffer_from_argb32(const uint32_t *data, int width, int height);
static int ensure_cpu_icon_buffer(int target_h);
static void drop_cpu_icon_buffer(void);
static int ensure_light_icon_buffer(int target_h);
static void drop_light_icon_buffer(void);
static int ensure_ram_icon_buffer(int target_h);
static void drop_ram_icon_buffer(void);
static int ensure_battery_icon_buffer(int target_h);
static void drop_battery_icon_buffer(void);
static int ensure_clock_icon_buffer(int target_h);
static void drop_clock_icon_buffer(void);
static int ensure_mic_icon_buffer(int target_h);
static void drop_mic_icon_buffer(void);
static int ensure_volume_icon_buffer(int target_h);
static void drop_volume_icon_buffer(void);
static void renderclock(StatusModule *module, int bar_height, const char *text);
static void renderlight(StatusModule *module, int bar_height, const char *text);
static void rendernet(StatusModule *module, int bar_height, const char *text);
static void renderbattery(StatusModule *module, int bar_height, const char *text);
static void rendermon(struct wl_listener *listener, void *data);
static void outputpresent(struct wl_listener *listener, void *data);
static void rendervolume(StatusModule *module, int bar_height, const char *text);
static void rendermic(StatusModule *module, int bar_height, const char *text);
static void render_icon_label(StatusModule *module, int bar_height, const char *text,
		int (*ensure_icon)(int target_h), struct wlr_buffer **icon_buf,
		int *icon_w, int *icon_h, int min_text_w, int icon_gap,
		const float text_color[static 4]);
static void renderworkspaces(Monitor *m, StatusModule *module, int bar_height);
static void freestatusfont(void);
static int loadstatusfont(void);
static int status_text_width(const char *text);
static int tray_render_label(StatusModule *module, const char *text, int x, int bar_height,
		const float color[static 4]);
static void positionstatusmodules(Monitor *m);
static void refreshstatusclock(void);
static void refreshstatuslight(void);
static void refreshstatusvolume(void);
static void refreshstatusmic(void);
static void refreshstatusbattery(void);
static void refreshstatusnet(void);
static void request_public_ip_async_ex(int force);
static void request_public_ip_async(void);
static void stop_public_ip_fetch(void);
static void request_ssid_async(const char *iface);
static void stop_ssid_fetch(void);
static void refreshstatusicons(void);
static void refreshstatustags(void);
static void init_status_refresh_tasks(void);
static int status_should_render(StatusModule *module, int barh, const char *text,
		char *last_text, size_t last_len, int *last_h);
static void initial_status_refresh(void);
static void net_menu_hide_all(void);
static void net_menu_open(Monitor *m);
static void net_menu_render(Monitor *m);
static void net_menu_submenu_render(Monitor *m);
static void net_menu_update_hover(Monitor *m, double cx, double cy);
static void wifi_networks_clear(void);
static void request_wifi_scan(void);
static void wifi_scan_plan_rescan(void);
static int wifi_scan_event_cb(int fd, uint32_t mask, void *data);
static void connect_wifi_ssid(const char *ssid);
static void vpn_connections_clear(void);
static int vpn_scan_event_cb(int fd, uint32_t mask, void *data);
static void vpn_connect(const char *name);
static int vpn_connect_event_cb(int fd, uint32_t mask, void *data);
static void connect_wifi_with_prompt(const char *ssid, int secure);
static void wifi_popup_show(Monitor *m, const char *ssid);
static void wifi_popup_hide(Monitor *m);
static void wifi_popup_hide_all(void);
static void wifi_popup_render(Monitor *m);
static int wifi_popup_handle_key(Monitor *m, uint32_t mods, xkb_keysym_t sym);
static int wifi_popup_handle_click(Monitor *m, int lx, int ly, uint32_t button);
static Monitor *wifi_popup_visible_monitor(void);
static void wifi_popup_connect(Monitor *m);
static void wifi_try_saved_connect(Monitor *m, const char *ssid);
static int wifi_popup_connect_cb(int fd, uint32_t mask, void *data);
static void sudo_popup_show(Monitor *m, const char *title, const char *cmd, const char *pkg_name);
static void sudo_popup_hide(Monitor *m);
static void sudo_popup_hide_all(void);
static void sudo_popup_render(Monitor *m);
static int sudo_popup_handle_key(Monitor *m, uint32_t mods, xkb_keysym_t sym);
static Monitor *sudo_popup_visible_monitor(void);
static void sudo_popup_execute(Monitor *m);
static int sudo_popup_cb(int fd, uint32_t mask, void *data);
static int sudo_popup_wait_timer(void *data);
static void osk_show(Monitor *m, struct wlr_surface *target);
static void osk_hide(Monitor *m);
static void osk_hide_all(void);
static void osk_render(Monitor *m);
static int osk_handle_button(Monitor *m, int button, int value);
static Monitor *osk_visible_monitor(void);
static void osk_send_key(Monitor *m);
static void osk_send_backspace(Monitor *m);
static void osk_send_text(const char *text);
static int status_task_hover_active(void (*fn)(void));
static void trigger_status_task_now(void (*fn)(void));
static int public_ip_event_cb(int fd, uint32_t mask, void *data);
static int ssid_event_cb(int fd, uint32_t mask, void *data);
static void updatetaghover(Monitor *m, double cx, double cy);
static void updatenethover(Monitor *m, double cx, double cy);
static int tray_bus_event(int fd, uint32_t mask, void *data);
static int tray_method_register_item(sd_bus_message *m, void *userdata, sd_bus_error *ret_error);
static int tray_method_register_host(sd_bus_message *m, void *userdata, sd_bus_error *ret_error);
static int tray_property_get_registered(sd_bus *bus, const char *path, const char *interface,
        const char *property, sd_bus_message *reply, void *userdata, sd_bus_error *ret_error);
static int tray_property_get_host_registered(sd_bus *bus, const char *path, const char *interface,
        const char *property, sd_bus_message *reply, void *userdata, sd_bus_error *ret_error);
static int tray_property_get_protocol_version(sd_bus *bus, const char *path, const char *interface,
        const char *property, sd_bus_message *reply, void *userdata, sd_bus_error *ret_error);
static int tray_item_load_icon(TrayItem *it);
static int tray_render_label(StatusModule *module, const char *text, int x, int bar_height,
		const float color[static 4]);
static void tray_emit_host_registered(void);
static void tray_menu_clear(TrayMenu *menu);
static void tray_menu_hide(Monitor *m);
static void tray_menu_hide_all(void);
static int tray_item_get_menu_path(TrayItem *it);
static int tray_menu_open_at(Monitor *m, TrayItem *it, int icon_x);
static void tray_menu_render(Monitor *m);
static TrayMenuEntry *tray_menu_entry_at(Monitor *m, int lx, int ly);
static int tray_menu_send_event(TrayMenu *menu, TrayMenuEntry *entry, uint32_t time_msec);
static int tray_menu_parse_node(sd_bus_message *msg, TrayMenu *menu, int depth, int max_depth);
static int tray_menu_parse_node_body(sd_bus_message *msg, TrayMenu *menu, int depth, int max_depth);
static void tray_sanitize_label(const char *src, char *dst, size_t len);
static int tray_search_item_path(const char *service, const char *start_path,
		char *out, size_t outlen, int depth);
static int tray_find_item_path(const char *service, char *path, size_t pathlen);
static void tray_add_item(const char *service, const char *path, int emit_signals);
static void tray_scan_existing_items(void);
static void tray_update_icons_text(void);
static void tray_remove_item(const char *service);
static void rendertrayicons(Monitor *m, int bar_height);
static int tray_name_owner_changed(sd_bus_message *m, void *userdata, sd_bus_error *ret_error);
static int resolve_asset_path(const char *path, char *out, size_t len);
static void tray_init(void);
static TrayItem *tray_first_item(void);
static void tray_item_activate(TrayItem *it, int button, int context_menu, int x, int y);
static void requestdecorationmode(struct wl_listener *listener, void *data);
static void requeststartdrag(struct wl_listener *listener, void *data);
static void requestmonstate(struct wl_listener *listener, void *data);
static void resize(Client *c, struct wlr_box geo, int interact);
static void run(const char *startup_cmd);
static void set_adaptive_sync(Monitor *m, int enabled);
static void set_video_refresh_rate(Monitor *m, Client *c);
static void restore_max_refresh_rate(Monitor *m);
static int detect_10bit_support(Monitor *m);
static int set_drm_color_properties(Monitor *m, int max_bpc);
static int enable_10bit_rendering(Monitor *m);
static void init_monitor_color_settings(Monitor *m);
static int is_video_content(Client *c);
static void update_game_vrr(Monitor *m, float current_fps);
static void enable_game_vrr(Monitor *m);
static void disable_game_vrr(Monitor *m);
static int is_game_content(Client *c);
static int client_wants_tearing(Client *c);
static void track_client_frame(Client *c);
static float detect_video_framerate(Client *c);
static void check_fullscreen_video(void);
static void schedule_video_check(uint32_t ms);
static int enable_vrr_video_mode(Monitor *m, float video_hz);
static void disable_vrr_video_mode(Monitor *m);
static int set_custom_video_mode(Monitor *m, float exact_hz);
static void generate_cvt_mode(drmModeModeInfo *mode, int hdisplay, int vdisplay, float vrefresh);
static void show_hz_osd(Monitor *m, const char *msg);
static void hide_hz_osd(Monitor *m);
static int hz_osd_timeout(void *data);
static void testhzosd(const Arg *arg);
static void setcustomhz(const Arg *arg);
static void setcursor(struct wl_listener *listener, void *data);
static void setcursorshape(struct wl_listener *listener, void *data);
static void setfloating(Client *c, int floating);
static void setfullscreen(Client *c, int fullscreen);
static void setsticky(Client *c, int sticky);
static void setlayout(const Arg *arg);
static void setmfact(const Arg *arg);
static void setmon(Client *c, Monitor *m, uint32_t newtags);
static void setpsel(struct wl_listener *listener, void *data);
static void setsel(struct wl_listener *listener, void *data);
static void setup(void);
static void load_config(void);
static void reload_config(void);
static int config_watch_handler(int fd, uint32_t mask, void *data);
static void setup_config_watch(void);
static void init_keybindings(void);
static RuntimeMonitorConfig *find_monitor_config(const char *name);
static void calculate_monitor_position(Monitor *m, RuntimeMonitorConfig *cfg, int *out_x, int *out_y);
static void spawn(const Arg *arg);
static void startdrag(struct wl_listener *listener, void *data);
static void tag(const Arg *arg);
static void tagmon(const Arg *arg);
static void tile(Monitor *m);
static void togglefloating(const Arg *arg);
static void togglefullscreen(const Arg *arg);
static void togglefullscreenadaptivesync(const Arg *arg);
static void gamepanel(const Arg *arg);
static Monitor *stats_panel_visible_monitor(void);
static int stats_panel_handle_key(Monitor *m, xkb_keysym_t sym);
static void togglesticky(const Arg *arg);
static void togglegaps(const Arg *arg);
static void togglestatusbar(const Arg *arg);
static void toggletag(const Arg *arg);
static void toggleview(const Arg *arg);
static void modal_show(const Arg *arg);
static void modal_show_files(const Arg *arg);
static void modal_show_git(const Arg *arg);
static void modal_render(Monitor *m);
static void modal_render_results(Monitor *m);
static void modal_update_selection(Monitor *m);
static void modal_hide(Monitor *m);
static void modal_hide_all(void);
static Monitor *modal_visible_monitor(void);
static void modal_layout_metrics(int *btn_h, int *field_h, int *line_h, int *pad);
static int modal_max_visible_lines(Monitor *m);
static void modal_ensure_selection_visible(Monitor *m);
static int modal_handle_key(Monitor *m, uint32_t mods, xkb_keysym_t sym);
static void modal_file_search_clear_results(Monitor *m);
static void modal_file_search_stop(Monitor *m);
static void modal_file_search_start_mode(Monitor *m, int fallback);
static void modal_file_search_start(Monitor *m);
static int modal_file_search_event(int fd, uint32_t mask, void *data);
static int modal_file_search_debounce_cb(void *data);
static void modal_file_search_schedule(Monitor *m);
static void modal_git_search_clear_results(Monitor *m);
static void modal_git_search_stop(Monitor *m);
static void modal_git_search_start(Monitor *m);
static int modal_git_search_event(int fd, uint32_t mask, void *data);
static void git_cache_update_start(void);
static void file_cache_update_start(void);
static void nixpkgs_cache_update_start(void);
static void pc_gaming_cache_update_start(void);
static int cache_update_timer_cb(void *data);
static int nixpkgs_cache_timer_cb(void *data);
static void schedule_cache_update_timer(void);
static void schedule_nixpkgs_cache_timer(void);
static void update_game_mode(void);
static void htpc_mode_enter(void);
static void htpc_mode_exit(void);
static void steam_set_ge_proton_default(void);
static uint64_t get_time_ns(void);
static void htpc_mode_toggle(const Arg *arg);
static void config_expand_path(const char *src, char *dst, size_t dstlen);
static int any_client_fullscreen(void);
static Client *get_fullscreen_client(void);
static void modal_truncate_to_width(const char *src, char *dst, size_t len, int max_px);
static void shorten_path_display(const char *full, char *out, size_t len);
static int desktop_entry_cmp_used(const void *a, const void *b);
static int __attribute__((unused)) modal_match_name(const char *haystack, const char *needle);
static void modal_update_results(Monitor *m);
static void modal_render_search_field(Monitor *m);
static int modal_render_timer_cb(void *data);
static void modal_schedule_render(Monitor *m);
static void modal_prewarm(Monitor *m);
static void nixpkgs_show(const Arg *arg);
static void nixpkgs_hide(Monitor *m);
static void nixpkgs_hide_all(void);
static Monitor *nixpkgs_visible_monitor(void);
static void nixpkgs_render(Monitor *m);
static void nixpkgs_render_results(Monitor *m);
static void nixpkgs_update_selection(Monitor *m);
static void nixpkgs_update_results(Monitor *m);
static int nixpkgs_handle_key(Monitor *m, uint32_t mods, xkb_keysym_t sym);
static void nixpkgs_install_selected(Monitor *m);
static int toast_hide_timer(void *data);
static void toast_show(Monitor *m, const char *message, int duration_ms);
static void load_nixpkgs_cache(void);
static void load_installed_packages(void);
static void ensure_nixpkgs_cache_loaded(void);
static void ensure_desktop_entries_loaded(void);
static int ensure_nixpkg_ok_icon(int height);
static void ensure_shell_env(void);
static int should_use_dgpu(const char *cmd);
static void set_dgpu_env(void);
static void set_steam_env(void);
static int is_steam_cmd(const char *cmd);
static int is_steam_client(Client *c);
static int is_steam_popup(Client *c);
static int is_steam_child_process(pid_t pid);
static int is_steam_game(Client *c);
static int is_browser_client(Client *c);
static int looks_like_game(Client *c);
static int game_refocus_timer_cb(void *data);
static void schedule_game_refocus(Client *c, uint32_t ms);
static void detect_gpus(void);
static int cpu_popup_refresh_timeout(void *data);
static void schedule_cpu_popup_refresh(uint32_t ms);
static int popup_delay_timeout(void *data);
static void schedule_popup_delay(uint32_t ms);
static uint64_t monotonic_msec(void);

/* Gamepad controller menu functions */
static void gamepad_menu_show(Monitor *m);
static void gamepad_menu_hide(Monitor *m);
static void gamepad_menu_hide_all(void);
static Monitor *gamepad_menu_visible_monitor(void);
static void gamepad_menu_render(Monitor *m);
static int gamepad_menu_handle_button(Monitor *m, int button, int value);
static int gamepad_menu_handle_click(Monitor *m, int cx, int cy, uint32_t button);
static void gamepad_menu_select(Monitor *m);
static void gamepad_device_add(const char *path);
static void gamepad_device_remove(const char *path);
static int gamepad_event_cb(int fd, uint32_t mask, void *data);
static int gamepad_inotify_cb(int fd, uint32_t mask, void *data);
static void gamepad_scan_devices(void);
static void gamepad_setup(void);
static void gamepad_cleanup(void);
static int gamepad_cursor_timer_cb(void *data);
static int gamepad_pending_timer_cb(void *data);
static void gamepad_update_cursor(void);
static int gamepad_inactivity_timer_cb(void *data);
static void gamepad_turn_off_led_sysfs(GamepadDevice *gp);
static void gamepad_suspend(GamepadDevice *gp);
static void gamepad_resume(GamepadDevice *gp);
static int gamepad_any_monitor_active(void);
static void gamepad_grab(GamepadDevice *gp);
static void gamepad_ungrab(GamepadDevice *gp);
static void gamepad_update_grab_state(void);
static int gamepad_should_grab(void);
static void cec_switch_to_active_source(void);
static void steam_launch_bigpicture(void);
static void steam_kill(void);
static void live_tv_kill(void);

/* Bluetooth controller auto-pairing */
static int bt_bus_event_cb(int fd, uint32_t mask, void *data);
static void bt_controller_setup(void);
static void bt_controller_cleanup(void);
static int bt_scan_timer_cb(void *data);
static void bt_start_discovery(void);
static void bt_stop_discovery(void);
static int bt_is_gamepad_name(const char *name);
static void bt_pair_device(const char *path);
static void bt_connect_device(const char *path);
static void bt_trust_device(const char *path);
static int bt_device_signal_cb(sd_bus_message *m, void *userdata, sd_bus_error *error);

/* PC Gaming view functions */
static void pc_gaming_show(Monitor *m);
static void pc_gaming_hide(Monitor *m);
static void pc_gaming_hide_all(void);
static Monitor *pc_gaming_visible_monitor(void);
static void pc_gaming_render(Monitor *m);
static void pc_gaming_refresh_games(Monitor *m);
static void pc_gaming_free_games(Monitor *m);
static void pc_gaming_scan_steam(Monitor *m);
static void pc_gaming_scan_heroic(Monitor *m);
static int pc_gaming_handle_button(Monitor *m, int button, int value);
static int pc_gaming_handle_key(Monitor *m, uint32_t mods, xkb_keysym_t sym);
static void pc_gaming_launch_game(Monitor *m);
static void pc_gaming_scroll(Monitor *m, int delta);
static void pc_gaming_install_popup_show(Monitor *m, GameEntry *g);
static void pc_gaming_install_popup_hide(Monitor *m);
static void pc_gaming_install_popup_render(Monitor *m);
static int pc_gaming_install_popup_handle_button(Monitor *m, int button, int value);
static void pc_gaming_load_game_icon(GameEntry *g, int target_w, int target_h);
static void pc_gaming_fetch_steam_names_batch(Monitor *m);
static void pc_gaming_load_steam_playtime(Monitor *m);
static void pc_gaming_sort_by_acquired(Monitor *m);
static void pc_gaming_filter_non_games(Monitor *m);
static void pc_gaming_update_install_status(Monitor *m);
static int pc_gaming_cache_inotify_cb(int fd, uint32_t mask, void *data);
static void pc_gaming_cache_watch_setup(void);

/* Retro Gaming view functions */
static void retro_gaming_show(Monitor *m);
static void retro_gaming_hide(Monitor *m);
static void retro_gaming_hide_all(void);
static Monitor *retro_gaming_visible_monitor(void);
static void retro_gaming_render(Monitor *m);
static int retro_gaming_handle_button(Monitor *m, int button, int value);
static int retro_gaming_animate(void *data);

/* Media Grid view functions (Movies & TV-shows) */
static void media_view_show(Monitor *m, MediaViewType type);
static void media_view_hide(Monitor *m, MediaViewType type);
static void media_view_hide_all(void);
static void media_view_render(Monitor *m, MediaViewType type);
static int media_view_refresh(Monitor *m, MediaViewType type);
static int media_view_poll_timer_cb(void *data);
static void media_view_free_items(MediaGridView *view);
static int media_view_handle_button(Monitor *m, MediaViewType type, int button, int value);
static int media_view_handle_key(Monitor *m, MediaViewType type, xkb_keysym_t sym);
static void media_view_scroll(Monitor *m, MediaViewType type, int delta);
static void media_view_load_poster(MediaItem *item, int target_w, int target_h);
static Monitor *media_view_visible_monitor(void);

static void rendercpu(StatusModule *module, int bar_height, const char *text);
static void rendercpupopup(Monitor *m);
static int cpu_popup_clamped_x(Monitor *m, CpuPopup *p);
static int cpu_popup_hover_index(Monitor *m, CpuPopup *p);
static int cpu_proc_cmp(const void *a, const void *b);
static int kill_processes_with_name(const char *name);
static int cpu_proc_is_critical(pid_t pid, const char *name);
static int read_top_cpu_processes(CpuPopup *p);
static int cpu_popup_handle_click(Monitor *m, int lx, int ly, uint32_t button);
static void renderrampopup(Monitor *m);
static int ram_popup_clamped_x(Monitor *m, RamPopup *p);
static int ram_popup_hover_index(Monitor *m, RamPopup *p);
static int ram_proc_cmp(const void *a, const void *b);
static int read_top_ram_processes(RamPopup *p);
static int ram_popup_handle_click(Monitor *m, int lx, int ly, uint32_t button);
static int ram_popup_refresh_timeout(void *data);
static void schedule_ram_popup_refresh(uint32_t ms);
static void renderbatterypopup(Monitor *m);
static int battery_popup_clamped_x(Monitor *m, BatteryPopup *p);
static void read_battery_info(BatteryPopup *p);
static void updatebatteryhover(Monitor *m, double cx, double cy);
static void renderram(StatusModule *module, int bar_height, const char *text);
static void refreshstatuscpu(void);
static void refreshstatusram(void);
static int handlestatusscroll(struct wlr_pointer_axis_event *event);
static int scrollsteps(const struct wlr_pointer_axis_event *event);
static int updatestatuscpu(void *data);
static int updatestatusclock(void *data);
static int updatehoverfade(void *data);
static void schedule_hover_timer(void);
static int readcpustats(struct CpuSample *out, int maxcount);
static int readmeminfo(unsigned long long *total_kb, unsigned long long *avail_kb);
static int set_backlight_percent(double percent);
static int set_backlight_relative(double delta_percent);
static int set_pipewire_volume(double percent);
static int set_pipewire_mute(int mute);
static int toggle_pipewire_mute(void);
static int pipewire_sink_is_headset(void);
static int set_pipewire_mic_volume(double percent);
static int set_pipewire_mic_mute(int mute);
static int toggle_pipewire_mic_mute(void);
static double pipewire_mic_volume_percent(void);
static void updatecpuhover(Monitor *m, double cx, double cy);
static void updateramhover(Monitor *m, double cx, double cy);
static void set_status_task_due(void (*fn)(void), uint64_t due_ms);
static double net_bytes_to_rate(unsigned long long cur, unsigned long long prev,
		double elapsed);
static void fix_tray_argb32(uint32_t *pixels, size_t count, int use_rgba_order);
static double ramused_mb(void);
static double cpuaverage(void);
static double battery_percent(void);
static void applyxkbdefaultsfromsystem(struct xkb_rule_names *names);
static struct xkb_rule_names getxkbrules(void);
static double backlight_percent(void);
static double pipewire_volume_percent(int *is_headset_out);
static void volume_invalidate_cache(int is_headset);
static int findbacklightdevice(char *brightness_path, size_t brightness_len,
		char *max_path, size_t max_len);
static int set_backlight_relative(double delta_percent);
static void apply_startup_defaults(void);
static int findbatterydevice(char *capacity_path, size_t capacity_len);
static int findbluetoothdevice(void);
static int is_process_running(const char *name);
static Client *find_client_by_app_id(const char *app_id);
static Client *find_discord_client(void);
static void focus_or_launch_app(const char *app_id, const char *launch_cmd);
static void schedule_status_timer(void);
static void schedule_next_status_refresh(void);
static struct wlr_buffer *statusbar_scaled_buffer_from_argb32_raw(const uint32_t *data,
		int width, int height, int target_h);
static struct wlr_buffer *statusbar_buffer_from_argb32_raw(const uint32_t *data, int width, int height);
static struct wlr_buffer *statusbar_buffer_from_glyph(const struct fcft_glyph *glyph);
static struct wlr_buffer *statusbar_scaled_buffer_from_argb32(const uint32_t *data,
		int width, int height, int target_h);
static void unlocksession(struct wl_listener *listener, void *data);
static void unmaplayersurfacenotify(struct wl_listener *listener, void *data);
static void unmapnotify(struct wl_listener *listener, void *data);
static void updatemons(struct wl_listener *listener, void *data);
static void updatetitle(struct wl_listener *listener, void *data);
static void urgent(struct wl_listener *listener, void *data);
static void view(const Arg *arg);
static void virtualkeyboard(struct wl_listener *listener, void *data);
static void virtualpointer(struct wl_listener *listener, void *data);
static void warpcursor(const Client *c);
static const char *pick_resize_handle(const Client *c, double cx, double cy);
static const char *resize_cursor_from_dirs(int dx, int dy);
static LayoutNode *closest_split_node(LayoutNode *client_node, int want_vert,
        double pointer, double *out_ratio, struct wlr_box *out_box,
        double *out_dist);
static void apply_resize_axis_choice(void);
static int resize_should_update(uint32_t time);
static Monitor *xytomon(double x, double y);
static void xytonode(double x, double y, struct wlr_surface **psurface,
		Client **pc, LayerSurface **pl, double *nx, double *ny);
static void zoom(const Arg *arg);
static void rotate_clients(const Arg *arg);
static int __attribute__((unused)) node_contains_client(LayoutNode *node, Client *c);
static int subtree_bounds(LayoutNode *node, Monitor *m, struct wlr_box *out);
static __attribute__((unused)) LayoutNode *ancestor_split(LayoutNode *node, int want_vert);
static struct wlr_output_mode *bestmode(struct wlr_output *output);
static void btrtile(Monitor *m);
static void focusdir(const Arg *arg);
static void setratio_h(const Arg *arg);
static void setratio_v(const Arg *arg);
static void swapclients(const Arg *arg);

/* variables */
static pid_t child_pid = -1;
static int locked;
static void *exclusive_focus;

/* Config hot-reload */
static int config_inotify_fd = -1;
static int config_watch_wd = -1;
static char config_path_cached[PATH_MAX] = {0};
static struct wl_event_source *config_watch_source = NULL;
static struct wl_event_source *config_rewatch_timer = NULL;
static int config_needs_rewatch = 0;
static struct wl_display *dpy;
static struct wl_event_loop *event_loop;
static struct wlr_backend *backend;
static struct wlr_scene *scene;
static struct wlr_scene_tree *layers[NUM_LAYERS];
static struct wlr_scene_tree *drag_icon;
/* Map from ZWLR_LAYER_SHELL_* constants to Lyr* enum */
static const int layermap[] = { LyrBg, LyrBottom, LyrTop, LyrOverlay };
static struct wlr_renderer *drw;
static struct wlr_allocator *alloc;
static struct wlr_compositor *compositor;
static struct wlr_session *session;
static struct StatusFont statusfont;
static int fcft_initialized;
static int has_nixlytile_session_target_cached = -1;
static void hidetagthumbnail(Monitor *m);

static struct wlr_xdg_shell *xdg_shell;
static struct wlr_xdg_activation_v1 *activation;
static struct wlr_xdg_decoration_manager_v1 *xdg_decoration_mgr;
static struct wl_list clients; /* tiling order */
static struct wl_list fstack;  /* focus order */
static struct wlr_idle_notifier_v1 *idle_notifier;
static struct wlr_idle_inhibit_manager_v1 *idle_inhibit_mgr;
static struct wlr_layer_shell_v1 *layer_shell;
static struct wlr_output_manager_v1 *output_mgr;
static struct wlr_content_type_manager_v1 *content_type_mgr;
static struct wlr_tearing_control_manager_v1 *tearing_control_mgr;
static struct wlr_virtual_keyboard_manager_v1 *virtual_keyboard_mgr;
static struct wlr_virtual_pointer_manager_v1 *virtual_pointer_mgr;
static struct wlr_text_input_manager_v3 *text_input_mgr;
static struct wlr_text_input_v3 *active_text_input;
static struct wl_list text_inputs; /* TextInput.link */
static struct wlr_cursor_shape_manager_v1 *cursor_shape_mgr;
static struct wlr_output_power_manager_v1 *power_mgr;

static struct wlr_pointer_constraints_v1 *pointer_constraints;
static struct wlr_relative_pointer_manager_v1 *relative_pointer_mgr;
static struct wlr_pointer_constraint_v1 *active_constraint;

static struct wlr_cursor *cursor;
static struct wlr_xcursor_manager *cursor_mgr;

static struct wlr_scene_rect *root_bg;
static struct wlr_session_lock_manager_v1 *session_lock_mgr;
static struct wlr_scene_rect *locked_bg;
static struct wlr_session_lock_v1 *cur_lock;

static struct wlr_seat *seat;
static KeyboardGroup *kb_group;
static unsigned int cursor_mode;
static Client *grabc;
static int grabcx, grabcy; /* client-relative */
static int resize_dir_x, resize_dir_y;
static double resize_start_ratio_v, resize_start_ratio_h;
static int resize_use_v, resize_use_h;
static uint32_t resize_last_time;
static double resize_last_x, resize_last_y;

static struct wlr_output_layout *output_layout;
static struct wlr_box sgeom;
static struct wl_list mons;
static Monitor *selmon;

static struct wlr_box resize_start_box_v;
static struct wlr_box resize_start_box_h;
static struct wlr_box resize_start_box_f;
static double resize_start_x, resize_start_y;
static LayoutNode *resize_split_node;
static LayoutNode *resize_split_node_h;
static int fullscreen_adaptive_sync_enabled = 1;
static int fps_limit_enabled = 0;        /* 1 if FPS limiter is active */
static int fps_limit_value = 60;         /* FPS limit value (default 60) */
static int game_mode_active = 0; /* Set when any client is fullscreen - pauses background tasks */
static int game_mode_ultra = 0;  /* Ultra game mode - maximum performance, minimal latency */
static Client *game_mode_client = NULL;  /* The fullscreen game client */
static pid_t game_mode_pid = 0;  /* PID of fullscreen game process */
static int game_mode_nice_applied = 0;  /* 1 if we changed nice value */
static int game_mode_ioclass_applied = 0;  /* 1 if we changed IO priority */
static int htpc_mode_active = 0; /* HTPC mode - hides statusbar, stops background tasks */
static struct wl_event_source *status_timer;
static struct wl_event_source *status_cpu_timer;
static struct wl_event_source *status_hover_timer;
static struct wl_event_source *cache_update_timer;
static struct wl_event_source *nixpkgs_cache_timer;
static int cache_update_phase = 0; /* 0=git, 1=file, 2=gaming, then restart */
static StatusRefreshTask status_tasks[] = {
	{ refreshstatuscpu, 0 },
	{ refreshstatusram, 0 },
	{ refreshstatuslight, 0 },
	{ refreshstatusmic, 0 },
	{ refreshstatusvolume, 0 },
	{ refreshstatusbattery, 0 },
	{ refreshstatusnet, 0 },
	{ refreshstatusicons, 0 },
};
static int status_rng_seeded;

/* Gamepad controller support */
static struct wl_list gamepads;  /* GamepadDevice.link */
static int gamepad_inotify_fd = -1;
static int gamepad_inotify_wd = -1;
static struct wl_event_source *gamepad_inotify_event = NULL;
static struct wl_event_source *gamepad_inactivity_timer = NULL;
#define GAMEPAD_INACTIVITY_TIMEOUT_MS 10000  /* 10 seconds */
#define GAMEPAD_INACTIVITY_CHECK_MS 1000     /* Check every 1 second */

/* Pending gamepad devices (for delayed add after inotify) */
#define GAMEPAD_PENDING_MAX 8
static char gamepad_pending_paths[GAMEPAD_PENDING_MAX][128];
static int gamepad_pending_count = 0;
static struct wl_event_source *gamepad_pending_timer = NULL;

/* HTPC menu page toggles (0=disabled, 1=enabled) */
static int htpc_page_pcgaming = 1;
static int htpc_page_retrogaming = 1;
static int htpc_page_movies = 1;
static int htpc_page_tvshows = 1;
static int htpc_page_nrk = 1;
static int htpc_page_netflix = 1;
static int htpc_page_viaplay = 1;
static int htpc_page_tv2play = 1;
static int htpc_page_f1tv = 1;
static int htpc_page_quit = 1;

/* Streaming service URLs */
#define NRK_URL "https://nrk.no/direkte/nrk1"
#define NETFLIX_URL "https://www.netflix.com/browse"
#define VIAPLAY_URL "https://viaplay.no"
#define TV2PLAY_URL "https://play.tv2.no"
#define F1TV_URL "https://f1tv.formula1.com/detail/1000005614/f1-live"

/* Built HTPC menu based on enabled pages */
#define HTPC_MENU_MAX_ITEMS 12
static struct {
	char label[64];
	char command[256];
} htpc_menu_items[HTPC_MENU_MAX_ITEMS];
static int htpc_menu_item_count = 0;

static void htpc_menu_build(void)
{
	htpc_menu_item_count = 0;

	/* Order matches tag numbers: TV-shows=1, Movies=2, Retro-gaming=3, PC-gaming=4 */
	if (htpc_page_tvshows) {
		snprintf(htpc_menu_items[htpc_menu_item_count].label, 64, "TV-shows");
		htpc_menu_items[htpc_menu_item_count].command[0] = '\0';
		htpc_menu_item_count++;
	}
	if (htpc_page_movies) {
		snprintf(htpc_menu_items[htpc_menu_item_count].label, 64, "Movies");
		htpc_menu_items[htpc_menu_item_count].command[0] = '\0';
		htpc_menu_item_count++;
	}
	if (htpc_page_retrogaming) {
		snprintf(htpc_menu_items[htpc_menu_item_count].label, 64, "Retro-gaming");
		htpc_menu_items[htpc_menu_item_count].command[0] = '\0';
		htpc_menu_item_count++;
	}
	if (htpc_page_pcgaming) {
		snprintf(htpc_menu_items[htpc_menu_item_count].label, 64, "PC-gaming");
		htpc_menu_items[htpc_menu_item_count].command[0] = '\0';
		htpc_menu_item_count++;
	}
	/* Live TV streaming services */
	if (htpc_page_nrk) {
		snprintf(htpc_menu_items[htpc_menu_item_count].label, 64, "NRK");
		snprintf(htpc_menu_items[htpc_menu_item_count].command, 256, "%s", NRK_URL);
		htpc_menu_item_count++;
	}
	if (htpc_page_netflix) {
		snprintf(htpc_menu_items[htpc_menu_item_count].label, 64, "Netflix");
		snprintf(htpc_menu_items[htpc_menu_item_count].command, 256, "%s", NETFLIX_URL);
		htpc_menu_item_count++;
	}
	if (htpc_page_viaplay) {
		snprintf(htpc_menu_items[htpc_menu_item_count].label, 64, "Viaplay");
		snprintf(htpc_menu_items[htpc_menu_item_count].command, 256, "%s", VIAPLAY_URL);
		htpc_menu_item_count++;
	}
	if (htpc_page_tv2play) {
		snprintf(htpc_menu_items[htpc_menu_item_count].label, 64, "TV2 Play");
		snprintf(htpc_menu_items[htpc_menu_item_count].command, 256, "%s", TV2PLAY_URL);
		htpc_menu_item_count++;
	}
	if (htpc_page_f1tv) {
		snprintf(htpc_menu_items[htpc_menu_item_count].label, 64, "F1TV");
		snprintf(htpc_menu_items[htpc_menu_item_count].command, 256, "%s", F1TV_URL);
		htpc_menu_item_count++;
	}
}

/* PC Gaming service configuration */
static int gaming_service_enabled[GAMING_SERVICE_COUNT] = {1, 1, 1, 1}; /* All enabled by default */
static const char *gaming_service_names[] = {"Steam", "Heroic", "Lutris", "Bottles"};
/* Game tile size - aspect ratio based on Steam headers (460x215) */
#define PC_GAMING_TILE_HEIGHT 180  /* Base height for scroll calculations (matches 2:3 aspect) */
#define PC_GAMING_TILE_GAP 15
#define PC_GAMING_PADDING 40
#define PC_GAMING_CACHE_FILE "/.cache/nixlytile/games.cache"

/* GPU detection and management */
typedef enum {
	GPU_VENDOR_UNKNOWN = 0,
	GPU_VENDOR_INTEL,
	GPU_VENDOR_AMD,
	GPU_VENDOR_NVIDIA
} GpuVendor;

typedef struct {
	char card_path[64];      /* /dev/dri/cardX */
	char render_path[64];    /* /dev/dri/renderDX */
	char driver[32];         /* Driver name: nvidia, amdgpu, i915, nouveau, radeon */
	char pci_slot[16];       /* PCI slot like 0000:01:00.0 */
	char pci_slot_underscore[20]; /* PCI slot with underscores: pci-0000_01_00_0 */
	GpuVendor vendor;
	int is_discrete;         /* 1 if discrete GPU, 0 if integrated */
	int card_index;          /* Card number (0, 1, 2...) */
	int render_index;        /* Render node index */
} GpuInfo;

#define MAX_GPUS 8
static GpuInfo detected_gpus[MAX_GPUS];
static int detected_gpu_count = 0;
static int discrete_gpu_idx = -1;   /* Index of preferred discrete GPU, -1 if none */
static int integrated_gpu_idx = -1; /* Index of integrated GPU, -1 if none */

/* GPU-specific game launch parameters */
#include "game_launch_params.h"

/* PC gaming cache file watcher for realtime updates */
static int pc_gaming_cache_inotify_fd = -1;
static int pc_gaming_cache_inotify_wd = -1;
static struct wl_event_source *pc_gaming_cache_event = NULL;

/* Gamepad joystick cursor control */
static struct wl_event_source *gamepad_cursor_timer = NULL;
#define GAMEPAD_CURSOR_INTERVAL_MS 16   /* ~60 Hz update rate */
#define GAMEPAD_DEADZONE 4000           /* Deadzone threshold (out of 32767) */
#define GAMEPAD_CURSOR_SPEED 15.0       /* Base cursor speed in pixels per update */
#define GAMEPAD_CURSOR_ACCEL 2.5        /* Acceleration factor at full tilt */

/* Bluetooth controller auto-pairing */
static struct wl_event_source *bt_scan_timer = NULL;
static struct wl_event_source *bt_bus_event = NULL;
static sd_bus *bt_bus = NULL;
static int bt_scanning = 0;
#define BT_SCAN_INTERVAL_MS 30000       /* Scan every 30 seconds */
#define BT_SCAN_DURATION_MS 10000       /* Scan for 10 seconds */

/* Known gamepad name patterns for auto-pairing */
static const char *bt_gamepad_patterns[] = {
	"Xbox",
	"DualSense",
	"DualShock",
	"PS5",
	"PS4",
	"PlayStation",
	"8BitDo",
	"Pro Controller",   /* Nintendo Switch Pro */
	"Joy-Con",
	"Wireless Controller",
	"Game Controller",
	"Gamepad",
	NULL
};

static pid_t public_ip_pid = -1;
static int public_ip_fd = -1;
static struct wl_event_source *public_ip_event = NULL;
static char public_ip_buf[128];
static size_t public_ip_len = 0;
static pid_t ssid_pid = -1;
static int ssid_fd = -1;
static struct wl_event_source *ssid_event = NULL;
static char ssid_buf[256];
static size_t ssid_len = 0;
static time_t ssid_last_time = 0;
static int tray_anchor_x = -1;
static int tray_anchor_y = -1;
static uint64_t tray_anchor_time_ms;
#define MAX_CPU_CORES 256
static struct CpuSample cpu_prev[MAX_CPU_CORES];
static int cpu_prev_count;
static double cpu_last_percent = -1.0;
static char cpu_text[32] = "--%";
static double ram_last_mb = -1.0;
static char ram_text[32] = "--";
static double battery_last_percent = -1.0;
static char battery_text[32] = "--%";
static double net_last_down_bps = -1.0;
static double net_last_up_bps = -1.0;
static char last_clock_render[32];
static char last_cpu_render[32];
static char last_ram_render[32];
static char last_light_render[32];
static char last_volume_render[32];
static char last_mic_render[32];
static char last_battery_render[32];
static char last_net_render[64];
static int last_clock_h;
static int last_cpu_h;
static int last_ram_h;
static int last_light_h;
static int last_volume_h;
static int last_mic_h;
static int last_battery_h;
static int last_net_h;
static int battery_path_initialized;
static int backlight_paths_initialized;
static uint64_t volume_last_read_speaker_ms;
static uint64_t volume_last_read_headset_ms;
static double volume_cached_speaker = -1.0;
static double volume_cached_headset = -1.0;
static int volume_cached_speaker_muted = -1;
static int volume_cached_headset_muted = -1;
static uint64_t mic_last_read_ms;
static double mic_cached = -1.0;
static int mic_cached_muted = -1;
static uint64_t last_pointer_motion_ms;
static const float *volume_text_color = NULL; /* set at runtime; defaults to statusbar_fg */
static const float *mic_text_color = NULL;
static const float *statusbar_fg_override = NULL;
static pid_t wifi_scan_pid = -1;
static int wifi_scan_fd = -1;
static struct wl_event_source *wifi_scan_event = NULL;
static struct wl_event_source *wifi_scan_timer = NULL;
static struct wl_event_source *cpu_popup_refresh_timer = NULL;
static struct wl_event_source *ram_popup_refresh_timer = NULL;
static struct wl_event_source *popup_delay_timer = NULL;
static struct wl_event_source *video_check_timer = NULL;
static struct wl_event_source *hz_osd_timer = NULL;
static struct wl_event_source *pc_gaming_install_timer = NULL;
static struct wl_event_source *game_refocus_timer = NULL;
static struct wl_event_source *media_view_poll_timer = NULL;
static struct wl_event_source *osk_dpad_repeat_timer = NULL;
static int osk_dpad_held_button = 0;  /* BTN_DPAD_UP/DOWN/LEFT/RIGHT or 0 if none */
static Monitor *osk_dpad_held_mon = NULL;
#define OSK_DPAD_INITIAL_DELAY 400  /* ms before repeat starts */
#define OSK_DPAD_REPEAT_RATE 50     /* ms between repeats (fast sliding) */
static Client *game_refocus_client = NULL;
static char wifi_scan_buf[8192];
static size_t wifi_scan_len = 0;
static int wifi_scan_inflight;
static unsigned int wifi_networks_generation;
static unsigned int wifi_scan_generation;
static int wifi_networks_accept_updates;
static int wifi_networks_freeze_existing;
static struct wl_list wifi_networks; /* WifiNetwork */
static int wifi_networks_initialized;
static struct wl_list vpn_connections; /* VpnConnection */
static int vpn_list_initialized;
static pid_t vpn_scan_pid = -1;
static int vpn_scan_fd = -1;
static struct wl_event_source *vpn_scan_event;
static char vpn_scan_buf[8192];
static size_t vpn_scan_len;
static int vpn_scan_inflight;
static pid_t vpn_connect_pid = -1;
static int vpn_connect_fd = -1;
static struct wl_event_source *vpn_connect_event;
static char vpn_connect_buf[4096];
static size_t vpn_connect_len;
static char vpn_pending_name[128];
static char net_text[64] = "Net: --";
static char net_local_ip[64] = "--";
static char net_public_ip[64] = "--";
static char net_down_text[32] = "--";
static char net_up_text[32] = "--";
static char net_ssid[64] = "--";
static double net_last_wifi_quality = -1.0;
static int net_link_speed_mbps = -1;
static char net_iface[64] = {0};
static char net_prev_iface[64] = {0};
static int net_is_wireless;
static int net_available;
static char net_icon_path[PATH_MAX] = "images/svg/no_connection.svg";
static char net_icon_loaded_path[PATH_MAX];
static char cpu_icon_path[PATH_MAX] = "images/svg/cpu.svg";
static char cpu_icon_loaded_path[PATH_MAX];
static const uint32_t cpu_popup_refresh_interval_ms = 1000;
static const uint32_t ram_popup_refresh_interval_ms = 1000;
static char light_icon_path[PATH_MAX] = "images/svg/light.svg";
static char light_icon_loaded_path[PATH_MAX];
static char ram_icon_path[PATH_MAX] = "images/svg/ram.svg";
static char ram_icon_loaded_path[PATH_MAX];
static char battery_icon_path[PATH_MAX] = "images/svg/battery-100.svg";
static char battery_icon_loaded_path[PATH_MAX];
static char mic_icon_path[PATH_MAX] = "images/svg/microphone.svg";
static char mic_icon_loaded_path[PATH_MAX];
static char volume_icon_path[PATH_MAX] = "images/svg/speaker_100.svg";
static char volume_icon_loaded_path[PATH_MAX];
static const char net_icon_no_conn[] = "images/svg/no_connection.svg";
static const char net_icon_eth[] = "images/svg/ethernet.svg";
static const char net_icon_wifi_100[] = "images/svg/wifi_100.svg";
static const char net_icon_wifi_75[] = "images/svg/wifi_75.svg";
static const char net_icon_wifi_50[] = "images/svg/wifi_50.svg";
static const char net_icon_wifi_25[] = "images/svg/wifi_25.svg";
static const char battery_icon_25[] = "images/svg/battery-25.svg";
static const char battery_icon_50[] = "images/svg/battery-50.svg";
static const char battery_icon_75[] = "images/svg/battery-75.svg";
static const char battery_icon_100[] = "images/svg/battery-100.svg";
static const char volume_icon_speaker_25[] = "images/svg/speaker_25.svg";
static const char volume_icon_speaker_50[] = "images/svg/speaker_50.svg";
static const char volume_icon_speaker_100[] = "images/svg/speaker_100.svg";
static const char volume_icon_speaker_muted[] = "images/svg/speaker_muted.svg";
static const char volume_icon_headset[] = "images/svg/headset.svg";
static const char volume_icon_headset_muted[] = "images/svg/headset_muted.svg";
static const char mic_icon_unmuted[] = "images/svg/microphone.svg";
static const char mic_icon_muted[] = "images/svg/microphone_muted.svg";
static char net_icon_wifi_100_resolved[PATH_MAX];
static char net_icon_wifi_75_resolved[PATH_MAX];
static char net_icon_wifi_50_resolved[PATH_MAX];
static char net_icon_wifi_25_resolved[PATH_MAX];
static char net_icon_eth_resolved[PATH_MAX];
static char net_icon_no_conn_resolved[PATH_MAX];
static char clock_icon_path[PATH_MAX] = "images/svg/clock.svg";
static char clock_icon_loaded_path[PATH_MAX];
static int net_icon_loaded_h;
static int net_icon_w;
static int net_icon_h;
static struct wlr_buffer *net_icon_buf;
static int clock_icon_loaded_h;
static int clock_icon_w;
static int clock_icon_h;
static struct wlr_buffer *clock_icon_buf;
static int cpu_icon_loaded_h;
static int cpu_icon_w;
static int cpu_icon_h;
static struct wlr_buffer *cpu_icon_buf;
static int light_icon_loaded_h;
static int light_icon_w;
static int light_icon_h;
static struct wlr_buffer *light_icon_buf;
static int ram_icon_loaded_h;
static int ram_icon_w;
static int ram_icon_h;
static struct wlr_buffer *ram_icon_buf;
static int battery_icon_loaded_h;
static int battery_icon_w;
static int battery_icon_h;
static struct wlr_buffer *battery_icon_buf;
static int mic_icon_loaded_h;
static int mic_icon_w;
static int mic_icon_h;
static struct wlr_buffer *mic_icon_buf;
static int volume_icon_loaded_h;
static int volume_icon_w;
static int volume_icon_h;
static struct wlr_buffer *volume_icon_buf;
static char bluetooth_icon_path[PATH_MAX] = "images/svg/bluetooth.svg";
static char bluetooth_icon_loaded_path[PATH_MAX];
static int bluetooth_icon_loaded_h;
static int bluetooth_icon_w;
static int bluetooth_icon_h;
static struct wlr_buffer *bluetooth_icon_buf;
static int bluetooth_available;
static char steam_icon_path[PATH_MAX] = "images/svg/steam.svg";
static char steam_icon_loaded_path[PATH_MAX];
static int steam_icon_loaded_h;
static int steam_icon_w;
static int steam_icon_h;
static struct wlr_buffer *steam_icon_buf;
static int steam_running;
static char discord_icon_path[PATH_MAX] = "images/svg/discord.svg";
static char discord_icon_loaded_path[PATH_MAX];
static int discord_icon_loaded_h;
static int discord_icon_w;
static int discord_icon_h;
static struct wlr_buffer *discord_icon_buf;
static int discord_running;
static unsigned long long net_prev_rx;
static unsigned long long net_prev_tx;
static struct timespec net_prev_ts;
static int net_prev_valid;
static time_t net_public_ip_last;
static sd_bus *tray_bus;
static struct wl_event_source *tray_event;
static sd_bus_slot *tray_vtable_slot;
static sd_bus_slot *tray_fdo_vtable_slot;
static sd_bus_slot *tray_name_slot;
static int tray_host_registered;
static struct wl_list tray_items;
static double light_last_percent = -1.0;
static double light_cached_percent = -1.0;
static char light_text[32] = "--%";
static double mic_last_percent = 80.0;
static char mic_text[32] = "--%";
static double volume_last_speaker_percent = 70.0;
static double volume_last_headset_percent = 70.0;
static double speaker_active = 70.0;
static double speaker_stored = 70.0;
static double microphone_active = 80.0;
static double microphone_stored = 80.0;
static char volume_text[32] = "--%";
static int volume_muted = -1;
static int mic_muted = -1;
static int mic_last_color_is_muted = -1;
static int volume_last_color_is_muted = -1;
static char backlight_brightness_path[PATH_MAX];
static char backlight_max_path[PATH_MAX];
static int backlight_available;
static int backlight_writable;
static char battery_capacity_path[PATH_MAX];
static char battery_device_dir[PATH_MAX];  /* e.g. /sys/class/power_supply/BAT0 */
static int battery_available;
static const double light_step = 5.0;
static const double volume_step = 3.0;
static const double volume_max_percent = 150.0;
static const double mic_step = 3.0;
static const double mic_max_percent = 150.0;
static double cpu_last_core_percent[MAX_CPU_CORES];
static int cpu_core_count;
static char sysicons_text[64] = "Tray";
static DesktopEntry desktop_entries[4096];
static int desktop_entry_count = 0;
static int desktop_entries_loaded = 0;

/* Nixpkgs package cache */
#define NIXPKGS_MAX_ENTRIES 32768
static NixpkgEntry nixpkg_entries[NIXPKGS_MAX_ENTRIES];
static int nixpkg_entry_count = 0;
static int nixpkg_entries_loaded = 0;
static char nixpkgs_cache_path[PATH_MAX] = "";

/* Installed package check icon */
static struct wlr_buffer *nixpkg_ok_icon_buf = NULL;
static int nixpkg_ok_icon_height = 0;

/* global event handlers */
static struct wl_listener cursor_axis = {.notify = axisnotify};
static struct wl_listener cursor_button = {.notify = buttonpress};
static struct wl_listener cursor_frame = {.notify = cursorframe};
static struct wl_listener cursor_motion = {.notify = motionrelative};
static struct wl_listener cursor_motion_absolute = {.notify = motionabsolute};
static struct wl_listener gpu_reset = {.notify = gpureset};
static struct wl_listener layout_change = {.notify = updatemons};
static struct wl_listener new_idle_inhibitor = {.notify = createidleinhibitor};
static struct wl_listener new_input_device = {.notify = inputdevice};
static struct wl_listener new_virtual_keyboard = {.notify = virtualkeyboard};
static struct wl_listener new_virtual_pointer = {.notify = virtualpointer};
static void textinput(struct wl_listener *listener, void *data);
static void text_input_focus_change(struct wlr_surface *old, struct wlr_surface *new);
static struct wl_listener new_text_input = {.notify = textinput};
static struct wl_listener new_pointer_constraint = {.notify = createpointerconstraint};
static struct wl_listener new_output = {.notify = createmon};
static struct wl_listener new_xdg_toplevel = {.notify = createnotify};
static struct wl_listener new_xdg_popup = {.notify = createpopup};
static struct wl_listener new_xdg_decoration = {.notify = createdecoration};
static struct wl_listener new_layer_surface = {.notify = createlayersurface};
static struct wl_listener output_mgr_apply = {.notify = outputmgrapply};
static struct wl_listener output_mgr_test = {.notify = outputmgrtest};
static struct wl_listener output_power_mgr_set_mode = {.notify = powermgrsetmode};
static struct wl_listener request_activate = {.notify = urgent};
static struct wl_listener request_cursor = {.notify = setcursor};
static struct wl_listener request_set_psel = {.notify = setpsel};
static struct wl_listener request_set_sel = {.notify = setsel};
static struct wl_listener request_set_cursor_shape = {.notify = setcursorshape};
static struct wl_listener request_start_drag = {.notify = requeststartdrag};
static struct wl_listener start_drag = {.notify = startdrag};
static struct wl_listener new_session_lock = {.notify = locksession};

#ifdef XWAYLAND
static void activatex11(struct wl_listener *listener, void *data);
static void associatex11(struct wl_listener *listener, void *data);
static void configurex11(struct wl_listener *listener, void *data);
static void createnotifyx11(struct wl_listener *listener, void *data);
static void dissociatex11(struct wl_listener *listener, void *data);
static void minimizenotify(struct wl_listener *listener, void *data);
static void sethints(struct wl_listener *listener, void *data);
static void xwaylandready(struct wl_listener *listener, void *data);
static struct wl_listener new_xwayland_surface = {.notify = createnotifyx11};
static struct wl_listener xwayland_ready = {.notify = xwaylandready};
static struct wlr_xwayland *xwayland;
#endif

#ifndef WLR_SILENCE
#define WLR_SILENCE (WLR_ERROR - 1)
#endif

/* configuration, allows nested code to access above variables */
#include "config.h"

/* Runtime font storage - config values are copied here so we can modify them */
static char *runtime_fonts[8];
static int runtime_fonts_set = 0;

/* attempt to encapsulate suck into one file */
#include "client.h"
#include "btrtile.c"

static int
has_nixlytile_session_target(void)
{
	const char *paths[] = {
		"/etc/systemd/user/nixlytile-session.target",
		"/usr/lib/systemd/user/nixlytile-session.target",
		"/lib/systemd/user/nixlytile-session.target",
		NULL
	};

	if (has_nixlytile_session_target_cached >= 0)
		return has_nixlytile_session_target_cached;

	for (int i = 0; paths[i]; i++) {
		if (access(paths[i], F_OK) == 0) {
			has_nixlytile_session_target_cached = 1;
			return 1;
		}
	}
	has_nixlytile_session_target_cached = 0;
	return 0;
}

static void
hidetagthumbnail(Monitor *m)
{
	(void)m;
}

/* function implementations */
void
applybounds(Client *c, struct wlr_box *bbox)
{
	/* set minimum possible */
	c->geom.width = MAX(1 + 2 * (int)c->bw, c->geom.width);
	c->geom.height = MAX(1 + 2 * (int)c->bw, c->geom.height);

	if (c->geom.x >= bbox->x + bbox->width)
		c->geom.x = bbox->x + bbox->width - c->geom.width;
	if (c->geom.y >= bbox->y + bbox->height)
		c->geom.y = bbox->y + bbox->height - c->geom.height;
	if (c->geom.x + c->geom.width <= bbox->x)
		c->geom.x = bbox->x;
	if (c->geom.y + c->geom.height <= bbox->y)
		c->geom.y = bbox->y;
}

void
applyrules(Client *c)
{
	/* rule matching */
	const char *appid, *title;
	uint32_t newtags = 0;
	int i;
	const Rule *r;
	Monitor *mon = selmon, *m;

	appid = client_get_appid(c);
	title = client_get_title(c);

	for (r = rules; r < END(rules); r++) {
		if ((!r->title || strstr(title, r->title))
				&& (!r->id || strstr(appid, r->id))) {
			c->isfloating = r->isfloating;
			newtags |= r->tags;
			i = 0;
			wl_list_for_each(m, &mons, link) {
				if (r->monitor == i++)
					mon = m;
			}
		}
	}

	if (mon) {
		c->geom.x = (mon->w.width - c->geom.width) / 2 + mon->m.x;
		c->geom.y = (mon->w.height - c->geom.height) / 2 + mon->m.y;
	}

	c->isfloating |= client_is_float_type(c);
	setmon(c, mon, newtags);
}

static void
pixman_buffer_destroy(struct wlr_buffer *wlr_buffer)
{
	struct PixmanBuffer *buf = wl_container_of(wlr_buffer, buf, base);

	if (!buf)
		return;
	if (buf->image)
		pixman_image_unref(buf->image);
	if (buf->owns_data && buf->data)
		free(buf->data);
	free(buf);
}

static bool
pixman_buffer_begin_data_ptr_access(struct wlr_buffer *wlr_buffer, uint32_t flags,
		void **data, uint32_t *format, size_t *stride)
{
	struct PixmanBuffer *buf = wl_container_of(wlr_buffer, buf, base);

	(void)flags;
	if (!buf || !data || !format || !stride)
		return false;

	*data = buf->data;
	*format = buf->drm_format;
	*stride = buf->stride;
	return true;
}

static void
pixman_buffer_end_data_ptr_access(struct wlr_buffer *wlr_buffer)
{
	(void)wlr_buffer;
}

static bool
pixman_buffer_get_dmabuf(struct wlr_buffer *wlr_buffer,
		struct wlr_dmabuf_attributes *attribs)
{
	(void)wlr_buffer;
	(void)attribs;
	return false;
}

static bool
pixman_buffer_get_shm(struct wlr_buffer *wlr_buffer,
		struct wlr_shm_attributes *attribs)
{
	(void)wlr_buffer;
	(void)attribs;
	return false;
}

static const struct wlr_buffer_impl pixman_buffer_impl = {
	.destroy = pixman_buffer_destroy,
	.get_dmabuf = pixman_buffer_get_dmabuf,
	.get_shm = pixman_buffer_get_shm,
	.begin_data_ptr_access = pixman_buffer_begin_data_ptr_access,
	.end_data_ptr_access = pixman_buffer_end_data_ptr_access,
};

static struct wlr_buffer *
statusbar_buffer_from_glyph(const struct fcft_glyph *glyph)
{
	pixman_image_t *dst, *solid = NULL;
	struct PixmanBuffer *buf;
	pixman_color_t col;
	uint32_t *data;
	int width, height, stride, force_color;

	if (!glyph || !glyph->pix)
		return NULL;

	width = glyph->width;
	height = glyph->height;
	if (width <= 0 || height <= 0)
		return NULL;

	stride = width * 4;
	data = ecalloc(height, stride);
	if (!data)
		return NULL;

	dst = pixman_image_create_bits_no_clear(PIXMAN_a8r8g8b8, width, height,
			data, stride);
	if (!dst) {
		free(data);
		return NULL;
	}

	force_color = statusbar_font_force_color || pixman_image_get_format(glyph->pix) == PIXMAN_a8;
	if (force_color) {
		const float *fg = statusbar_fg_override ? statusbar_fg_override : statusbar_fg;
		col.alpha = (uint16_t)lroundf(fg[3] * 65535.0f);
		col.red = (uint16_t)lroundf(fg[0] * 65535.0f);
		col.green = (uint16_t)lroundf(fg[1] * 65535.0f);
		col.blue = (uint16_t)lroundf(fg[2] * 65535.0f);
		solid = pixman_image_create_solid_fill(&col);
		pixman_image_composite32(PIXMAN_OP_SRC, solid, glyph->pix, dst,
				0, 0, 0, 0, 0, 0, width, height);
	} else {
		pixman_image_composite32(PIXMAN_OP_SRC, glyph->pix, NULL, dst,
				0, 0, 0, 0, 0, 0, width, height);
	}

	if (solid)
		pixman_image_unref(solid);

	buf = ecalloc(1, sizeof(*buf));
	if (!buf) {
		pixman_image_unref(dst);
		free(data);
		return NULL;
	}

	buf->image = dst;
	buf->data = data;
	buf->drm_format = DRM_FORMAT_ARGB8888;
	buf->stride = stride;
	buf->owns_data = 1;
	wlr_buffer_init(&buf->base, &pixman_buffer_impl, width, height);

	return &buf->base;
}

static void
clearstatusmodule(StatusModule *module)
{
	struct wlr_scene_node *node, *tmp;

	if (!module || !module->tree)
		return;

	wl_list_for_each_safe(node, tmp, &module->tree->children, link) {
		if (module->bg && node == &module->bg->node)
			continue;
		wlr_scene_node_destroy(node);
	}
}

static void
updatemodulebg(StatusModule *module, int width, int height,
		const float color[static 4])
{
	struct wlr_scene_node *node, *tmp;
	int radius, y, inset_top, inset_bottom, inset, start, h, w;
	struct wlr_scene_rect *r;

	if (!module || !module->tree || width <= 0 || height <= 0)
		return;

	if (!module->bg && !(module->bg = wlr_scene_tree_create(module->tree)))
		return;
	wlr_scene_node_set_enabled(&module->bg->node, 1);
	wlr_scene_node_set_position(&module->bg->node, 0, 0);

	wl_list_for_each_safe(node, tmp, &module->bg->children, link)
		wlr_scene_node_destroy(node);

	radius = MIN(4, MIN(width, height) / 4);

	y = 0;
	while (y < height) {
		inset_top = radius ? MAX(0, radius - y) : 0;
		inset_bottom = radius ? MAX(0, radius - ((height - 1) - y)) : 0;
		inset = MAX(inset_top, inset_bottom);
		start = y;

		while (y < height) {
			inset_top = radius ? MAX(0, radius - y) : 0;
			inset_bottom = radius ? MAX(0, radius - ((height - 1) - y)) : 0;
			if (MAX(inset_top, inset_bottom) != inset)
				break;
			y++;
		}

		h = y - start;
		w = width - 2 * inset;
		if (w < 0)
			w = 0;

		if (h > 0 && w > 0) {
			r = wlr_scene_rect_create(module->bg, w, h, color);
			if (r)
				wlr_scene_node_set_position(&r->node, inset, start);
		}
	}

	wlr_scene_node_lower_to_bottom(&module->bg->node);
}

static void
renderclock(StatusModule *module, int bar_height, const char *text)
{
	render_icon_label(module, bar_height, text,
			ensure_clock_icon_buffer, &clock_icon_buf, &clock_icon_w, &clock_icon_h,
			0, statusbar_icon_text_gap_clock, statusbar_fg);
}

static void
render_icon_label(StatusModule *module, int bar_height, const char *text,
		int (*ensure_icon)(int target_h), struct wlr_buffer **icon_buf,
		int *icon_w, int *icon_h, int min_text_w, int icon_gap,
		const float text_color[static 4])
{
	int padding = statusbar_module_padding;
	int text_w = 0;
	int x;
	int iw = 0, ih = 0;
	int target_h;
	int scaled_target_h;
	struct wlr_scene_buffer *scene_buf;
	const float *fg = text_color ? text_color : statusbar_fg;

	if (!module || !module->tree)
		return;

	clearstatusmodule(module);

	if (bar_height <= 0) {
		module->width = 0;
		return;
	}

	target_h = bar_height - 2 * padding;
	if (target_h <= 0)
		target_h = bar_height;
	scaled_target_h = target_h;
	if (status_icon_scale > 0.0) {
		double scaled = (double)target_h * status_icon_scale;
		if (scaled > (double)INT_MAX)
			scaled = (double)INT_MAX;
		scaled_target_h = (int)lround(scaled);
		if (scaled_target_h <= 0)
			scaled_target_h = target_h;
	}

	if (ensure_icon && icon_buf && icon_w && icon_h
			&& ensure_icon(scaled_target_h) == 0
			&& *icon_buf && *icon_w > 0 && *icon_h > 0) {
		iw = *icon_w;
		ih = *icon_h;
	}

	if (text && *text)
		text_w = status_text_width(text);
	if (min_text_w > text_w)
		text_w = min_text_w;
	if (icon_gap <= 0)
		icon_gap = statusbar_icon_text_gap;

	module->width = 2 * padding + text_w;
	if (iw > 0)
		module->width += iw + (text_w > 0 ? icon_gap : padding);
	if (module->width < 2 * padding)
		module->width = 2 * padding;

	updatemodulebg(module, module->width, bar_height, statusbar_bg);
	x = padding;

	if (iw > 0 && icon_buf && *icon_buf) {
		scene_buf = wlr_scene_buffer_create(module->tree, NULL);
		if (scene_buf) {
			int icon_y = (bar_height - ih) / 2;
			wlr_scene_buffer_set_buffer(scene_buf, *icon_buf);
			wlr_scene_node_set_position(&scene_buf->node, x, icon_y);
		}
		x += iw + (text_w > 0 ? icon_gap : padding);
	}

	if (text_w > 0)
		tray_render_label(module, text, x, bar_height, fg);
}

static int
status_text_width(const char *text)
{
	int pen_x = 0;
	uint32_t prev_cp = 0;

	if (!text || !*text)
		return 0;

	if (!statusfont.font)
		return (int)strlen(text) * 8;

	for (int i = 0; text[i]; ) {
		long kern_x = 0, kern_y = 0;
		uint32_t cp;
		unsigned char c = (unsigned char)text[i];
		const struct fcft_glyph *glyph;

		/* Decode UTF-8 to Unicode codepoint */
		if ((c & 0x80) == 0) {
			cp = c;
			i += 1;
		} else if ((c & 0xE0) == 0xC0) {
			cp = (c & 0x1F) << 6;
			if (text[i + 1])
				cp |= ((unsigned char)text[i + 1] & 0x3F);
			i += 2;
		} else if ((c & 0xF0) == 0xE0) {
			cp = (c & 0x0F) << 12;
			if (text[i + 1]) {
				cp |= ((unsigned char)text[i + 1] & 0x3F) << 6;
				if (text[i + 2])
					cp |= ((unsigned char)text[i + 2] & 0x3F);
			}
			i += 3;
		} else if ((c & 0xF8) == 0xF0) {
			cp = (c & 0x07) << 18;
			if (text[i + 1]) {
				cp |= ((unsigned char)text[i + 1] & 0x3F) << 12;
				if (text[i + 2]) {
					cp |= ((unsigned char)text[i + 2] & 0x3F) << 6;
					if (text[i + 3])
						cp |= ((unsigned char)text[i + 3] & 0x3F);
				}
			}
			i += 4;
		} else {
			i += 1;
			continue;
		}

		if (prev_cp)
			fcft_kerning(statusfont.font, prev_cp, cp, &kern_x, &kern_y);
		pen_x += (int)kern_x;

		glyph = fcft_rasterize_char_utf32(statusfont.font, cp,
				statusbar_font_subpixel);
		if (glyph && glyph->pix) {
			pen_x += glyph->advance.x;
			if (text[i])
				pen_x += statusbar_font_spacing;
		}
		prev_cp = cp;
	}

	return pen_x;
}

static int
tray_render_label(StatusModule *module, const char *text, int x, int bar_height,
		const float color[static 4])
{
	tll(struct GlyphRun) glyphs = tll_init();
	const struct fcft_glyph *glyph;
	struct wlr_scene_buffer *scene_buf;
	struct wlr_buffer *buffer;
	uint32_t prev_cp = 0;
	int pen_x = 0;
	int min_y = INT_MAX, max_y = INT_MIN;
	int text_width, text_height, origin_y;
	size_t i;
	const float *prev_fg = statusbar_fg_override;

	if (!module || !module->tree || !text || !*text || bar_height <= 0)
		return 0;

	statusbar_fg_override = color;
	if (!statusfont.font) {
		int w = status_text_width(text);
		if (w <= 0)
			w = statusbar_font_spacing;
		statusbar_fg_override = prev_fg;
		return w;
	}

	for (i = 0; text[i]; ) {
		long kern_x = 0, kern_y = 0;
		uint32_t cp;
		unsigned char c = (unsigned char)text[i];

		/* Decode UTF-8 to Unicode codepoint */
		if ((c & 0x80) == 0) {
			/* ASCII (0xxxxxxx) */
			cp = c;
			i += 1;
		} else if ((c & 0xE0) == 0xC0) {
			/* 2-byte sequence (110xxxxx 10xxxxxx) */
			cp = (c & 0x1F) << 6;
			if (text[i + 1])
				cp |= ((unsigned char)text[i + 1] & 0x3F);
			i += 2;
		} else if ((c & 0xF0) == 0xE0) {
			/* 3-byte sequence (1110xxxx 10xxxxxx 10xxxxxx) */
			cp = (c & 0x0F) << 12;
			if (text[i + 1]) {
				cp |= ((unsigned char)text[i + 1] & 0x3F) << 6;
				if (text[i + 2])
					cp |= ((unsigned char)text[i + 2] & 0x3F);
			}
			i += 3;
		} else if ((c & 0xF8) == 0xF0) {
			/* 4-byte sequence (11110xxx 10xxxxxx 10xxxxxx 10xxxxxx) */
			cp = (c & 0x07) << 18;
			if (text[i + 1]) {
				cp |= ((unsigned char)text[i + 1] & 0x3F) << 12;
				if (text[i + 2]) {
					cp |= ((unsigned char)text[i + 2] & 0x3F) << 6;
					if (text[i + 3])
						cp |= ((unsigned char)text[i + 3] & 0x3F);
				}
			}
			i += 4;
		} else {
			/* Invalid UTF-8, skip byte */
			i += 1;
			continue;
		}

		if (prev_cp)
			fcft_kerning(statusfont.font, prev_cp, cp, &kern_x, &kern_y);
		pen_x += (int)kern_x;

		glyph = fcft_rasterize_char_utf32(statusfont.font, cp,
				statusbar_font_subpixel);
		if (glyph && glyph->pix) {
			tll_push_back(glyphs, ((struct GlyphRun){
				.glyph = glyph,
				.pen_x = pen_x,
				.codepoint = cp,
			}));
			if (-glyph->y < min_y)
				min_y = -glyph->y;
			if (-glyph->y + glyph->height > max_y)
				max_y = -glyph->y + glyph->height;
			pen_x += glyph->advance.x;
			if (text[i])
				pen_x += statusbar_font_spacing;
		}
		prev_cp = cp;
	}

	if (tll_length(glyphs) == 0) {
		tll_free(glyphs);
		statusbar_fg_override = prev_fg;
		return 0;
	}

	text_width = status_text_width(text);
	text_height = max_y - min_y;
	origin_y = (bar_height - text_height) / 2 - min_y;

	tll_foreach(glyphs, it) {
		glyph = it->item.glyph;
		buffer = statusbar_buffer_from_glyph(glyph);
		if (!buffer)
			continue;

		scene_buf = wlr_scene_buffer_create(module->tree, NULL);
		if (scene_buf) {
			wlr_scene_buffer_set_buffer(scene_buf, buffer);
			wlr_scene_node_set_position(&scene_buf->node,
					x + it->item.pen_x + glyph->x,
					origin_y - glyph->y);
		}
		wlr_buffer_drop(buffer);
	}

	tll_free(glyphs);
	statusbar_fg_override = prev_fg;
	return text_width;
}

static void
rendercpu(StatusModule *module, int bar_height, const char *text)
{
	render_icon_label(module, bar_height, text,
			ensure_cpu_icon_buffer, &cpu_icon_buf, &cpu_icon_w, &cpu_icon_h,
			0, statusbar_icon_text_gap_cpu, statusbar_fg);
}

static void
renderlight(StatusModule *module, int bar_height, const char *text)
{
	if (!module || !module->tree) {
		return;
	}

	if (!backlight_available) {
		clearstatusmodule(module);
		module->width = 0;
		wlr_scene_node_set_enabled(&module->tree->node, 0);
		return;
	}

	render_icon_label(module, bar_height, text,
			ensure_light_icon_buffer, &light_icon_buf, &light_icon_w, &light_icon_h,
			0, statusbar_icon_text_gap_light, statusbar_fg);
}

static void
rendernet(StatusModule *module, int bar_height, const char *text)
{
	/* Net text module is disabled; keep node hidden */
	if (module && module->tree) {
		clearstatusmodule(module);
		module->width = 0;
		wlr_scene_node_set_enabled(&module->tree->node, 0);
	}
}

static void
renderbattery(StatusModule *module, int bar_height, const char *text)
{
	if (!battery_available) {
		if (module && module->tree) {
			clearstatusmodule(module);
			module->width = 0;
			wlr_scene_node_set_enabled(&module->tree->node, 0);
		}
		return;
	}

	render_icon_label(module, bar_height, text,
			ensure_battery_icon_buffer, &battery_icon_buf, &battery_icon_w, &battery_icon_h,
			status_text_width("100%"), statusbar_icon_text_gap_battery, statusbar_fg);
}

static void
renderram(StatusModule *module, int bar_height, const char *text)
{
	render_icon_label(module, bar_height, text,
			ensure_ram_icon_buffer, &ram_icon_buf, &ram_icon_w, &ram_icon_h,
			0, statusbar_icon_text_gap_ram, statusbar_fg);
}

static void
rendervolume(StatusModule *module, int bar_height, const char *text)
{
	render_icon_label(module, bar_height, text,
			ensure_volume_icon_buffer, &volume_icon_buf, &volume_icon_w, &volume_icon_h,
			status_text_width("100%"), statusbar_icon_text_gap_volume, volume_text_color);
}

static void
rendermic(StatusModule *module, int bar_height, const char *text)
{
	render_icon_label(module, bar_height, text,
			ensure_mic_icon_buffer, &mic_icon_buf, &mic_icon_w, &mic_icon_h,
			status_text_width("100%"), statusbar_icon_text_gap_microphone, mic_text_color);
}

static int
pathisdir(const char *path)
{
	struct stat st;

	return path && *path && stat(path, &st) == 0 && S_ISDIR(st.st_mode);
}

static int
pathisfile(const char *path)
{
	struct stat st;

	return path && *path && stat(path, &st) == 0 && S_ISREG(st.st_mode);
}

static int
resolve_asset_path(const char *path, char *out, size_t len)
{
	static char exe_dir[PATH_MAX];
	static int exe_dir_cached = 0;
	char cand[PATH_MAX];
	const char *envdir;

	if (!path || !*path || !out || len == 0)
		return -1;

	if (path[0] == '/') {
		if (pathisfile(path)) {
			snprintf(out, len, "%s", path);
			return 0;
		}
		return -1;
	}

	if (pathisfile(path)) {
		snprintf(out, len, "%s", path);
		return 0;
	}

	envdir = getenv("NIXLYTILE_ICON_DIR");
	if (envdir && *envdir) {
		if (snprintf(cand, sizeof(cand), "%s/%s", envdir, path) < (int)sizeof(cand)
				&& pathisfile(cand)) {
			snprintf(out, len, "%s", cand);
			return 0;
		}
	}

	if (!exe_dir_cached) {
		char *slash;
		ssize_t n = readlink("/proc/self/exe", exe_dir, sizeof(exe_dir) - 1);
		if (n > 0 && (size_t)n < sizeof(exe_dir)) {
			exe_dir[n] = '\0';
			slash = strrchr(exe_dir, '/');
			if (slash)
				*slash = '\0';
			else
				exe_dir[0] = '\0';
		} else {
			exe_dir[0] = '\0';
		}
		exe_dir_cached = 1;
	}

	if (exe_dir[0]) {
		if (snprintf(cand, sizeof(cand), "%s/%s", exe_dir, path) < (int)sizeof(cand)
				&& pathisfile(cand)) {
			snprintf(out, len, "%s", cand);
			return 0;
		}
		if (snprintf(cand, sizeof(cand), "%s/../share/nixlytile/%s", exe_dir, path) < (int)sizeof(cand)
				&& pathisfile(cand)) {
			snprintf(out, len, "%s", cand);
			return 0;
		}
	}

	return -1;
}

static int
has_svg_extension(const char *path)
{
	size_t len;

	if (!path || !*path)
		return 0;

	len = strlen(path);
	if (len >= 4 && strcasecmp(path + len - 4, ".svg") == 0)
		return 1;
	if (len >= 5 && strcasecmp(path + len - 5, ".svgz") == 0)
		return 1;
	return 0;
}

static int
strip_symbolic_suffix(const char *name, char *out, size_t outlen)
{
	size_t len, suffix = strlen("-symbolic");

	if (!name || !out || outlen == 0)
		return 0;

	len = strlen(name);
	if (len > suffix && strcmp(name + len - suffix, "-symbolic") == 0) {
		size_t copylen = len - suffix;
		if (copylen >= outlen)
			copylen = outlen - 1;
		memcpy(out, name, copylen);
		out[copylen] = '\0';
		return 1;
	}
	return 0;
}

static void
add_icon_root_paths(const char *base, const char *themes[], size_t theme_count,
		char pathbufs[][PATH_MAX], size_t *pathcount, size_t max_paths)
{
	if (!base || !*base || !themes || !pathbufs || !pathcount)
		return;

	for (size_t i = 0; i < theme_count && *pathcount < max_paths; i++) {
		char themed[PATH_MAX];
		snprintf(themed, sizeof(themed), "%s/%s", base, themes[i]);
		snprintf(pathbufs[*pathcount], PATH_MAX, "%s", themed);
		(*pathcount)++;
	}

	if (*pathcount < max_paths) {
		snprintf(pathbufs[*pathcount], PATH_MAX, "%s", base);
		(*pathcount)++;
	}
}

static GdkPixbuf *
pixbuf_from_cairo_surface(cairo_surface_t *surface, int width, int height)
{
	GdkPixbuf *pixbuf;
	guchar *dst;
	const uint8_t *src;
	int dst_stride, src_stride;

	if (!surface || width <= 0 || height <= 0)
		return NULL;
	if (cairo_surface_status(surface) != CAIRO_STATUS_SUCCESS)
		return NULL;

	cairo_surface_flush(surface);
	src = cairo_image_surface_get_data(surface);
	src_stride = cairo_image_surface_get_stride(surface);
	if (!src)
		return NULL;

	pixbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB, 1, 8, width, height);
	if (!pixbuf)
		return NULL;
	dst = gdk_pixbuf_get_pixels(pixbuf);
	dst_stride = gdk_pixbuf_get_rowstride(pixbuf);

	for (int y = 0; y < height; y++) {
		const uint32_t *srow = (const uint32_t *)(src + (size_t)y * (size_t)src_stride);
		guchar *drow = dst + (size_t)y * (size_t)dst_stride;
		for (int x = 0; x < width; x++) {
			uint32_t s = srow[x];
			uint8_t a = (uint8_t)(s >> 24);
			uint8_t r = (uint8_t)(s >> 16);
			uint8_t g = (uint8_t)(s >> 8);
			uint8_t b = (uint8_t)s;

			if (a > 0) {
				/* Un-premultiply */
				r = (uint8_t)((((uint32_t)r) * 255u + a / 2u) / a);
				g = (uint8_t)((((uint32_t)g) * 255u + a / 2u) / a);
				b = (uint8_t)((((uint32_t)b) * 255u + a / 2u) / a);
			} else {
				r = g = b = 0;
			}

			drow[(size_t)x * 4] = r;
			drow[(size_t)x * 4 + 1] = g;
			drow[(size_t)x * 4 + 2] = b;
			drow[(size_t)x * 4 + 3] = a;
		}
	}

	return pixbuf;
}

static void
tray_consider_icon(const char *path, int size_hint, int desired_h,
		char *best_path, int *best_diff, int *found)
{
	int diff;

	if (!path || !*path || !best_path || !best_diff || !found)
		return;
	if (!pathisfile(path) || access(path, R_OK) != 0)
		return;

	if (size_hint > 0 && desired_h > 0)
		diff = abs(size_hint - desired_h);
	else if (desired_h > 0 && size_hint <= 0)
		diff = desired_h;
	else
		diff = 0;

	if (!*found || diff < *best_diff) {
		*best_diff = diff;
		snprintf(best_path, PATH_MAX, "%s", path);
		*found = 1;
	}
}

static struct wlr_buffer *
statusbar_buffer_from_pixbuf(GdkPixbuf *pixbuf, int target_h, int *out_w, int *out_h)
{
	GdkPixbuf *scaled = NULL;
	guchar *pixels;
	int w, h, nchan, stride;
	uint8_t *argb = NULL;
	size_t bufsize;
	struct wlr_buffer *buf = NULL;

	if (!pixbuf)
		return NULL;

	w = gdk_pixbuf_get_width(pixbuf);
	h = gdk_pixbuf_get_height(pixbuf);
	if (w <= 0 || h <= 0)
		goto out;

	if (target_h > 0 && h > target_h) {
		int target_w = (int)lround(((double)w * (double)target_h) / (double)h);
		if (target_w <= 0)
			target_w = 1;
		scaled = gdk_pixbuf_scale_simple(pixbuf, target_w, target_h, GDK_INTERP_BILINEAR);
		if (scaled) {
			g_object_unref(pixbuf);
			pixbuf = scaled;
			w = target_w;
			h = target_h;
		}
	}

	nchan = gdk_pixbuf_get_n_channels(pixbuf);
	if (nchan < 3)
		goto out;
	stride = gdk_pixbuf_get_rowstride(pixbuf);
	pixels = gdk_pixbuf_get_pixels(pixbuf);
	if (!pixels)
		goto out;

	bufsize = (size_t)w * (size_t)h * 4;
	argb = calloc(1, bufsize);
	if (!argb)
		goto out;

	for (int y = 0; y < h; y++) {
		const guchar *row = pixels + (size_t)y * (size_t)stride;
		for (int x = 0; x < w; x++) {
			const guchar *p = row + (size_t)x * (size_t)nchan;
			uint8_t r = p[0];
			uint8_t g = p[1];
			uint8_t b = p[2];
			uint8_t a = (nchan >= 4 && gdk_pixbuf_get_has_alpha(pixbuf)) ? p[3] : 255;
			size_t idx = ((size_t)y * (size_t)w + (size_t)x) * 4;
			argb[idx] = a;
			argb[idx + 1] = r;
			argb[idx + 2] = g;
			argb[idx + 3] = b;
		}
	}

	buf = statusbar_buffer_from_argb32((const uint32_t *)argb, w, h);
	if (buf) {
		if (out_w)
			*out_w = w;
		if (out_h)
			*out_h = h;
	}

out:
	free(argb);
	g_object_unref(pixbuf);
	return buf;
}

static void
recolor_wifi100_pixbuf(GdkPixbuf *pixbuf)
{
	int w, h, nchan, stride;
	guchar *pixels;
	double fx, fy;
	int has_alpha;
	struct Rect {
		double x, y, w, h;
		uint8_t r, g, b;
	};
	static const struct Rect rects[] = {
		{ 6, 38, 10, 20, 0x82, 0xCC, 0x00 }, /* bar 1 main */
		{ 14, 38,  2, 20, 0x5E, 0x9E, 0x00 }, /* bar 1 stripe */
		{ 20, 30, 10, 28, 0x82, 0xCC, 0x00 }, /* bar 2 main */
		{ 28, 30,  2, 28, 0x5E, 0x9E, 0x00 }, /* bar 2 stripe */
		{ 34, 22, 10, 36, 0x82, 0xCC, 0x00 }, /* bar 3 main */
		{ 42, 22,  2, 36, 0x5E, 0x9E, 0x00 }, /* bar 3 stripe */
		{ 48, 14, 10, 44, 0x82, 0xCC, 0x00 }, /* bar 4 main */
		{ 56, 14,  2, 44, 0x5E, 0x9E, 0x00 }, /* bar 4 stripe */
	};

	if (!pixbuf)
		return;
	nchan = gdk_pixbuf_get_n_channels(pixbuf);
	if (nchan < 3)
		return;
	w = gdk_pixbuf_get_width(pixbuf);
	h = gdk_pixbuf_get_height(pixbuf);
	if (w <= 0 || h <= 0)
		return;
	stride = gdk_pixbuf_get_rowstride(pixbuf);
	pixels = gdk_pixbuf_get_pixels(pixbuf);
	if (!pixels)
		return;
	has_alpha = gdk_pixbuf_get_has_alpha(pixbuf);
	fx = (double)w / 64.0;
	fy = (double)h / 64.0;

	for (size_t i = 0; i < LENGTH(rects); i++) {
		int rx = (int)lround(rects[i].x * fx);
		int ry = (int)lround(rects[i].y * fy);
		int rw = (int)lround(rects[i].w * fx);
		int rh = (int)lround(rects[i].h * fy);
		if (rx < 0) rx = 0;
		if (ry < 0) ry = 0;
		if (rw < 1) rw = 1;
		if (rh < 1) rh = 1;
		if (rx + rw > w) rw = w - rx;
		if (ry + rh > h) rh = h - ry;
		for (int y = ry; y < ry + rh; y++) {
			guchar *row = pixels + (size_t)y * (size_t)stride;
			for (int x = rx; x < rx + rw; x++) {
				guchar *p = row + (size_t)x * (size_t)nchan;
				p[0] = rects[i].r;
				p[1] = rects[i].g;
				p[2] = rects[i].b;
				if (has_alpha && nchan >= 4)
					p[3] = 255;
			}
		}
	}
}

static struct wlr_buffer *
statusbar_buffer_from_wifi100(int target_h, int *out_w, int *out_h)
{
	struct {
		int x, y, w, h;
		uint8_t r, g, b;
	} bars[] = {
		{6, 38, 10, 20, 0x82, 0xCC, 0x00}, /* bar 1 main */
		{14, 38, 2, 20, 0x5E, 0x9E, 0x00}, /* bar 1 stripe */
		{20, 30, 10, 28, 0x82, 0xCC, 0x00}, /* bar 2 main */
		{28, 30, 2, 28, 0x5E, 0x9E, 0x00}, /* bar 2 stripe */
		{34, 22, 10, 36, 0x82, 0xCC, 0x00}, /* bar 3 main */
		{42, 22, 2, 36, 0x5E, 0x9E, 0x00}, /* bar 3 stripe */
		{48, 14, 10, 44, 0x82, 0xCC, 0x00}, /* bar 4 main */
		{56, 14, 2, 44, 0x5E, 0x9E, 0x00}, /* bar 4 stripe */
	};
	const int base_w = 64;
	const int base_h = 64;
	int target_w, target_h_final;
	uint32_t *buf = NULL;
	struct wlr_buffer *wb = NULL;

	target_h_final = (target_h > 0) ? target_h : base_h;
	if (target_h_final <= 0)
		return NULL;
	target_w = (int)lround(((double)base_w * (double)target_h_final) / (double)base_h);
	if (target_w <= 0)
		target_w = 1;

	buf = calloc(1, (size_t)base_w * (size_t)base_h * sizeof(uint32_t));
	if (!buf)
		return NULL;

	for (size_t i = 0; i < LENGTH(bars); i++) {
		int rx = bars[i].x;
		int ry = bars[i].y;
		int rw = bars[i].w;
		int rh = bars[i].h;
		if (rx < 0) rx = 0;
		if (ry < 0) ry = 0;
		if (rw < 1) rw = 1;
		if (rh < 1) rh = 1;
		if (rx + rw > base_w) rw = base_w - rx;
		if (ry + rh > base_h) rh = base_h - ry;
		for (int y = ry; y < ry + rh; y++) {
			for (int x = rx; x < rx + rw; x++) {
				size_t idx = (size_t)y * (size_t)base_w + (size_t)x;
				buf[idx] = ((uint32_t)0xFF << 24)
						| ((uint32_t)bars[i].r << 16)
						| ((uint32_t)bars[i].g << 8)
						| (uint32_t)bars[i].b;
			}
		}
	}

	wb = statusbar_scaled_buffer_from_argb32_raw((const uint32_t *)buf, base_w, base_h, target_h_final);
	free(buf);
	if (wb) {
		if (out_w)
			*out_w = target_w;
		if (out_h)
			*out_h = target_h_final;
	}
	return wb;
}

static int
tray_load_svg_pixbuf(const char *path, int desired_h, GdkPixbuf **out_pixbuf)
{
	RsvgHandle *handle = NULL;
	GError *gerr = NULL;
	double svg_w = 0.0, svg_h = 0.0;
	int target_w, target_h;
	cairo_surface_t *surface = NULL;
	cairo_t *cr = NULL;
	GdkPixbuf *pixbuf = NULL;

	if (!path || !*path || !out_pixbuf)
		return -1;

	/* Read the file manually so changes arent hidden by loader caches */
	{
		gchar *data = NULL;
		gsize len = 0;

		if (!g_file_get_contents(path, &data, &len, &gerr) || !data || len == 0) {
			if (gerr) {
				wlr_log(WLR_ERROR, "tray: failed to read SVG '%s': %s",
						path, gerr->message);
				g_error_free(gerr);
			}
			g_free(data);
			return -1;
		}

		handle = rsvg_handle_new_from_data((const guint8 *)data, len, &gerr);
		g_free(data);
	}
	if (!handle) {
		if (gerr) {
			wlr_log(WLR_ERROR, "tray: failed to parse SVG '%s': %s",
					path, gerr->message);
			g_error_free(gerr);
		}
		return -1;
	}

	if (!rsvg_handle_get_intrinsic_size_in_pixels(handle, &svg_w, &svg_h) ||
			svg_w <= 0.0 || svg_h <= 0.0) {
		RsvgDimensionData dim = {0};
		rsvg_handle_get_dimensions(handle, &dim);
		svg_w = dim.width;
		svg_h = dim.height;
	}

	target_h = (desired_h > 0) ? desired_h :
		((svg_h > 0.0) ? (int)lround(svg_h) : 24);
	if (target_h <= 0)
		target_h = 24;
	if (svg_w > 0.0 && svg_h > 0.0)
		target_w = MAX(1, (int)lround((svg_w * (double)target_h) / svg_h));
	else
		target_w = target_h;

	surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, target_w, target_h);
	if (cairo_surface_status(surface) != CAIRO_STATUS_SUCCESS)
		goto out;

	cr = cairo_create(surface);
	cairo_set_operator(cr, CAIRO_OPERATOR_SOURCE);
	cairo_set_source_rgba(cr, 0.0, 0.0, 0.0, 0.0);
	cairo_paint(cr);

	{
		RsvgRectangle viewport = {
			.x = 0,
			.y = 0,
			.width = (double)target_w,
			.height = (double)target_h,
		};
		if (!rsvg_handle_render_document(handle, cr, &viewport, &gerr)) {
			if (gerr) {
				wlr_log(WLR_ERROR, "tray: failed to render SVG '%s': %s",
						path, gerr->message);
				g_error_free(gerr);
				gerr = NULL;
			}
			goto out;
		}
	}

	cairo_destroy(cr);
	cr = NULL;
	pixbuf = pixbuf_from_cairo_surface(surface, target_w, target_h);

out:
	if (cr)
		cairo_destroy(cr);
	if (surface)
		cairo_surface_destroy(surface);
	if (handle)
		g_object_unref(handle);
	if (!pixbuf && gerr) {
		wlr_log(WLR_ERROR, "tray: failed to load SVG '%s': %s",
				path, gerr->message);
	}
	if (gerr)
		g_error_free(gerr);

	if (!pixbuf)
		return -1;

	*out_pixbuf = pixbuf;
	return 0;
}

static void
drop_cpu_icon_buffer(void)
{
	if (cpu_icon_buf) {
		wlr_buffer_drop(cpu_icon_buf);
		cpu_icon_buf = NULL;
	}
	cpu_icon_loaded_h = 0;
	cpu_icon_w = cpu_icon_h = 0;
	cpu_icon_loaded_path[0] = '\0';
}

static int
ensure_cpu_icon_buffer(int target_h)
{
	GdkPixbuf *pixbuf = NULL;
	GError *gerr = NULL;
	struct wlr_buffer *buf;
	int w = 0, h = 0;
	char resolved[PATH_MAX];
	const char *path = cpu_icon_path;

	if (target_h <= 0)
		return -1;

	if (resolve_asset_path(cpu_icon_path, resolved, sizeof(resolved)) == 0 && resolved[0])
		path = resolved;

	if (cpu_icon_buf && cpu_icon_loaded_h == target_h &&
			strncmp(cpu_icon_loaded_path, path, sizeof(cpu_icon_loaded_path)) == 0)
		return 0;

	if (tray_load_svg_pixbuf(path, target_h, &pixbuf) != 0) {
		pixbuf = gdk_pixbuf_new_from_file(path, &gerr);
		if (!pixbuf) {
			if (gerr) {
				wlr_log(WLR_ERROR, "cpu icon: failed to load '%s': %s",
						path, gerr->message);
				g_error_free(gerr);
			}
			return -1;
		}
	}

	buf = statusbar_buffer_from_pixbuf(pixbuf, target_h, &w, &h);
	if (!buf)
		return -1;

	drop_cpu_icon_buffer();
	cpu_icon_buf = buf;
	cpu_icon_w = w;
	cpu_icon_h = h;
	cpu_icon_loaded_h = target_h;
	snprintf(cpu_icon_loaded_path, sizeof(cpu_icon_loaded_path), "%s", path);
	return 0;
}

static void
drop_clock_icon_buffer(void)
{
	if (clock_icon_buf) {
		wlr_buffer_drop(clock_icon_buf);
		clock_icon_buf = NULL;
	}
	clock_icon_loaded_h = 0;
	clock_icon_w = clock_icon_h = 0;
	clock_icon_loaded_path[0] = '\0';
}

static int
ensure_clock_icon_buffer(int target_h)
{
	GdkPixbuf *pixbuf = NULL;
	GError *gerr = NULL;
	struct wlr_buffer *buf;
	int w = 0, h = 0;
	char resolved[PATH_MAX];
	const char *path = clock_icon_path;

	if (target_h <= 0)
		return -1;

	if (resolve_asset_path(clock_icon_path, resolved, sizeof(resolved)) == 0 && resolved[0])
		path = resolved;

	if (clock_icon_buf && clock_icon_loaded_h == target_h &&
			strncmp(clock_icon_loaded_path, path, sizeof(clock_icon_loaded_path)) == 0)
		return 0;

	if (tray_load_svg_pixbuf(path, target_h, &pixbuf) != 0) {
		pixbuf = gdk_pixbuf_new_from_file(path, &gerr);
		if (!pixbuf) {
			if (gerr) {
				wlr_log(WLR_ERROR, "clock icon: failed to load '%s': %s",
						path, gerr->message);
				g_error_free(gerr);
			}
			return -1;
		}
	}

	buf = statusbar_buffer_from_pixbuf(pixbuf, target_h, &w, &h);
	if (!buf)
		return -1;

	drop_clock_icon_buffer();
	clock_icon_buf = buf;
	clock_icon_w = w;
	clock_icon_h = h;
	clock_icon_loaded_h = target_h;
	snprintf(clock_icon_loaded_path, sizeof(clock_icon_loaded_path), "%s", path);
	return 0;
}

static void
drop_light_icon_buffer(void)
{
	if (light_icon_buf) {
		wlr_buffer_drop(light_icon_buf);
		light_icon_buf = NULL;
	}
	light_icon_loaded_h = 0;
	light_icon_w = light_icon_h = 0;
	light_icon_loaded_path[0] = '\0';
}

static int
ensure_light_icon_buffer(int target_h)
{
	GdkPixbuf *pixbuf = NULL;
	GError *gerr = NULL;
	struct wlr_buffer *buf;
	int w = 0, h = 0;
	char resolved[PATH_MAX];
	const char *path = light_icon_path;

	if (target_h <= 0)
		return -1;

	if (resolve_asset_path(light_icon_path, resolved, sizeof(resolved)) == 0 && resolved[0])
		path = resolved;

	if (light_icon_buf && light_icon_loaded_h == target_h &&
			strncmp(light_icon_loaded_path, path, sizeof(light_icon_loaded_path)) == 0)
		return 0;

	if (tray_load_svg_pixbuf(path, target_h, &pixbuf) != 0) {
		pixbuf = gdk_pixbuf_new_from_file(path, &gerr);
		if (!pixbuf) {
			if (gerr) {
				wlr_log(WLR_ERROR, "light icon: failed to load '%s': %s",
						path, gerr->message);
				g_error_free(gerr);
			}
			return -1;
		}
	}

	buf = statusbar_buffer_from_pixbuf(pixbuf, target_h, &w, &h);
	if (!buf)
		return -1;

	drop_light_icon_buffer();
	light_icon_buf = buf;
	light_icon_w = w;
	light_icon_h = h;
	light_icon_loaded_h = target_h;
	snprintf(light_icon_loaded_path, sizeof(light_icon_loaded_path), "%s", path);
	return 0;
}

static void
drop_ram_icon_buffer(void)
{
	if (ram_icon_buf) {
		wlr_buffer_drop(ram_icon_buf);
		ram_icon_buf = NULL;
	}
	ram_icon_loaded_h = 0;
	ram_icon_w = ram_icon_h = 0;
	ram_icon_loaded_path[0] = '\0';
}

static int
ensure_ram_icon_buffer(int target_h)
{
	GdkPixbuf *pixbuf = NULL;
	GError *gerr = NULL;
	struct wlr_buffer *buf;
	int w = 0, h = 0;
	char resolved[PATH_MAX];
	const char *path = ram_icon_path;

	if (target_h <= 0)
		return -1;

	if (resolve_asset_path(ram_icon_path, resolved, sizeof(resolved)) == 0 && resolved[0])
		path = resolved;

	if (ram_icon_buf && ram_icon_loaded_h == target_h &&
			strncmp(ram_icon_loaded_path, path, sizeof(ram_icon_loaded_path)) == 0)
		return 0;

	if (tray_load_svg_pixbuf(path, target_h, &pixbuf) != 0) {
		pixbuf = gdk_pixbuf_new_from_file(path, &gerr);
		if (!pixbuf) {
			if (gerr) {
				wlr_log(WLR_ERROR, "ram icon: failed to load '%s': %s",
						path, gerr->message);
				g_error_free(gerr);
			}
			return -1;
		}
	}

	buf = statusbar_buffer_from_pixbuf(pixbuf, target_h, &w, &h);
	if (!buf)
		return -1;

	drop_ram_icon_buffer();
	ram_icon_buf = buf;
	ram_icon_w = w;
	ram_icon_h = h;
	ram_icon_loaded_h = target_h;
	snprintf(ram_icon_loaded_path, sizeof(ram_icon_loaded_path), "%s", path);
	return 0;
}

static void
drop_volume_icon_buffer(void)
{
	if (volume_icon_buf) {
		wlr_buffer_drop(volume_icon_buf);
		volume_icon_buf = NULL;
	}
	volume_icon_loaded_h = 0;
	volume_icon_w = volume_icon_h = 0;
	volume_icon_loaded_path[0] = '\0';
}

static int
ensure_volume_icon_buffer(int target_h)
{
	GdkPixbuf *pixbuf = NULL;
	GError *gerr = NULL;
	struct wlr_buffer *buf;
	int w = 0, h = 0;
	char resolved[PATH_MAX];
	const char *path = volume_icon_path;

	if (target_h <= 0)
		return -1;

	if (resolve_asset_path(volume_icon_path, resolved, sizeof(resolved)) == 0 && resolved[0])
		path = resolved;

	if (volume_icon_buf && volume_icon_loaded_h == target_h &&
			strncmp(volume_icon_loaded_path, path, sizeof(volume_icon_loaded_path)) == 0)
		return 0;

	if (tray_load_svg_pixbuf(path, target_h, &pixbuf) != 0) {
		pixbuf = gdk_pixbuf_new_from_file(path, &gerr);
		if (!pixbuf) {
			if (gerr) {
				wlr_log(WLR_ERROR, "volume icon: failed to load '%s': %s",
						path, gerr->message);
				g_error_free(gerr);
			}
			return -1;
		}
	}

	buf = statusbar_buffer_from_pixbuf(pixbuf, target_h, &w, &h);
	if (!buf)
		return -1;

	drop_volume_icon_buffer();
	volume_icon_buf = buf;
	volume_icon_w = w;
	volume_icon_h = h;
	volume_icon_loaded_h = target_h;
	snprintf(volume_icon_loaded_path, sizeof(volume_icon_loaded_path), "%s", path);
	return 0;
}

static void
drop_battery_icon_buffer(void)
{
	if (battery_icon_buf) {
		wlr_buffer_drop(battery_icon_buf);
		battery_icon_buf = NULL;
	}
	battery_icon_loaded_h = 0;
	battery_icon_w = battery_icon_h = 0;
	battery_icon_loaded_path[0] = '\0';
}

static int
ensure_battery_icon_buffer(int target_h)
{
	GdkPixbuf *pixbuf = NULL;
	GError *gerr = NULL;
	struct wlr_buffer *buf;
	int w = 0, h = 0;
	char resolved[PATH_MAX];
	const char *path = battery_icon_path;

	if (target_h <= 0)
		return -1;

	if (resolve_asset_path(battery_icon_path, resolved, sizeof(resolved)) == 0 && resolved[0])
		path = resolved;

	if (battery_icon_buf && battery_icon_loaded_h == target_h &&
			strncmp(battery_icon_loaded_path, path, sizeof(battery_icon_loaded_path)) == 0)
		return 0;

	if (tray_load_svg_pixbuf(path, target_h, &pixbuf) != 0) {
		pixbuf = gdk_pixbuf_new_from_file(path, &gerr);
		if (!pixbuf) {
			if (gerr) {
				wlr_log(WLR_ERROR, "battery icon: failed to load '%s': %s",
						path, gerr->message);
				g_error_free(gerr);
			}
			return -1;
		}
	}

	buf = statusbar_buffer_from_pixbuf(pixbuf, target_h, &w, &h);
	if (!buf)
		return -1;

	drop_battery_icon_buffer();
	battery_icon_buf = buf;
	battery_icon_w = w;
	battery_icon_h = h;
	battery_icon_loaded_h = target_h;
	snprintf(battery_icon_loaded_path, sizeof(battery_icon_loaded_path), "%s", path);
	return 0;
}

static void
drop_mic_icon_buffer(void)
{
	if (mic_icon_buf) {
		wlr_buffer_drop(mic_icon_buf);
		mic_icon_buf = NULL;
	}
	mic_icon_loaded_h = 0;
	mic_icon_w = mic_icon_h = 0;
	mic_icon_loaded_path[0] = '\0';
}

static int
ensure_mic_icon_buffer(int target_h)
{
	GdkPixbuf *pixbuf = NULL;
	GError *gerr = NULL;
	struct wlr_buffer *buf;
	int w = 0, h = 0;
	char resolved[PATH_MAX];
	const char *path = mic_icon_path;

	if (target_h <= 0)
		return -1;

	if (resolve_asset_path(mic_icon_path, resolved, sizeof(resolved)) == 0 && resolved[0])
		path = resolved;

	if (mic_icon_buf && mic_icon_loaded_h == target_h &&
			strncmp(mic_icon_loaded_path, path, sizeof(mic_icon_loaded_path)) == 0)
		return 0;

	if (tray_load_svg_pixbuf(path, target_h, &pixbuf) != 0) {
		pixbuf = gdk_pixbuf_new_from_file(path, &gerr);
		if (!pixbuf) {
			if (gerr) {
				wlr_log(WLR_ERROR, "mic icon: failed to load '%s': %s",
						path, gerr->message);
				g_error_free(gerr);
			}
			return -1;
		}
	}

	buf = statusbar_buffer_from_pixbuf(pixbuf, target_h, &w, &h);
	if (!buf)
		return -1;

	drop_mic_icon_buffer();
	mic_icon_buf = buf;
	mic_icon_w = w;
	mic_icon_h = h;
	mic_icon_loaded_h = target_h;
	snprintf(mic_icon_loaded_path, sizeof(mic_icon_loaded_path), "%s", path);
	return 0;
}

static int
tray_load_icon_file(TrayItem *it, const char *path, int desired_h)
{
	GError *gerr = NULL;
	struct wlr_buffer *buf;
	int w = 0, h = 0;
	GdkPixbuf *pixbuf = NULL;

	if (!it || !path || !*path)
		return -1;

	if (has_svg_extension(path)) {
		if (tray_load_svg_pixbuf(path, desired_h, &pixbuf) != 0) {
			pixbuf = gdk_pixbuf_new_from_file(path, &gerr);
			if (!pixbuf && gerr) {
				wlr_log(WLR_ERROR, "tray: failed to load icon '%s': %s", path, gerr->message);
				g_error_free(gerr);
				gerr = NULL;
			}
			if (!pixbuf)
				return -1;
		}
	} else {
		pixbuf = gdk_pixbuf_new_from_file(path, &gerr);
		if (!pixbuf) {
			if (gerr) {
				wlr_log(WLR_ERROR, "tray: failed to load icon '%s': %s", path, gerr->message);
				g_error_free(gerr);
				gerr = NULL;
			}
			if (has_svg_extension(path) &&
					tray_load_svg_pixbuf(path, desired_h, &pixbuf) != 0)
				return -1;
			if (!pixbuf)
				return -1;
		}
	}

	buf = statusbar_buffer_from_pixbuf(pixbuf, desired_h, &w, &h);
	if (!buf)
		return -1;

	if (it->icon_buf)
		wlr_buffer_drop(it->icon_buf);
	it->icon_buf = buf;
	it->icon_w = w;
	it->icon_h = h;
	return 0;
}

static int
tray_lookup_icon_in_theme(const char *theme_root, const char *name, int desired_h,
		char *best_path, int *best_diff, int *found)
{
	static const char *subdirs[] = {
		"", "status", "apps", "panel", "actions",
		"devices", "emblems", "places", "categories", "mimetypes"
	};
	static const char *exts[] = { "png", "svg", "xpm", "jpg", "jpeg" };
	const int base_sizes[] = { 16, 22, 24, 32, 48, 64, 96, 128, 256 };
	int sizes[LENGTH(base_sizes) + 1] = {0};
	size_t size_count = 0;
	char symbolic[128] = {0};
	char nosymbolic[128] = {0};
	const char *candidates[3] = { name, NULL, NULL };
	size_t cand_count = 1;

	if (!theme_root || !name || !*name || !pathisdir(theme_root))
		return -1;

	if (desired_h > 0)
		sizes[size_count++] = desired_h;
	for (size_t i = 0; i < LENGTH(base_sizes) && size_count < LENGTH(sizes); i++) {
		if (desired_h > 0 && base_sizes[i] == desired_h)
			continue;
		sizes[size_count++] = base_sizes[i];
	}

	if (strip_symbolic_suffix(name, nosymbolic, sizeof(nosymbolic))) {
		candidates[0] = nosymbolic; /* Prefer colored variant over symbolic */
		candidates[cand_count++] = name;
	} else {
		candidates[0] = name;
	}
	if (!strstr(name, "-symbolic") && cand_count < LENGTH(candidates)) {
		snprintf(symbolic, sizeof(symbolic), "%s-symbolic", name);
		candidates[cand_count++] = symbolic;
	}

	for (size_t s = 0; s < size_count; s++) {
		char sizedir[32];
		snprintf(sizedir, sizeof(sizedir), "%dx%d", sizes[s], sizes[s]);
		for (size_t d = 0; d < LENGTH(subdirs); d++) {
			for (size_t c = 0; c < cand_count; c++) {
				if (!candidates[c])
					continue;
				for (size_t e = 0; e < LENGTH(exts); e++) {
					char path[PATH_MAX];
					if (*subdirs[d])
						snprintf(path, sizeof(path), "%s/%s/%s/%s.%s",
								theme_root, sizedir, subdirs[d], candidates[c], exts[e]);
					else
						snprintf(path, sizeof(path), "%s/%s/%s.%s",
								theme_root, sizedir, candidates[c], exts[e]);
					tray_consider_icon(path, sizes[s], desired_h, best_path, best_diff, found);
					if (*found && *best_diff == 0)
						return 0;
				}
			}
		}
	}

	for (size_t d = 0; d < LENGTH(subdirs); d++) {
		for (size_t c = 0; c < cand_count; c++) {
			if (!candidates[c])
				continue;
			for (size_t e = 0; e < LENGTH(exts); e++) {
				char path[PATH_MAX];
				if (*subdirs[d])
					snprintf(path, sizeof(path), "%s/scalable/%s/%s.%s",
							theme_root, subdirs[d], candidates[c], exts[e]);
				else
					snprintf(path, sizeof(path), "%s/scalable/%s.%s",
							theme_root, candidates[c], exts[e]);
				tray_consider_icon(path, desired_h, desired_h, best_path, best_diff, found);
				if (*found && *best_diff == 0)
					return 0;
			}
		}
	}

	for (size_t d = 0; d < LENGTH(subdirs); d++) {
		for (size_t c = 0; c < cand_count; c++) {
			if (!candidates[c])
				continue;
			for (size_t e = 0; e < LENGTH(exts); e++) {
				char path[PATH_MAX];
				if (*subdirs[d])
					snprintf(path, sizeof(path), "%s/%s/%s.%s",
							theme_root, subdirs[d], candidates[c], exts[e]);
				else
					snprintf(path, sizeof(path), "%s/%s.%s",
							theme_root, candidates[c], exts[e]);
				tray_consider_icon(path, desired_h, desired_h, best_path, best_diff, found);
				if (*found && *best_diff == 0)
					return 0;
			}
		}
	}

	return *found ? 0 : -1;
}

static int
tray_lookup_icon_in_root(const char *base, const char *name, int desired_h,
		char *best_path, int *best_diff, int *found)
{
	DIR *dir;
	struct dirent *ent;
	static const char *exts[] = { "png", "svg", "xpm", "jpg", "jpeg" };

	if (!base || !*base || !name || !*name)
		return -1;

	tray_lookup_icon_in_theme(base, name, desired_h, best_path, best_diff, found);
	if (*found && *best_diff == 0)
		return 0;

	if (pathisdir(base)) {
		dir = opendir(base);
		if (dir) {
			while ((ent = readdir(dir))) {
				char sub[PATH_MAX];
				if (ent->d_name[0] == '.')
					continue;
				snprintf(sub, sizeof(sub), "%s/%s", base, ent->d_name);
				if (!pathisdir(sub))
					continue;
				tray_lookup_icon_in_theme(sub, name, desired_h, best_path, best_diff, found);
				if (*found && *best_diff == 0) {
					closedir(dir);
					return 0;
				}
			}
			closedir(dir);
		}
	}

	for (size_t e = 0; e < LENGTH(exts); e++) {
		char path[PATH_MAX];
		snprintf(path, sizeof(path), "%s/%s.%s", base, name, exts[e]);
		tray_consider_icon(path, desired_h, desired_h, best_path, best_diff, found);
		if (*found && *best_diff == 0)
			return 0;
	}

	return *found ? 0 : -1;
}

static int
tray_find_icon_path(const char *name, const char *theme_path, int desired_h,
		char *out, size_t outlen)
{
	const char *xdg_data_dirs;
	char best_path[PATH_MAX] = {0};
	char pathbufs[64][PATH_MAX];
	size_t pathcount = 0;
	int found = 0;
	int best_diff = INT_MAX;
	const char *themes[16] = {0};
	size_t theme_count = 0;
	char theme_env[256] = {0};
	const char *default_themes[] = {
		"Papirus", "Papirus-Dark", "Papirus-Light", "Adwaita", "hicolor"
	};

#define ADD_PATH(P) do { \
	const char *p_ = (P); \
	if (p_ && *p_ && pathcount < LENGTH(pathbufs)) { \
		snprintf(pathbufs[pathcount], sizeof(pathbufs[pathcount]), "%s", p_); \
		pathcount++; \
	} \
} while (0)

	if (getenv("STATUSBAR_ICON_THEMES")) {
		snprintf(theme_env, sizeof(theme_env), "%s", getenv("STATUSBAR_ICON_THEMES"));
		for (char *tok = theme_env; tok && *tok && theme_count < LENGTH(themes); ) {
			char *sep = strchr(tok, ':');
			if (sep)
				*sep = '\0';
			if (*tok)
				themes[theme_count++] = tok;
			if (!sep)
				break;
			tok = sep + 1;
		}
	}
	if (theme_count == 0) {
		for (size_t i = 0; i < LENGTH(default_themes) && theme_count < LENGTH(themes); i++)
			themes[theme_count++] = default_themes[i];
	}

	if (!name || !*name || !out || outlen == 0)
		return -1;

	if (name[0] == '/' && access(name, R_OK) == 0) {
		snprintf(out, outlen, "%s", name);
		return 0;
	}

	if (theme_path && *theme_path && pathcount < LENGTH(pathbufs)) {
		ADD_PATH(theme_path);
	}

	{
		const char *xdg_home = getenv("XDG_DATA_HOME");
		const char *home = getenv("HOME");
		if (xdg_home && *xdg_home && pathcount < LENGTH(pathbufs)) {
			char path[PATH_MAX];
			snprintf(path, sizeof(path), "%s/icons", xdg_home);
			add_icon_root_paths(path, themes, theme_count, pathbufs, &pathcount, LENGTH(pathbufs));
		} else if (home && *home && pathcount < LENGTH(pathbufs)) {
			char path[PATH_MAX];
			snprintf(path, sizeof(path), "%s/.local/share/icons", home);
			add_icon_root_paths(path, themes, theme_count, pathbufs, &pathcount, LENGTH(pathbufs));
		}
		if (home && *home && pathcount < LENGTH(pathbufs)) {
			char path[PATH_MAX];
			snprintf(path, sizeof(path), "%s/.icons", home);
			add_icon_root_paths(path, themes, theme_count, pathbufs, &pathcount, LENGTH(pathbufs));
		}
	}

	xdg_data_dirs = getenv("XDG_DATA_DIRS");
	if (!xdg_data_dirs || !*xdg_data_dirs)
		xdg_data_dirs = "/usr/local/share:/usr/share";
	while (*xdg_data_dirs && pathcount < LENGTH(pathbufs)) {
		const char *end = strchrnul(xdg_data_dirs, ':');
		size_t len = (size_t)(end - xdg_data_dirs);
		if (len > 0 && len < sizeof(pathbufs[0]) - 7) {
			char path[PATH_MAX];
			snprintf(path, sizeof(path), "%.*s/icons",
					(int)len, xdg_data_dirs);
			add_icon_root_paths(path, themes, theme_count, pathbufs, &pathcount, LENGTH(pathbufs));
		}
		if (*end == '\0')
			break;
		xdg_data_dirs = end + 1;
	}

	{
		const char *nix_profiles = getenv("NIX_PROFILES");
		while (nix_profiles && *nix_profiles && pathcount < LENGTH(pathbufs)) {
			const char *end = strchrnul(nix_profiles, ' ');
			size_t len = (size_t)(end - nix_profiles);
			if (len > 0 && len < sizeof(pathbufs[0]) - 14 && pathcount < LENGTH(pathbufs)) {
				char path[PATH_MAX];
				snprintf(path, sizeof(path),
						"%.*s/share/icons", (int)len, nix_profiles);
				add_icon_root_paths(path, themes, theme_count, pathbufs, &pathcount, LENGTH(pathbufs));
			}
			if (len > 0 && len < sizeof(pathbufs[0]) - 16 && pathcount < LENGTH(pathbufs)) {
				char path[PATH_MAX];
				snprintf(path, sizeof(path),
						"%.*s/share/pixmaps", (int)len, nix_profiles);
				ADD_PATH(path);
			}
			if (*end == '\0')
				break;
			nix_profiles = end + 1;
		}
	}

	if (pathcount < LENGTH(pathbufs)) {
		add_icon_root_paths("/run/current-system/sw/share/icons", themes, theme_count, pathbufs, &pathcount, LENGTH(pathbufs));
	}
	if (pathcount < LENGTH(pathbufs)) {
		ADD_PATH("/run/current-system/sw/share/pixmaps");
	}

	if (pathcount < LENGTH(pathbufs)) {
		ADD_PATH("/usr/share/pixmaps");
	}

#undef ADD_PATH

	for (size_t i = 0; i < pathcount; i++) {
		tray_lookup_icon_in_root(pathbufs[i], name, desired_h, best_path, &best_diff, &found);
		if (found && best_diff == 0)
			break;
	}

	if (!found)
		return -1;

	snprintf(out, outlen, "%s", best_path);
	return 0;
}

static int
tray_get_string_property(TrayItem *it, const char *prop, char *out, size_t outlen)
{
	const char *ifaces[] = {
		"org.kde.StatusNotifierItem",
		"org.freedesktop.StatusNotifierItem",
	};
	sd_bus_message *reply = NULL;
	sd_bus_error err = SD_BUS_ERROR_NULL;
	const char *val = NULL;
	int r = -1;

	if (!tray_bus || !it || !prop)
		return -1;

	for (size_t iface_idx = 0; iface_idx < LENGTH(ifaces); iface_idx++) {
		sd_bus_error_free(&err);
		sd_bus_message_unref(reply);
		reply = NULL;

		r = sd_bus_call_method(tray_bus, it->service, it->path,
				"org.freedesktop.DBus.Properties", "Get",
				&err, &reply, "ss", ifaces[iface_idx], prop);
		if (r >= 0)
			break;
	}
	if (r < 0 || !reply)
		goto out;
	if (sd_bus_message_enter_container(reply, 'v', "s") < 0)
		goto out;
	if (sd_bus_message_read(reply, "s", &val) < 0)
		goto out;
	if (val && *val && out && outlen > 0)
		snprintf(out, outlen, "%s", val);

out:
	sd_bus_error_free(&err);
	sd_bus_message_unref(reply);
	return (val && *val) ? 0 : -1;
}

__attribute__((unused)) static int
tray_item_load_icon(TrayItem *it)
{
	sd_bus_message *reply = NULL;
	sd_bus_error err = SD_BUS_ERROR_NULL;
	const void *best_data = NULL;
	size_t best_len = 0;
	int desired_h = statusbar_height > 0 ? MAX(12, (int)statusbar_height - 4) : 24;
	int best_score = INT_MAX;
	int best_w = 0, best_h = 0;
	int r;
	const char *ifaces[] = {
		"org.kde.StatusNotifierItem",
		"org.freedesktop.StatusNotifierItem",
	};
	const char *props[] = { "IconPixmap", "AttentionIconPixmap" };
	int prop_idx;

	if (!tray_bus || !it)
		return -1;
	if (it->icon_tried && it->icon_failed)
		return -1;
	it->icon_tried = 1;

	/* Prefer themed icons first so the user's icon theme takes effect */
	{
		char icon_theme_path[PATH_MAX] = {0};
		char icon_path[PATH_MAX] = {0};
		char icon_name[128] = {0};

		tray_get_string_property(it, "IconThemePath", icon_theme_path,
				sizeof(icon_theme_path));

		if (tray_get_string_property(it, "AttentionIconName", icon_name, sizeof(icon_name)) == 0 &&
				tray_find_icon_path(icon_name, icon_theme_path, desired_h,
					icon_path, sizeof(icon_path)) == 0 &&
				tray_load_icon_file(it, icon_path, desired_h) == 0) {
			it->icon_failed = 0;
			return 0;
		}

		memset(icon_name, 0, sizeof(icon_name));
		memset(icon_path, 0, sizeof(icon_path));
		if (tray_get_string_property(it, "IconName", icon_name, sizeof(icon_name)) == 0 &&
				tray_find_icon_path(icon_name, icon_theme_path, desired_h,
					icon_path, sizeof(icon_path)) == 0 &&
				tray_load_icon_file(it, icon_path, desired_h) == 0) {
			it->icon_failed = 0;
			return 0;
		}
	}

	for (prop_idx = 0; prop_idx < (int)LENGTH(props); prop_idx++) {
		best_data = NULL;
		best_len = 0;
		best_score = INT_MAX;
		best_w = best_h = 0;

		for (size_t iface_idx = 0; iface_idx < LENGTH(ifaces); iface_idx++) {
			sd_bus_error_free(&err);
			sd_bus_message_unref(reply);
			reply = NULL;

			r = sd_bus_call_method(tray_bus, it->service, it->path,
					"org.freedesktop.DBus.Properties", "Get",
					&err, &reply, "ss", ifaces[iface_idx], props[prop_idx]);
			if (r >= 0)
				break;
		}
		if (r < 0)
			continue;

		if (sd_bus_message_enter_container(reply, 'v', "a(iiay)") < 0)
			continue;
		if (sd_bus_message_enter_container(reply, 'a', "(iiay)") < 0)
			continue;

		while (sd_bus_message_enter_container(reply, 'r', "iiay") > 0) {
			int w = 0, h = 0;
			const void *pix = NULL;
			size_t len = 0;
			if (sd_bus_message_read(reply, "ii", &w, &h) < 0) {
				sd_bus_message_exit_container(reply); /* struct */
				break;
			}
			if (sd_bus_message_read_array(reply, 'y', &pix, &len) < 0) {
				sd_bus_message_exit_container(reply); /* struct */
				break;
			}
			if (w > 0 && h > 0 && len >= (size_t)w * (size_t)h * 4) {
				int diff = desired_h > 0 ? abs(h - desired_h) : INT_MAX;
				size_t area = (size_t)w * (size_t)h;
				if ((desired_h > 0 && (diff < best_score ||
						(diff == best_score && h < best_h))) ||
						(desired_h <= 0 && area > best_len)) {
					best_score = diff;
					best_len = area;
					best_w = w;
					best_h = h;
					best_data = pix;
				}
			}
			sd_bus_message_exit_container(reply); /* struct */
		}

		sd_bus_message_exit_container(reply);
		sd_bus_message_exit_container(reply);

		if (best_data && best_w > 0 && best_h > 0)
			break;
	}

	if (best_data && best_w > 0 && best_h > 0) {
		int target_h = (desired_h > 0) ? desired_h : best_h;
		struct wlr_buffer *buf = NULL;

		if (best_h > target_h && target_h > 0)
			buf = statusbar_scaled_buffer_from_argb32(best_data, best_w, best_h, target_h);
		else
			buf = statusbar_buffer_from_argb32(best_data, best_w, best_h);
		if (buf) {
			if (it->icon_buf)
				wlr_buffer_drop(it->icon_buf);
			it->icon_buf = buf;
			if (target_h > 0 && best_h > target_h) {
				it->icon_w = (int)lround(((double)best_w * (double)target_h) / (double)best_h);
				it->icon_h = target_h;
			} else {
				it->icon_w = best_w;
				it->icon_h = best_h;
			}
			sd_bus_message_unref(reply);
			sd_bus_error_free(&err);
			it->icon_failed = 0;
			return 0;
		}
	}

	sd_bus_message_unref(reply);
	sd_bus_error_free(&err);
	it->icon_failed = 1;
	return -1;
}

static void
drop_net_icon_buffer(void)
{
	if (net_icon_buf) {
		wlr_buffer_drop(net_icon_buf);
		net_icon_buf = NULL;
	}
	net_icon_loaded_h = 0;
	net_icon_loaded_path[0] = '\0';
	net_icon_w = 0;
	net_icon_h = 0;
}

static int
load_net_icon_buffer(const char *path, int target_h)
{
	GError *gerr = NULL;
	struct wlr_buffer *buf;
	int w = 0, h = 0;
	GdkPixbuf *pixbuf = NULL;
	char resolved[PATH_MAX];
	const char *load_path = path;

	if (!path || !*path || target_h <= 0)
		return -1;

	if (resolve_asset_path(path, resolved, sizeof(resolved)) == 0)
		load_path = resolved;

	/* For the 100% icon, synthesize the bars to avoid theme tinting entirely */
	if (strcmp(path, net_icon_wifi_100) == 0
			|| (net_icon_wifi_100_resolved[0]
				&& strcmp(load_path, net_icon_wifi_100_resolved) == 0)) {
		buf = statusbar_buffer_from_wifi100(target_h, &w, &h);
		if (!buf) {
			wlr_log(WLR_ERROR, "net icon: synth wifi_100 failed (path=%s resolved=%s)",
					path, load_path);
			return -1;
		}
		snprintf(net_icon_loaded_path, sizeof(net_icon_loaded_path), "%s", load_path);
		goto done;
	}

	if (tray_load_svg_pixbuf(load_path, target_h, &pixbuf) != 0) {
		pixbuf = gdk_pixbuf_new_from_file(load_path, &gerr);
		if (!pixbuf) {
			if (gerr) {
				wlr_log(WLR_ERROR, "net icon: failed to load '%s': %s", load_path, gerr->message);
				g_error_free(gerr);
			}
			return -1;
		}
	} else if (strcmp(path, net_icon_wifi_100) == 0
			|| (net_icon_wifi_100_resolved[0]
					&& strcmp(load_path, net_icon_wifi_100_resolved) == 0)) {
		/* Some themes tint this asset; normalize to expected green */
		recolor_wifi100_pixbuf(pixbuf);
	}

	buf = statusbar_buffer_from_pixbuf(pixbuf, target_h, &w, &h);
	if (!buf)
		return -1;

done:
	drop_net_icon_buffer();
	net_icon_buf = buf;
	net_icon_w = w;
	net_icon_h = h;
	net_icon_loaded_h = target_h;
	snprintf(net_icon_loaded_path, sizeof(net_icon_loaded_path), "%s", load_path);
	wlr_log(WLR_INFO, "net icon: loaded %s (resolved=%s) w=%d h=%d target_h=%d",
			path, load_path, net_icon_w, net_icon_h, target_h);
	return 0;
}

static int
ensure_net_icon_buffer(int target_h)
{
	if (target_h <= 0)
		return -1;

	if (net_icon_buf && net_icon_loaded_h == target_h &&
			strncmp(net_icon_loaded_path, net_icon_path, sizeof(net_icon_loaded_path)) == 0)
		return 0;

	if (load_net_icon_buffer(net_icon_path, target_h) == 0)
		return 0;

	/* fallback to offline icon if the requested asset is missing */
	if (strcmp(net_icon_path, net_icon_no_conn) != 0)
		return load_net_icon_buffer(net_icon_no_conn, target_h);

	return -1;
}

static void
drop_bluetooth_icon_buffer(void)
{
	if (bluetooth_icon_buf) {
		wlr_buffer_drop(bluetooth_icon_buf);
		bluetooth_icon_buf = NULL;
	}
	bluetooth_icon_loaded_h = 0;
	bluetooth_icon_loaded_path[0] = '\0';
	bluetooth_icon_w = 0;
	bluetooth_icon_h = 0;
}

static int
load_bluetooth_icon_buffer(const char *path, int target_h)
{
	GError *gerr = NULL;
	struct wlr_buffer *buf;
	int w = 0, h = 0;
	GdkPixbuf *pixbuf = NULL;
	char resolved[PATH_MAX];
	const char *load_path = path;

	if (!path || !*path || target_h <= 0)
		return -1;

	if (resolve_asset_path(path, resolved, sizeof(resolved)) == 0)
		load_path = resolved;

	if (tray_load_svg_pixbuf(load_path, target_h, &pixbuf) != 0) {
		pixbuf = gdk_pixbuf_new_from_file(load_path, &gerr);
		if (!pixbuf) {
			if (gerr) {
				wlr_log(WLR_ERROR, "bluetooth icon: failed to load '%s': %s", load_path, gerr->message);
				g_error_free(gerr);
			}
			return -1;
		}
	}

	buf = statusbar_buffer_from_pixbuf(pixbuf, target_h, &w, &h);
	if (!buf)
		return -1;

	drop_bluetooth_icon_buffer();
	bluetooth_icon_buf = buf;
	bluetooth_icon_w = w;
	bluetooth_icon_h = h;
	bluetooth_icon_loaded_h = target_h;
	snprintf(bluetooth_icon_loaded_path, sizeof(bluetooth_icon_loaded_path), "%s", load_path);
	return 0;
}

static int
ensure_bluetooth_icon_buffer(int target_h)
{
	if (target_h <= 0)
		return -1;

	if (bluetooth_icon_buf && bluetooth_icon_loaded_h == target_h &&
			strncmp(bluetooth_icon_loaded_path, bluetooth_icon_path, sizeof(bluetooth_icon_loaded_path)) == 0)
		return 0;

	return load_bluetooth_icon_buffer(bluetooth_icon_path, target_h);
}

static void
drop_steam_icon_buffer(void)
{
	if (steam_icon_buf) {
		wlr_buffer_drop(steam_icon_buf);
		steam_icon_buf = NULL;
	}
	steam_icon_loaded_h = 0;
	steam_icon_loaded_path[0] = '\0';
	steam_icon_w = 0;
	steam_icon_h = 0;
}

static int
load_steam_icon_buffer(const char *path, int target_h)
{
	GError *gerr = NULL;
	struct wlr_buffer *buf;
	int w = 0, h = 0;
	GdkPixbuf *pixbuf = NULL;
	char resolved[PATH_MAX];
	const char *load_path = path;

	if (!path || !*path || target_h <= 0)
		return -1;

	if (resolve_asset_path(path, resolved, sizeof(resolved)) == 0)
		load_path = resolved;

	if (tray_load_svg_pixbuf(load_path, target_h, &pixbuf) != 0) {
		pixbuf = gdk_pixbuf_new_from_file(load_path, &gerr);
		if (!pixbuf) {
			if (gerr) {
				wlr_log(WLR_ERROR, "steam icon: failed to load '%s': %s", load_path, gerr->message);
				g_error_free(gerr);
			}
			return -1;
		}
	}

	buf = statusbar_buffer_from_pixbuf(pixbuf, target_h, &w, &h);
	if (!buf)
		return -1;

	drop_steam_icon_buffer();
	steam_icon_buf = buf;
	steam_icon_w = w;
	steam_icon_h = h;
	steam_icon_loaded_h = target_h;
	snprintf(steam_icon_loaded_path, sizeof(steam_icon_loaded_path), "%s", load_path);
	return 0;
}

static int
ensure_steam_icon_buffer(int target_h)
{
	if (target_h <= 0)
		return -1;

	if (steam_icon_buf && steam_icon_loaded_h == target_h &&
			strncmp(steam_icon_loaded_path, steam_icon_path, sizeof(steam_icon_loaded_path)) == 0)
		return 0;

	return load_steam_icon_buffer(steam_icon_path, target_h);
}

static void
drop_discord_icon_buffer(void)
{
	if (discord_icon_buf) {
		wlr_buffer_drop(discord_icon_buf);
		discord_icon_buf = NULL;
	}
	discord_icon_loaded_h = 0;
	discord_icon_loaded_path[0] = '\0';
	discord_icon_w = 0;
	discord_icon_h = 0;
}

static int
load_discord_icon_buffer(const char *path, int target_h)
{
	GError *gerr = NULL;
	struct wlr_buffer *buf;
	int w = 0, h = 0;
	GdkPixbuf *pixbuf = NULL;
	char resolved[PATH_MAX];
	const char *load_path = path;

	if (!path || !*path || target_h <= 0)
		return -1;

	if (resolve_asset_path(path, resolved, sizeof(resolved)) == 0)
		load_path = resolved;

	if (tray_load_svg_pixbuf(load_path, target_h, &pixbuf) != 0) {
		pixbuf = gdk_pixbuf_new_from_file(load_path, &gerr);
		if (!pixbuf) {
			if (gerr) {
				wlr_log(WLR_ERROR, "discord icon: failed to load '%s': %s", load_path, gerr->message);
				g_error_free(gerr);
			}
			return -1;
		}
	}

	buf = statusbar_buffer_from_pixbuf(pixbuf, target_h, &w, &h);
	if (!buf)
		return -1;

	drop_discord_icon_buffer();
	discord_icon_buf = buf;
	discord_icon_w = w;
	discord_icon_h = h;
	discord_icon_loaded_h = target_h;
	snprintf(discord_icon_loaded_path, sizeof(discord_icon_loaded_path), "%s", load_path);
	return 0;
}

static int
ensure_discord_icon_buffer(int target_h)
{
	if (target_h <= 0)
		return -1;

	if (discord_icon_buf && discord_icon_loaded_h == target_h &&
			strncmp(discord_icon_loaded_path, discord_icon_path, sizeof(discord_icon_loaded_path)) == 0)
		return 0;

	return load_discord_icon_buffer(discord_icon_path, target_h);
}

static void
renderbluetooth(Monitor *m, int bar_height)
{
	StatusModule *module;
	int padding, target_h, icon_x, icon_y, base_h;
	struct wlr_scene_buffer *scene_buf;

	if (!m || !m->statusbar.bluetooth.tree)
		return;

	module = &m->statusbar.bluetooth;
	clearstatusmodule(module);
	module->width = 0;
	module->x = 0;

	/* Only show if bluetooth is available */
	if (!bluetooth_available) {
		wlr_scene_node_set_enabled(&module->tree->node, 0);
		return;
	}

	padding = statusbar_module_padding / 2;
	if (padding < 1)
		padding = 1;
	base_h = bar_height - 2 * padding;
	target_h = (int)lround(base_h * 1.5);
	if (target_h > bar_height)
		target_h = bar_height;
	if (target_h <= 0)
		target_h = bar_height - padding;
	if (target_h <= 0)
		target_h = 1;

	if (ensure_bluetooth_icon_buffer(target_h) != 0 || !bluetooth_icon_buf ||
			bluetooth_icon_w <= 0 || bluetooth_icon_h <= 0) {
		wlr_scene_node_set_enabled(&module->tree->node, 0);
		return;
	}

	module->width = bluetooth_icon_w + 2 * padding;
	if (module->width < bluetooth_icon_w)
		module->width = bluetooth_icon_w;

	updatemodulebg(module, module->width, bar_height, statusbar_bg);

	scene_buf = wlr_scene_buffer_create(module->tree, NULL);
	if (scene_buf) {
		int usable_w = module->width - 2 * padding;
		icon_x = padding + MAX(0, (usable_w - bluetooth_icon_w) / 2);
		icon_y = MAX(0, (bar_height - bluetooth_icon_h) / 2);
		wlr_scene_buffer_set_buffer(scene_buf, bluetooth_icon_buf);
		wlr_scene_node_set_position(&scene_buf->node, icon_x, icon_y);
	}

	wlr_scene_node_set_enabled(&module->tree->node, module->width > 0);
}

static void
rendersteam(Monitor *m, int bar_height)
{
	StatusModule *module;
	int padding, target_h, icon_x, icon_y, base_h;
	struct wlr_scene_buffer *scene_buf;

	if (!m || !m->statusbar.steam.tree)
		return;

	module = &m->statusbar.steam;
	clearstatusmodule(module);
	module->width = 0;
	module->x = 0;

	/* Only show if Steam process is running */
	steam_running = is_process_running("steam");
	if (!steam_running) {
		wlr_scene_node_set_enabled(&module->tree->node, 0);
		return;
	}

	padding = statusbar_module_padding / 2;
	if (padding < 1)
		padding = 1;
	base_h = bar_height - 2 * padding;
	target_h = (int)lround(base_h * 1.5);
	if (target_h > bar_height)
		target_h = bar_height;
	if (target_h <= 0)
		target_h = bar_height - padding;
	if (target_h <= 0)
		target_h = 1;

	if (ensure_steam_icon_buffer(target_h) != 0 || !steam_icon_buf ||
			steam_icon_w <= 0 || steam_icon_h <= 0) {
		wlr_scene_node_set_enabled(&module->tree->node, 0);
		return;
	}

	module->width = steam_icon_w + 2 * padding;
	if (module->width < steam_icon_w)
		module->width = steam_icon_w;

	updatemodulebg(module, module->width, bar_height, statusbar_bg);

	scene_buf = wlr_scene_buffer_create(module->tree, NULL);
	if (scene_buf) {
		int usable_w = module->width - 2 * padding;
		icon_x = padding + MAX(0, (usable_w - steam_icon_w) / 2);
		icon_y = MAX(0, (bar_height - steam_icon_h) / 2);
		wlr_scene_buffer_set_buffer(scene_buf, steam_icon_buf);
		wlr_scene_node_set_position(&scene_buf->node, icon_x, icon_y);
	}

	wlr_scene_node_set_enabled(&module->tree->node, module->width > 0);
}

static void
renderdiscord(Monitor *m, int bar_height)
{
	StatusModule *module;
	int padding, target_h, icon_x, icon_y, base_h;
	struct wlr_scene_buffer *scene_buf;

	if (!m || !m->statusbar.discord.tree)
		return;

	module = &m->statusbar.discord;
	clearstatusmodule(module);
	module->width = 0;
	module->x = 0;

	/* Only show if Discord process is running.
	 * Check both "Discord" and ".Discord" for NixOS wrapped version */
	discord_running = is_process_running("Discord") || is_process_running(".Discord");
	if (!discord_running) {
		wlr_scene_node_set_enabled(&module->tree->node, 0);
		return;
	}

	padding = statusbar_module_padding / 2;
	if (padding < 1)
		padding = 1;
	base_h = bar_height - 2 * padding;
	target_h = (int)lround(base_h * 1.5);
	if (target_h > bar_height)
		target_h = bar_height;
	if (target_h <= 0)
		target_h = bar_height - padding;
	if (target_h <= 0)
		target_h = 1;

	if (ensure_discord_icon_buffer(target_h) != 0 || !discord_icon_buf ||
			discord_icon_w <= 0 || discord_icon_h <= 0) {
		wlr_scene_node_set_enabled(&module->tree->node, 0);
		return;
	}

	module->width = discord_icon_w + 2 * padding;
	if (module->width < discord_icon_w)
		module->width = discord_icon_w;

	updatemodulebg(module, module->width, bar_height, statusbar_bg);

	scene_buf = wlr_scene_buffer_create(module->tree, NULL);
	if (scene_buf) {
		int usable_w = module->width - 2 * padding;
		icon_x = padding + MAX(0, (usable_w - discord_icon_w) / 2);
		icon_y = MAX(0, (bar_height - discord_icon_h) / 2);
		wlr_scene_buffer_set_buffer(scene_buf, discord_icon_buf);
		wlr_scene_node_set_position(&scene_buf->node, icon_x, icon_y);
	}

	wlr_scene_node_set_enabled(&module->tree->node, module->width > 0);
}

static void
rendertrayicons(Monitor *m, int bar_height)
{
	StatusModule *module;
	int padding, target_h, icon_x, icon_y, base_h;
	struct wlr_scene_buffer *scene_buf;

	if (!m || !m->statusbar.sysicons.tree)
		return;

	module = &m->statusbar.sysicons;
	clearstatusmodule(module);
	module->width = 0;
	module->x = 0;

	/* Use a small padding so the icon fills most of the bar height */
	padding = statusbar_module_padding / 2;
	if (padding < 1)
		padding = 1;
	base_h = bar_height - 2 * padding;
	target_h = (int)lround(base_h * 1.5); /* 50% larger */
	if (target_h > bar_height)
		target_h = bar_height;
	if (target_h <= 0)
		target_h = bar_height - padding;
	if (target_h <= 0)
		target_h = 1;

	if (ensure_net_icon_buffer(target_h) != 0 || !net_icon_buf || net_icon_w <= 0 || net_icon_h <= 0) {
		wlr_scene_node_set_enabled(&module->tree->node, 0);
		return;
	}

	module->width = net_icon_w + 2 * padding;
	if (module->width < net_icon_w)
		module->width = net_icon_w;

	updatemodulebg(module, module->width, bar_height, statusbar_bg);

	scene_buf = wlr_scene_buffer_create(module->tree, NULL);
	if (scene_buf) {
		int usable_w = module->width - 2 * padding;
		icon_x = padding + MAX(0, (usable_w - net_icon_w) / 2);
		icon_y = MAX(0, (bar_height - net_icon_h) / 2);
		wlr_scene_buffer_set_buffer(scene_buf, net_icon_buf);
		wlr_scene_node_set_position(&scene_buf->node, icon_x, icon_y);
	}

	wlr_scene_node_set_enabled(&module->tree->node, module->width > 0);
}

static void
fix_tray_argb32(uint32_t *pixels, size_t count, int use_rgba_order)
{
	size_t i;

	if (!pixels || count == 0)
		return;

	for (i = 0; i < count; i++) {
		/* IconPixmap spec: ARGB32, bytes in big-endian order A,R,G,B */
		const uint8_t *p8 = (const uint8_t *)&pixels[i];
		uint8_t a, r, g, b;

		if (use_rgba_order || statusbar_tray_force_rgba) {
			/* Fallback for apps that provide RGBA bytes */
			r = p8[0];
			g = p8[1];
			b = p8[2];
			a = p8[3];
		} else {
			a = p8[0];
			r = p8[1];
			g = p8[2];
			b = p8[3];
		}

		/* Premultiply for pixman/wlroots */
		if (a != 0 && a != 255) {
			r = (uint8_t)((r * a + 127) / 255);
			g = (uint8_t)((g * a + 127) / 255);
			b = (uint8_t)((b * a + 127) / 255);
		}

		pixels[i] = ((uint32_t)a << 24) | ((uint32_t)r << 16) |
			((uint32_t)g << 8) | (uint32_t)b;
	}
}

static void
init_net_icon_paths(void)
{
	resolve_asset_path(net_icon_wifi_100, net_icon_wifi_100_resolved, sizeof(net_icon_wifi_100_resolved));
	resolve_asset_path(net_icon_wifi_75, net_icon_wifi_75_resolved, sizeof(net_icon_wifi_75_resolved));
	resolve_asset_path(net_icon_wifi_50, net_icon_wifi_50_resolved, sizeof(net_icon_wifi_50_resolved));
	resolve_asset_path(net_icon_wifi_25, net_icon_wifi_25_resolved, sizeof(net_icon_wifi_25_resolved));
	resolve_asset_path(net_icon_eth, net_icon_eth_resolved, sizeof(net_icon_eth_resolved));
	resolve_asset_path(net_icon_no_conn, net_icon_no_conn_resolved, sizeof(net_icon_no_conn_resolved));
	if (net_icon_no_conn_resolved[0])
		snprintf(net_icon_path, sizeof(net_icon_path), "%s", net_icon_no_conn_resolved);
	wlr_log(WLR_INFO, "net icon paths: wifi100=%s wifi75=%s wifi50=%s wifi25=%s eth=%s noconn=%s",
			net_icon_wifi_100_resolved[0] ? net_icon_wifi_100_resolved : net_icon_wifi_100,
			net_icon_wifi_75_resolved[0] ? net_icon_wifi_75_resolved : net_icon_wifi_75,
			net_icon_wifi_50_resolved[0] ? net_icon_wifi_50_resolved : net_icon_wifi_50,
			net_icon_wifi_25_resolved[0] ? net_icon_wifi_25_resolved : net_icon_wifi_25,
			net_icon_eth_resolved[0] ? net_icon_eth_resolved : net_icon_eth,
			net_icon_no_conn_resolved[0] ? net_icon_no_conn_resolved : net_icon_no_conn);
}

static struct wlr_buffer *
statusbar_scaled_buffer_from_argb32(const uint32_t *data, int width, int height, int target_h)
{
	pixman_image_t *src = NULL, *dst = NULL;
	struct PixmanBuffer *buf;
	uint8_t *src_copy = NULL;
	uint8_t *dst_copy = NULL;
	size_t src_stride, dst_stride, src_size, dst_size;
	int target_w;
	pixman_transform_t transform;

	if (!data || width <= 0 || height <= 0 || target_h <= 0)
		return NULL;

	target_w = (int)lround(((double)width * (double)target_h) / (double)height);
	if (target_w <= 0)
		target_w = 1;

	src_stride = (size_t)width * 4;
	dst_stride = (size_t)target_w * 4;
	src_size = src_stride * (size_t)height;
	dst_size = dst_stride * (size_t)target_h;

	src_copy = calloc(1, src_size);
	dst_copy = calloc(1, dst_size);
	if (!src_copy || !dst_copy)
		goto fail;
	memcpy(src_copy, data, src_size);
	fix_tray_argb32((uint32_t *)src_copy, (size_t)width * (size_t)height, 0);

	/* If the first pass produced fully transparent data, retry assuming RGBA order */
	{
		size_t alpha_sum = 0;
		for (size_t n = 0; n < (size_t)width * (size_t)height; n++)
			alpha_sum += src_copy[n * 4];
		if (alpha_sum == 0) {
			memcpy(src_copy, data, src_size);
			fix_tray_argb32((uint32_t *)src_copy, (size_t)width * (size_t)height, 1);
		}
	}

	src = pixman_image_create_bits_no_clear(PIXMAN_a8r8g8b8, width, height,
			(uint32_t *)src_copy, (int)src_stride);
	dst = pixman_image_create_bits_no_clear(PIXMAN_a8r8g8b8, target_w, target_h,
			(uint32_t *)dst_copy, (int)dst_stride);
	if (!src || !dst)
		goto fail;

	/* Scale with a simple bilinear filter to fit the bar height */
	pixman_transform_init_identity(&transform);
	pixman_transform_scale(&transform, NULL,
			pixman_double_to_fixed((double)width / (double)target_w),
			pixman_double_to_fixed((double)height / (double)target_h));
	pixman_image_set_transform(src, &transform);
	pixman_image_set_filter(src, PIXMAN_FILTER_BILINEAR, NULL, 0);

	pixman_image_composite32(PIXMAN_OP_SRC, src, NULL, dst,
			0, 0, 0, 0, 0, 0, target_w, target_h);

	pixman_image_unref(src);
	free(src_copy);
	src = NULL;
	src_copy = NULL;

	buf = ecalloc(1, sizeof(*buf));
	if (!buf)
		goto fail;

	buf->image = dst;
	buf->data = dst_copy;
	buf->drm_format = DRM_FORMAT_ARGB8888;
	buf->stride = (int)dst_stride;
	buf->owns_data = 1;
	wlr_buffer_init(&buf->base, &pixman_buffer_impl, target_w, target_h);
	return &buf->base;

fail:
	if (src)
		pixman_image_unref(src);
	if (dst)
		pixman_image_unref(dst);
	free(src_copy);
	free(dst_copy);
	return NULL;
}

static struct wlr_buffer *
statusbar_scaled_buffer_from_argb32_raw(const uint32_t *data, int width, int height, int target_h)
{
	pixman_image_t *src = NULL, *dst = NULL;
	struct PixmanBuffer *buf;
	uint8_t *src_copy = NULL;
	uint8_t *dst_copy = NULL;
	size_t src_stride, dst_stride, src_size, dst_size;
	int target_w;
	pixman_transform_t transform;

	if (!data || width <= 0 || height <= 0 || target_h <= 0)
		return NULL;

	target_w = (int)lround(((double)width * (double)target_h) / (double)height);
	if (target_w <= 0)
		target_w = 1;

	src_stride = (size_t)width * 4;
	dst_stride = (size_t)target_w * 4;
	src_size = src_stride * (size_t)height;
	dst_size = dst_stride * (size_t)target_h;

	src_copy = calloc(1, src_size);
	dst_copy = calloc(1, dst_size);
	if (!src_copy || !dst_copy)
		goto fail;
	memcpy(src_copy, data, src_size);

	src = pixman_image_create_bits_no_clear(PIXMAN_a8r8g8b8, width, height,
			(uint32_t *)src_copy, (int)src_stride);
	dst = pixman_image_create_bits_no_clear(PIXMAN_a8r8g8b8, target_w, target_h,
			(uint32_t *)dst_copy, (int)dst_stride);
	if (!src || !dst)
		goto fail;

	pixman_transform_init_identity(&transform);
	pixman_transform_scale(&transform, NULL,
			pixman_double_to_fixed((double)width / (double)target_w),
			pixman_double_to_fixed((double)height / (double)target_h));
	pixman_image_set_transform(src, &transform);
	pixman_image_set_filter(src, PIXMAN_FILTER_BILINEAR, NULL, 0);

	pixman_image_composite32(PIXMAN_OP_SRC, src, NULL, dst,
			0, 0, 0, 0, 0, 0, target_w, target_h);

	pixman_image_unref(src);
	free(src_copy);
	src = NULL;
	src_copy = NULL;

	buf = ecalloc(1, sizeof(*buf));
	if (!buf)
		goto fail;

	buf->image = dst;
	buf->data = dst_copy;
	buf->drm_format = DRM_FORMAT_ARGB8888;
	buf->stride = (int)dst_stride;
	buf->owns_data = 1;
	wlr_buffer_init(&buf->base, &pixman_buffer_impl, target_w, target_h);
	return &buf->base;

fail:
	if (src)
		pixman_image_unref(src);
	if (dst)
		pixman_image_unref(dst);
	free(src_copy);
	free(dst_copy);
	return NULL;
}

__attribute__((unused)) static struct wlr_buffer *
statusbar_buffer_from_argb32_raw(const uint32_t *data, int width, int height)
{
	pixman_image_t *dst;
	struct PixmanBuffer *buf;
	uint8_t *copy;
	size_t stride, size;

	if (!data || width <= 0 || height <= 0)
		return NULL;

	stride = (size_t)width * 4;
	size = stride * (size_t)height;
	copy = calloc(1, size);
	if (!copy)
		return NULL;
	memcpy(copy, data, size);

	dst = pixman_image_create_bits_no_clear(PIXMAN_a8r8g8b8, width, height,
			(uint32_t *)copy, (int)stride);
	if (!dst) {
		free(copy);
		return NULL;
	}

	buf = ecalloc(1, sizeof(*buf));
	if (!buf) {
		pixman_image_unref(dst);
		free(copy);
		return NULL;
	}

	buf->image = dst;
	buf->data = copy;
	buf->drm_format = DRM_FORMAT_ARGB8888;
	buf->stride = (int)stride;
	buf->owns_data = 1;
	wlr_buffer_init(&buf->base, &pixman_buffer_impl, width, height);
	return &buf->base;
}

static struct wlr_buffer *
statusbar_buffer_from_argb32(const uint32_t *data, int width, int height)
{
	pixman_image_t *dst;
	struct PixmanBuffer *buf;
	uint8_t *copy;
	size_t stride, size;

	if (!data || width <= 0 || height <= 0)
		return NULL;

	stride = (size_t)width * 4;
	size = stride * (size_t)height;
	copy = calloc(1, size);
	if (!copy)
		return NULL;
	memcpy(copy, data, size);
	fix_tray_argb32((uint32_t *)copy, (size_t)width * (size_t)height, 0);

	/* If the first pass produced fully transparent data, retry assuming RGBA order */
	{
		size_t alpha_sum = 0;
		for (size_t n = 0; n < (size_t)width * (size_t)height; n++)
			alpha_sum += copy[n * 4];
		if (alpha_sum == 0) {
			memcpy(copy, data, size);
			fix_tray_argb32((uint32_t *)copy, (size_t)width * (size_t)height, 1);
		}
	}

	dst = pixman_image_create_bits_no_clear(PIXMAN_a8r8g8b8, width, height,
			(uint32_t *)copy, (int)stride);
	if (!dst) {
		free(copy);
		return NULL;
	}

	buf = ecalloc(1, sizeof(*buf));
	if (!buf) {
		pixman_image_unref(dst);
		free(copy);
		return NULL;
	}

	buf->image = dst;
	buf->data = copy;
	buf->drm_format = DRM_FORMAT_ARGB8888;
	buf->stride = (int)stride;
	buf->owns_data = 1;
	wlr_buffer_init(&buf->base, &pixman_buffer_impl, width, height);

	return &buf->base;
}

static int
cpu_proc_is_critical(pid_t pid, const char *name)
{
	/* Only show real user applications - hide all system/background processes */
	const char *user_apps[] = {
		/* Browsers */
		"firefox", "chromium", "chrome", "brave", "vivaldi", "opera",
		"epiphany", "midori", "qutebrowser", "nyxt", "librewolf", "waterfox",
		"zen", "floorp", "thorium",
		/* File managers */
		"thunar", "nautilus", "dolphin", "nemo", "pcmanfm", "caja",
		"spacefm", "ranger", "lf", "nnn", "vifm",
		/* Terminals */
		"alacritty", "kitty", "foot", "wezterm", "konsole", "gnome-terminal",
		"xfce4-terminal", "terminator", "tilix", "st", "urxvt", "xterm",
		/* Editors/IDEs */
		"code", "codium", "vscodium", "nvim", "vim", "emacs", "gedit", "kate",
		"sublime", "atom", "jetbrains", "idea", "pycharm", "webstorm",
		"clion", "goland", "rider", "android-studio", "zed", "helix",
		/* Creative */
		"blender", "gimp", "inkscape", "krita", "darktable", "rawtherapee",
		"kdenlive", "shotcut", "openshot", "obs", "audacity", "ardour",
		"lmms", "bitwig", "reaper", "godot", "unity",
		/* Office */
		"libreoffice", "soffice", "writer", "calc", "impress", "draw",
		"onlyoffice", "wps", "evince", "okular", "zathura", "mupdf",
		/* Communication */
		"discord", "slack", "teams", "zoom", "skype", "telegram", "signal",
		"element", "fractal", "nheko", "thunderbird", "geary", "evolution",
		/* Media players */
		"vlc", "mpv", "celluloid", "totem", "parole", "smplayer",
		"spotify", "rhythmbox", "clementine", "strawberry", "elisa",
		/* Games */
		"steam", "lutris", "heroic", "bottles", "wine", "proton",
		"minecraft", "retroarch",
		/* Utilities */
		"keepassxc", "bitwarden", "1password", "syncthing", "transmission",
		"qbittorrent", "deluge", "fragments", "virt-manager", "virtualbox",
		"vmware", "docker", "podman",
		/* Misc apps */
		"calibre", "anki", "logseq", "obsidian", "notion", "joplin",
		"drawio", "figma", "postman", "insomnia", "dbeaver", "pgadmin",
		"ghidra", "wireshark", "burp"
	};

	if (pid <= 1 || pid == getpid())
		return 1;
	if (!name || !*name)
		return 1;

	/* Block kernel threads */
	if (name[0] == '[')
		return 1;

	/* Block common kernel/system process prefixes */
	if (!strncmp(name, "kworker", 7) || !strncmp(name, "ksoftirq", 8) ||
	    !strncmp(name, "kthread", 7) || !strncmp(name, "kswapd", 6) ||
	    !strncmp(name, "rcu_", 4) || !strncmp(name, "migration", 9) ||
	    !strncmp(name, "irq/", 4) || !strncmp(name, "watchdog", 8) ||
	    !strncmp(name, "khugepaged", 10) || !strncmp(name, "kcompact", 8) ||
	    !strncmp(name, "writeback", 9) || !strncmp(name, "kblockd", 7) ||
	    !strncmp(name, "oom_", 4) || !strncmp(name, "kaudit", 6) ||
	    !strncmp(name, "ksmd", 4) || !strncmp(name, "khungtask", 9) ||
	    !strncmp(name, "kdevtmpfs", 9) || !strncmp(name, "netns", 5) ||
	    !strncmp(name, "kintegrity", 10) || !strncmp(name, "bioset", 6) ||
	    !strncmp(name, "crypto", 6) || !strncmp(name, "kstrp", 5) ||
	    !strncmp(name, "charger", 7) || !strncmp(name, "scsi_", 5) ||
	    !strncmp(name, "nvme", 4) || !strncmp(name, "usb-storage", 11) ||
	    !strncmp(name, "jbd2", 4) || !strncmp(name, "ext4", 4) ||
	    !strncmp(name, "btrfs", 5) || !strncmp(name, "xfs", 3) ||
	    !strncmp(name, "dm-", 3) || !strncmp(name, "md", 2) ||
	    !strncmp(name, "loop", 4) || !strncmp(name, "zram", 4) ||
	    !strncmp(name, "cfg80211", 8) || !strncmp(name, "card", 4) ||
	    !strncmp(name, "i915", 4) || !strncmp(name, "amdgpu", 6) ||
	    !strncmp(name, "nvidia", 6) ||
	    /* systemd and related */
	    !strncmp(name, "systemd", 7) || !strncmp(name, "(sd-", 4) ||
	    !strncmp(name, "sd-", 3))
		return 1;

	/* Block by suffix patterns */
	{
		size_t len = strlen(name);
		if (len > 2 && name[len-1] == 'd' && name[len-2] == '-')
			return 1; /* ends with -d (daemon) */
		if (strcasestr(name, "daemon") || strcasestr(name, "helper") ||
		    strcasestr(name, "agent") || strcasestr(name, "server") ||
		    strcasestr(name, "service") || strcasestr(name, "worker") ||
		    strcasestr(name, "watcher") || strcasestr(name, "monitor"))
			return 1;
	}

	/* Whitelist approach: only show known user applications */
	for (size_t i = 0; i < LENGTH(user_apps); i++) {
		if (strcasestr(name, user_apps[i]))
			return 0; /* NOT critical - show it */
	}

	/* Everything else is considered system/background - hide it */
	return 1;
}

static int
cpu_proc_cmp(const void *a, const void *b)
{
	const CpuProcEntry *pa = a;
	const CpuProcEntry *pb = b;

	if (pa->cpu < pb->cpu)
		return 1;
	if (pa->cpu > pb->cpu)
		return -1;
	if (pa->pid < pb->pid)
		return -1;
	if (pa->pid > pb->pid)
		return 1;
	return 0;
}

static int
cpu_popup_clamped_x(Monitor *m, CpuPopup *p)
{
	int popup_x;

	if (!m || !p)
		return 0;

	popup_x = m->statusbar.cpu.x;
	if (p->width > 0 && m->statusbar.area.width > 0) {
		int max_x = m->statusbar.area.width - p->width;
		if (max_x < 0)
			max_x = 0;
		if (popup_x > max_x)
			popup_x = max_x;
		if (popup_x < 0)
			popup_x = 0;
	}
	return popup_x;
}

static int
cpu_popup_hover_index(Monitor *m, CpuPopup *p)
{
	int rel_x, rel_y;
	int popup_x;

	if (!m || !p || p->proc_count <= 0 || p->width <= 0 || p->height <= 0)
		return -1;

	popup_x = cpu_popup_clamped_x(m, p);
	rel_x = (int)floor(cursor->x) - m->statusbar.area.x - popup_x;
	rel_y = (int)floor(cursor->y) - m->statusbar.area.y - m->statusbar.area.height;
	if (rel_x < 0 || rel_y < 0 || rel_x >= p->width || rel_y >= p->height)
		return -1;

	for (int i = 0; i < p->proc_count; i++) {
		CpuProcEntry *e = &p->procs[i];
		if (!e->has_kill || e->kill_w <= 0 || e->kill_h <= 0)
			continue;
		if (rel_x >= e->kill_x && rel_x < e->kill_x + e->kill_w &&
				rel_y >= e->kill_y && rel_y < e->kill_y + e->kill_h)
			return i;
	}
	return -1;
}

static int
kill_processes_with_name(const char *name)
{
	DIR *dir;
	struct dirent *ent;
	int killed = 0;
	int found = 0;

	if (!name || !*name)
		return 0;

	dir = opendir("/proc");
	if (!dir)
		return 0;

	while ((ent = readdir(dir))) {
		pid_t pid = 0;
		char comm_path[PATH_MAX];
		char comm[256];
		FILE *fp;
		size_t len;
		int is_num = 1;

		if (!ent->d_name || !*ent->d_name)
			continue;
		for (size_t i = 0; ent->d_name[i]; i++) {
			if (!isdigit((unsigned char)ent->d_name[i])) {
				is_num = 0;
				break;
			}
		}
		if (!is_num)
			continue;

		pid = (pid_t)atoi(ent->d_name);
		if (pid <= 1 || pid == getpid())
			continue;

		found = 1;

		snprintf(comm_path, sizeof(comm_path), "/proc/%s/comm", ent->d_name);
		fp = fopen(comm_path, "r");
		if (!fp)
			continue;
		if (!fgets(comm, sizeof(comm), fp)) {
			fclose(fp);
			continue;
		}
		fclose(fp);
		len = strlen(comm);
		if (len > 0 && comm[len - 1] == '\n')
			comm[len - 1] = '\0';

		if (strcmp(comm, name) == 0) {
			if (kill(pid, SIGKILL) == 0) {
				killed++;
			} else {
				wlr_log(WLR_ERROR, "cpu popup: kill %d (%s) failed: %s",
						pid, name, strerror(errno));
			}
		}
	}

	closedir(dir);
	if (killed == 0 && found > 0) {
		/* Fallback: use pkill (non-blocking) */
		if (fork() == 0) {
			setsid();
			execlp("pkill", "pkill", "-9", "-x", name, (char *)NULL);
			_exit(127);
		}
	}
	return killed;
}

static int
read_top_cpu_processes(CpuPopup *p)
{
	FILE *fp;
	char line[256];
	int count = 0;
	int lines = 0;

	if (!p)
		return 0;

	/* Use top for real-time CPU usage (not cumulative like ps pcpu) */
	fp = popen("top -bn1 -o %CPU 2>/dev/null | tail -n +8 | head -50", "r");
	if (!fp) {
		p->proc_count = 0;
		return 0;
	}

	while (fgets(line, sizeof(line), fp) && lines < 128) {
		CpuProcEntry *e;
		pid_t pid = 0;
		char name[64] = {0};
		double cpu = 0.0;
		int existing = -1;
		char user[32], pr[8], ni[8], virt[16], res[16], shr[16], s[4];

		lines++;
		/* top format: PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND */
		if (sscanf(line, "%d %31s %7s %7s %15s %15s %15s %3s %lf %*f %*s %63s",
		           &pid, user, pr, ni, virt, res, shr, s, &cpu, name) < 10)
			continue;
		if (name[0] == '[')
			continue;
		if (cpu_proc_is_critical(pid, name))
			continue;

		for (int i = 0; i < count; i++) {
			if (strcmp(p->procs[i].name, name) == 0) {
				existing = i;
				break;
			}
		}

		if (existing >= 0) {
			e = &p->procs[existing];
			e->cpu += cpu;
			if (cpu > e->max_single_cpu) {
				e->max_single_cpu = cpu;
				e->pid = pid;
			}
		} else if (count < (int)LENGTH(p->procs)) {
			e = &p->procs[count];
			e->pid = pid;
			snprintf(e->name, sizeof(e->name), "%s", name);
			e->cpu = cpu;
			e->max_single_cpu = cpu;
			e->y = e->height = 0;
			e->kill_x = e->kill_y = e->kill_w = e->kill_h = 0;
			e->has_kill = 1;
			count++;
		}
	}

	pclose(fp);
	if (count > 1)
		qsort(p->procs, (size_t)count, sizeof(p->procs[0]), cpu_proc_cmp);
	p->proc_count = count;
	return count;
}

static void
rendercpupopup(Monitor *m)
{
	CpuPopup *p;
	int padding, line_spacing;
	int line_count;
	int left_w = 0, right_w = 0;
	int left_h = 0, right_h = 0;
	int content_h;
	int column_gap;
	int row_height;
	int button_gap;
	int kill_text_w;
	int kill_w;
	int kill_h;
	uint64_t now;
	int use_right_gap;
	int hover_idx;
	int popup_x = m->statusbar.cpu.x;
	int need_fetch_now;
	int max_proc_text_w = 0;
	int any_has_kill = 0;
	char line[64];
	struct wlr_scene_node *node, *tmp;

	if (!m || !m->statusbar.cpu_popup.tree)
		return;

	p = &m->statusbar.cpu_popup;
	hover_idx = p->hover_idx;
	if (hover_idx < -1 || hover_idx >= (int)LENGTH(p->procs))
		hover_idx = -1;
	padding = statusbar_module_padding;
	line_spacing = 2;
	column_gap = statusbar_module_spacing + 8;
	row_height = statusfont.height > 0 ? statusfont.height : 16;
	button_gap = statusbar_module_spacing > 0 ? statusbar_module_spacing / 2 : 6;
	kill_text_w = status_text_width("Kill");
	kill_w = kill_text_w + 12;
	kill_h = row_height;
	now = monotonic_msec();
	need_fetch_now = 0;
	now = monotonic_msec();

	/* Clear previous buffers but keep bg */
	wl_list_for_each_safe(node, tmp, &p->tree->children, link) {
		if (p->bg && node == &p->bg->node)
			continue;
		wlr_scene_node_destroy(node);
	}

	if (!statusfont.font || cpu_core_count <= 0) {
		p->width = p->height = 0;
		if (p->tree)
			wlr_scene_node_set_enabled(&p->tree->node, 0);
		p->visible = 0;
		return;
	}

	/* Only fetch data after suppress delay has passed */
	if (p->suppress_refresh_until_ms == 0 || now >= p->suppress_refresh_until_ms) {
		if (p->last_fetch_ms == 0 ||
				now < p->last_fetch_ms ||
				now - p->last_fetch_ms >= cpu_popup_refresh_interval_ms)
			p->refresh_data = 1;

		if (p->refresh_data) {
			if (p->last_fetch_ms == 0 || now - p->last_fetch_ms >= 200)
				need_fetch_now = 1;
			if (need_fetch_now) {
				read_top_cpu_processes(p);
				p->last_fetch_ms = now;
			}
			if (p->suppress_refresh_until_ms > 0)
				p->suppress_refresh_until_ms = 0;
			p->refresh_data = 0;
		}
	}
	line_count = cpu_core_count + 1; /* +1 for avg line */

	for (int i = 0; i < line_count; i++) {
		double perc = (i < cpu_core_count) ? cpu_last_core_percent[i] : cpu_last_percent;

		if (perc < 0.0) {
			if (i < cpu_core_count)
				snprintf(line, sizeof(line), "C%d: --%%", i);
			else
				snprintf(line, sizeof(line), "Avg: --%%");
		} else if (i < cpu_core_count) {
			snprintf(line, sizeof(line), "C%d: %d%%", i, (int)lround(perc));
		} else {
			int avg_disp = (perc < 1.0) ? 0 : (int)lround(perc);
			snprintf(line, sizeof(line), "Avg: %d%%", avg_disp);
		}
		left_w = MAX(left_w, status_text_width(line));
	}
	left_h = line_count * row_height + (line_count - 1) * line_spacing;

	/* First pass: find max text width for vertical kill button alignment */
	for (int i = 0; i < p->proc_count; i++) {
		CpuProcEntry *e = &p->procs[i];
		int cpu_disp = (int)lround(e->cpu < 0.0 ? 0.0 : e->cpu);
		int text_w;
		char proc_line[128];

		snprintf(proc_line, sizeof(proc_line), "%s %d%%", e->name, cpu_disp);
		text_w = status_text_width(proc_line);
		max_proc_text_w = MAX(max_proc_text_w, text_w);
		if (e->has_kill)
			any_has_kill = 1;
	}
	/* Calculate right_w with aligned kill buttons */
	if (p->proc_count > 0) {
		right_w = max_proc_text_w;
		if (any_has_kill)
			right_w += button_gap + kill_w;
	}
	if (p->proc_count > 0)
		right_h = p->proc_count * row_height + (p->proc_count - 1) * line_spacing;

	content_h = MAX(left_h, right_h);
	use_right_gap = right_w > 0 ? column_gap : 0;
	p->width = 2 * padding + left_w + use_right_gap + right_w;
	p->height = content_h + 2 * padding;

	if (p->width > 0 && m->statusbar.area.width > 0) {
		int max_x = m->statusbar.area.width - p->width;
		if (max_x < 0)
			max_x = 0;
		if (popup_x > max_x)
			popup_x = max_x;
		if (popup_x < 0)
			popup_x = 0;
	}

	if (!p->bg && !(p->bg = wlr_scene_tree_create(p->tree)))
		return;
	wlr_scene_node_set_enabled(&p->bg->node, 1);
	wlr_scene_node_set_position(&p->bg->node, 0, 0);
	wl_list_for_each_safe(node, tmp, &p->bg->children, link)
		wlr_scene_node_destroy(node);
	drawrect(p->bg, 0, 0, p->width, p->height, statusbar_popup_bg);

	for (int i = 0; i < line_count; i++) {
		double perc = (i < cpu_core_count) ? cpu_last_core_percent[i] : cpu_last_percent;
		int row_y = padding + i * (row_height + line_spacing);
		struct wlr_scene_tree *row;
		StatusModule mod = {0};

		if (perc < 0.0) {
			if (i < cpu_core_count)
				snprintf(line, sizeof(line), "C%d: --%%", i);
			else
				snprintf(line, sizeof(line), "Avg: --%%");
		} else if (i < cpu_core_count) {
			snprintf(line, sizeof(line), "C%d: %d%%", i, (int)lround(perc));
		} else {
			int avg_disp = (perc < 1.0) ? 0 : (int)lround(perc);
			snprintf(line, sizeof(line), "Avg: %d%%", avg_disp);
		}

		row = wlr_scene_tree_create(p->tree);
		if (!row)
			continue;
		wlr_scene_node_set_position(&row->node, padding, row_y);
		mod.tree = row;
		tray_render_label(&mod, line, 0, row_height, statusbar_fg);
	}

	if (right_w > 0) {
		int right_x = padding + left_w + use_right_gap;
		for (int i = 0; i < p->proc_count; i++) {
			CpuProcEntry *e = &p->procs[i];
			int cpu_disp = (int)lround(e->cpu < 0.0 ? 0.0 : e->cpu);
			int row_y = padding + i * (row_height + line_spacing);
			int text_w;
			char proc_line[128];
			struct wlr_scene_tree *row;
			StatusModule mod = {0};

			snprintf(proc_line, sizeof(proc_line), "%s %d%%", e->name, cpu_disp);
			row = wlr_scene_tree_create(p->tree);
			if (row) {
				wlr_scene_node_set_position(&row->node, right_x, row_y);
				mod.tree = row;
				text_w = tray_render_label(&mod, proc_line, 0, row_height, statusbar_fg);
				if (text_w <= 0)
					text_w = status_text_width(proc_line);
			} else {
				text_w = status_text_width(proc_line);
			}

			e->y = row_y;
			e->height = row_height;
		if (e->has_kill && kill_w > 0 && kill_h > 0) {
			int btn_x = right_x + max_proc_text_w + button_gap;
			int btn_y = row_y + (row_height - kill_h) / 2;
			struct wlr_scene_tree *btn;
			StatusModule btn_mod = {0};
			const float *btn_color = statusbar_volume_muted_fg;
			int is_hover = (hover_idx == i);

			if (is_hover)
				btn_color = statusbar_tag_active_bg;

			e->kill_x = btn_x;
				e->kill_y = btn_y;
				e->kill_w = kill_w;
				e->kill_h = kill_h;
				drawrect(p->tree, btn_x, btn_y, kill_w, kill_h, btn_color);

				btn = wlr_scene_tree_create(p->tree);
				if (btn) {
					int text_x = (kill_w - kill_text_w) / 2;
					if (text_x < 2)
						text_x = 2;
					wlr_scene_node_set_position(&btn->node, btn_x, btn_y);
					btn_mod.tree = btn;
					tray_render_label(&btn_mod, "Kill", text_x, kill_h, statusbar_fg);
				}
			} else {
				e->kill_x = e->kill_y = e->kill_w = e->kill_h = 0;
				e->has_kill = 0;
			}
		}
	}

	if (p->width <= 0 || p->height <= 0)
		wlr_scene_node_set_enabled(&p->tree->node, 0);
	p->last_render_ms = now;
}

static int
cpu_popup_handle_click(Monitor *m, int lx, int ly, uint32_t button)
{
	CpuPopup *p;
	int rel_x, rel_y;
	int popup_x;

	if (!m || !m->statusbar.cpu_popup.visible || button != BTN_LEFT)
		return 0;

	p = &m->statusbar.cpu_popup;
	if (!p->tree || p->width <= 0 || p->height <= 0)
		return 0;

	popup_x = m->statusbar.cpu.x;
	if (p->width > 0 && m->statusbar.area.width > 0) {
		int max_x = m->statusbar.area.width - p->width;
		if (max_x < 0)
			max_x = 0;
		if (popup_x > max_x)
			popup_x = max_x;
		if (popup_x < 0)
			popup_x = 0;
	}

	rel_x = lx - popup_x;
	rel_y = ly - m->statusbar.area.height;
	if (rel_x < 0 || rel_y < 0 || rel_x >= p->width || rel_y >= p->height)
		return 0;

	for (int i = 0; i < p->proc_count; i++) {
		CpuProcEntry *e = &p->procs[i];
		if (!e->has_kill || e->kill_w <= 0 || e->kill_h <= 0)
			continue;
		if (rel_x >= e->kill_x && rel_x < e->kill_x + e->kill_w &&
				rel_y >= e->kill_y && rel_y < e->kill_y + e->kill_h) {
			if (cpu_proc_is_critical(e->pid, e->name))
				return 1;
			if (kill_processes_with_name(e->name) == 0) {
				if (kill(e->pid, SIGKILL) != 0)
					wlr_log(WLR_ERROR, "cpu popup: kill %d failed: %s",
							e->pid, strerror(errno));
			}
			p->last_fetch_ms = monotonic_msec();
			p->suppress_refresh_until_ms = p->last_fetch_ms + 2000;
			p->refresh_data = 0;
			schedule_cpu_popup_refresh(2000);
			refreshstatuscpu();
			return 1;
		}
	}

	return 0;
}

/* RAM Popup Functions */
static int
ram_proc_cmp(const void *a, const void *b)
{
	const RamProcEntry *pa = a;
	const RamProcEntry *pb = b;

	if (pa->mem_kb < pb->mem_kb)
		return 1;
	if (pa->mem_kb > pb->mem_kb)
		return -1;
	if (pa->pid < pb->pid)
		return -1;
	if (pa->pid > pb->pid)
		return 1;
	return 0;
}

static int
read_top_ram_processes(RamPopup *p)
{
	FILE *fp;
	char line[256];
	int count = 0;
	int lines = 0;
	const unsigned long min_kb = 50 * 1024; /* 50 MB minimum */

	if (!p)
		return 0;

	/* ps with RSS (resident set size) in KB, sorted by memory */
	fp = popen("ps -eo pid,rss,comm --no-headers --sort=-rss", "r");
	if (!fp) {
		p->proc_count = 0;
		return 0;
	}

	while (fgets(line, sizeof(line), fp) && lines < 200 && count < 15) {
		RamProcEntry *e;
		pid_t pid = 0;
		unsigned long rss = 0;
		char name[64] = {0};
		int existing = -1;

		lines++;
		if (sscanf(line, "%d %lu %63s", &pid, &rss, name) != 3)
			continue;
		if (name[0] == '[')
			continue;
		if (rss < min_kb)
			continue;
		/* Hide system processes from RAM popup */
		if (strcmp(name, "nixlytile") == 0 ||
				strcmp(name, "Xwayland") == 0 ||
				strncmp(name, "blueman", 7) == 0)
			continue;

		/* Check for existing entry with same name */
		for (int i = 0; i < count; i++) {
			if (strcmp(p->procs[i].name, name) == 0) {
				existing = i;
				break;
			}
		}

		if (existing >= 0) {
			e = &p->procs[existing];
			e->mem_kb += rss;
			if (rss > e->mem_kb / 2)
				e->pid = pid;
		} else {
			e = &p->procs[count];
			e->pid = pid;
			snprintf(e->name, sizeof(e->name), "%s", name);
			e->mem_kb = rss;
			e->y = e->height = 0;
			e->kill_x = e->kill_y = e->kill_w = e->kill_h = 0;
			e->has_kill = 1;
			count++;
		}
	}

	pclose(fp);
	if (count > 1)
		qsort(p->procs, (size_t)count, sizeof(p->procs[0]), ram_proc_cmp);
	p->proc_count = count;
	return count;
}

static int
ram_popup_clamped_x(Monitor *m, RamPopup *p)
{
	int popup_x;

	if (!m || !p)
		return 0;

	popup_x = m->statusbar.ram.x;
	if (p->width > 0 && m->statusbar.area.width > 0) {
		int max_x = m->statusbar.area.width - p->width;
		if (max_x < 0)
			max_x = 0;
		if (popup_x > max_x)
			popup_x = max_x;
		if (popup_x < 0)
			popup_x = 0;
	}
	return popup_x;
}

static int
ram_popup_hover_index(Monitor *m, RamPopup *p)
{
	double cx, cy;
	int lx, ly;
	int popup_x, rel_x, rel_y;

	if (!m || !p || !p->visible || !cursor)
		return -1;

	popup_x = ram_popup_clamped_x(m, p);
	cx = cursor->x;
	cy = cursor->y;
	lx = (int)round(cx) - m->m.x;
	ly = (int)round(cy) - m->m.y;
	rel_x = lx - popup_x;
	rel_y = ly - m->statusbar.area.height;

	for (int i = 0; i < p->proc_count; i++) {
		RamProcEntry *e = &p->procs[i];
		if (!e->has_kill || e->kill_w <= 0 || e->kill_h <= 0)
			continue;
		if (rel_x >= e->kill_x && rel_x < e->kill_x + e->kill_w &&
				rel_y >= e->kill_y && rel_y < e->kill_y + e->kill_h)
			return i;
	}
	return -1;
}

static void
format_mem_size(unsigned long kb, char *buf, size_t bufsz)
{
	if (kb >= 1024 * 1024)
		snprintf(buf, bufsz, "%.1fG", kb / (1024.0 * 1024.0));
	else if (kb >= 1024)
		snprintf(buf, bufsz, "%.0fM", kb / 1024.0);
	else
		snprintf(buf, bufsz, "%luK", kb);
}

static void
renderrampopup(Monitor *m)
{
	RamPopup *p;
	int padding, line_spacing;
	int row_height;
	int button_gap;
	int kill_text_w;
	int kill_w;
	int kill_h;
	uint64_t now;
	int hover_idx;
	int popup_x;
	int need_fetch_now;
	int max_proc_text_w = 0;
	int any_has_kill = 0;
	int content_w = 0, content_h = 0;
	struct wlr_scene_node *node, *tmp;

	if (!m || !m->statusbar.ram_popup.tree)
		return;

	p = &m->statusbar.ram_popup;
	hover_idx = p->hover_idx;
	if (hover_idx < -1 || hover_idx >= (int)LENGTH(p->procs))
		hover_idx = -1;
	padding = statusbar_module_padding;
	line_spacing = 2;
	row_height = statusfont.height > 0 ? statusfont.height : 16;
	button_gap = statusbar_module_spacing > 0 ? statusbar_module_spacing / 2 : 6;
	kill_text_w = status_text_width("Kill");
	kill_w = kill_text_w + 12;
	kill_h = row_height;
	now = monotonic_msec();
	need_fetch_now = 0;
	popup_x = m->statusbar.ram.x;

	/* Clear previous buffers but keep bg */
	wl_list_for_each_safe(node, tmp, &p->tree->children, link) {
		if (p->bg && node == &p->bg->node)
			continue;
		wlr_scene_node_destroy(node);
	}

	if (!statusfont.font) {
		p->width = p->height = 0;
		if (p->tree)
			wlr_scene_node_set_enabled(&p->tree->node, 0);
		p->visible = 0;
		return;
	}

	/* Only fetch data after suppress delay has passed */
	if (p->suppress_refresh_until_ms == 0 || now >= p->suppress_refresh_until_ms) {
		if (p->last_fetch_ms == 0 ||
				now < p->last_fetch_ms ||
				now - p->last_fetch_ms >= ram_popup_refresh_interval_ms)
			p->refresh_data = 1;

		if (p->refresh_data) {
			if (p->last_fetch_ms == 0 || now - p->last_fetch_ms >= 200)
				need_fetch_now = 1;
			if (need_fetch_now) {
				read_top_ram_processes(p);
				p->last_fetch_ms = now;
			}
			if (p->suppress_refresh_until_ms > 0)
				p->suppress_refresh_until_ms = 0;
			p->refresh_data = 0;
		}
	}

	if (p->proc_count == 0) {
		/* Don't hide if we're waiting for data to load (suppress period) */
		if (p->suppress_refresh_until_ms > 0 && now < p->suppress_refresh_until_ms) {
			/* Show loading placeholder */
			const char *loading = "Loading...";
			int text_w = status_text_width(loading);
			struct wlr_scene_tree *row;
			StatusModule mod = {0};

			p->width = 2 * padding + text_w;
			p->height = 2 * padding + row_height;

			if (!p->bg && !(p->bg = wlr_scene_tree_create(p->tree)))
				return;
			wlr_scene_node_set_enabled(&p->bg->node, 1);
			wlr_scene_node_set_position(&p->bg->node, 0, 0);
			wl_list_for_each_safe(node, tmp, &p->bg->children, link)
				wlr_scene_node_destroy(node);
			drawrect(p->bg, 0, 0, p->width, p->height, statusbar_popup_bg);

			row = wlr_scene_tree_create(p->tree);
			if (row) {
				wlr_scene_node_set_position(&row->node, padding, padding);
				mod.tree = row;
				tray_render_label(&mod, loading, 0, row_height, statusbar_fg);
			}
			p->last_render_ms = now;
			return;
		}
		p->width = p->height = 0;
		if (p->tree)
			wlr_scene_node_set_enabled(&p->tree->node, 0);
		p->visible = 0;
		return;
	}

	/* First pass: find max text width for vertical kill button alignment */
	for (int i = 0; i < p->proc_count; i++) {
		RamProcEntry *e = &p->procs[i];
		int text_w;
		char proc_line[128];
		char mem_str[16];

		format_mem_size(e->mem_kb, mem_str, sizeof(mem_str));
		snprintf(proc_line, sizeof(proc_line), "%s %s", e->name, mem_str);
		text_w = status_text_width(proc_line);
		max_proc_text_w = MAX(max_proc_text_w, text_w);
		if (e->has_kill)
			any_has_kill = 1;
	}

	/* Calculate dimensions */
	content_w = max_proc_text_w;
	if (any_has_kill)
		content_w += button_gap + kill_w;
	content_h = p->proc_count * row_height + (p->proc_count - 1) * line_spacing;

	p->width = 2 * padding + content_w;
	p->height = content_h + 2 * padding;

	if (p->width > 0 && m->statusbar.area.width > 0) {
		int max_x = m->statusbar.area.width - p->width;
		if (max_x < 0)
			max_x = 0;
		if (popup_x > max_x)
			popup_x = max_x;
		if (popup_x < 0)
			popup_x = 0;
	}

	if (!p->bg && !(p->bg = wlr_scene_tree_create(p->tree)))
		return;
	wlr_scene_node_set_enabled(&p->bg->node, 1);
	wlr_scene_node_set_position(&p->bg->node, 0, 0);
	wl_list_for_each_safe(node, tmp, &p->bg->children, link)
		wlr_scene_node_destroy(node);
	drawrect(p->bg, 0, 0, p->width, p->height, statusbar_popup_bg);

	/* Render process rows */
	for (int i = 0; i < p->proc_count; i++) {
		RamProcEntry *e = &p->procs[i];
		int row_y = padding + i * (row_height + line_spacing);
		char proc_line[128];
		char mem_str[16];
		struct wlr_scene_tree *row;
		StatusModule mod = {0};

		format_mem_size(e->mem_kb, mem_str, sizeof(mem_str));
		snprintf(proc_line, sizeof(proc_line), "%s %s", e->name, mem_str);
		row = wlr_scene_tree_create(p->tree);
		if (row) {
			wlr_scene_node_set_position(&row->node, padding, row_y);
			mod.tree = row;
			tray_render_label(&mod, proc_line, 0, row_height, statusbar_fg);
		}

		e->y = row_y;
		e->height = row_height;

		if (e->has_kill && kill_w > 0 && kill_h > 0) {
			int btn_x = padding + max_proc_text_w + button_gap;
			int btn_y = row_y + (row_height - kill_h) / 2;
			struct wlr_scene_tree *btn;
			StatusModule btn_mod = {0};
			const float *btn_color = statusbar_volume_muted_fg;
			int is_hover = (hover_idx == i);

			if (is_hover)
				btn_color = statusbar_tag_active_bg;

			e->kill_x = btn_x;
			e->kill_y = btn_y;
			e->kill_w = kill_w;
			e->kill_h = kill_h;
			drawrect(p->tree, btn_x, btn_y, kill_w, kill_h, btn_color);

			btn = wlr_scene_tree_create(p->tree);
			if (btn) {
				int text_x = (kill_w - kill_text_w) / 2;
				if (text_x < 2)
					text_x = 2;
				wlr_scene_node_set_position(&btn->node, btn_x, btn_y);
				btn_mod.tree = btn;
				tray_render_label(&btn_mod, "Kill", text_x, kill_h, statusbar_fg);
			}
		} else {
			e->kill_x = e->kill_y = e->kill_w = e->kill_h = 0;
			e->has_kill = 0;
		}
	}

	if (p->width <= 0 || p->height <= 0)
		wlr_scene_node_set_enabled(&p->tree->node, 0);
	p->last_render_ms = now;
}

static int
ram_popup_handle_click(Monitor *m, int lx, int ly, uint32_t button)
{
	RamPopup *p;
	int popup_x, rel_x, rel_y;

	if (!m || !m->statusbar.ram_popup.visible || button != BTN_LEFT)
		return 0;

	p = &m->statusbar.ram_popup;
	popup_x = ram_popup_clamped_x(m, p);

	if (p->width > 0 && m->statusbar.area.width > 0) {
		int max_x = m->statusbar.area.width - p->width;
		if (max_x < 0)
			max_x = 0;
		if (popup_x > max_x)
			popup_x = max_x;
		if (popup_x < 0)
			popup_x = 0;
	}

	rel_x = lx - popup_x;
	rel_y = ly - m->statusbar.area.height;
	if (rel_x < 0 || rel_y < 0 || rel_x >= p->width || rel_y >= p->height)
		return 0;

	for (int i = 0; i < p->proc_count; i++) {
		RamProcEntry *e = &p->procs[i];
		if (!e->has_kill || e->kill_w <= 0 || e->kill_h <= 0)
			continue;
		if (rel_x >= e->kill_x && rel_x < e->kill_x + e->kill_w &&
				rel_y >= e->kill_y && rel_y < e->kill_y + e->kill_h) {
			if (cpu_proc_is_critical(e->pid, e->name))
				return 1;
			if (kill_processes_with_name(e->name) == 0) {
				if (kill(e->pid, SIGKILL) != 0)
					wlr_log(WLR_ERROR, "ram popup: kill %d failed: %s",
							e->pid, strerror(errno));
			}
			p->last_fetch_ms = monotonic_msec();
			p->suppress_refresh_until_ms = p->last_fetch_ms + 2000;
			p->refresh_data = 0;
			schedule_ram_popup_refresh(2000);
			refreshstatusram();
			return 1;
		}
	}

	return 0;
}

static int
ram_popup_refresh_timeout(void *data)
{
	Monitor *m;
	int any_visible = 0;

	(void)data;

	wl_list_for_each(m, &mons, link) {
		RamPopup *p = &m->statusbar.ram_popup;
		if (!p || !p->tree || !p->visible)
			continue;
		p->suppress_refresh_until_ms = 0;
		p->refresh_data = 1;
		renderrampopup(m);
		any_visible = 1;
	}

	if (any_visible)
		wl_event_source_timer_update(ram_popup_refresh_timer, ram_popup_refresh_interval_ms);

	return 0;
}

static void
schedule_ram_popup_refresh(uint32_t ms)
{
	if (!event_loop)
		return;
	if (!ram_popup_refresh_timer)
		ram_popup_refresh_timer = wl_event_loop_add_timer(event_loop,
				ram_popup_refresh_timeout, NULL);
	if (ram_popup_refresh_timer)
		wl_event_source_timer_update(ram_popup_refresh_timer, ms);
}

/* Forward declaration for readulong (defined later) */
static int readulong(const char *path, unsigned long long *out);

/* Battery Popup Functions */
static void
read_battery_info(BatteryPopup *p)
{
	char path[PATH_MAX];
	char buf[64];
	FILE *fp;
	unsigned long long val;

	if (!p || !battery_available || !battery_device_dir[0])
		return;

	/* Read charging status */
	snprintf(path, sizeof(path), "%s/status", battery_device_dir);
	fp = fopen(path, "r");
	if (fp) {
		if (fgets(buf, sizeof(buf), fp)) {
			char *nl = strchr(buf, '\n');
			if (nl) *nl = '\0';
			p->charging = (strcmp(buf, "Charging") == 0 || strcmp(buf, "Full") == 0);
		}
		fclose(fp);
	}

	/* Read capacity percentage */
	p->percent = battery_percent();

	/* Read voltage (microvolts -> volts) */
	snprintf(path, sizeof(path), "%s/voltage_now", battery_device_dir);
	if (readulong(path, &val) == 0) {
		p->voltage_v = val / 1000000.0;
	} else {
		p->voltage_v = -1.0;
	}

	/* Read power draw (microwatts -> watts) */
	snprintf(path, sizeof(path), "%s/power_now", battery_device_dir);
	if (readulong(path, &val) == 0) {
		p->power_w = val / 1000000.0;
	} else {
		/* Try current_now * voltage_now if power_now not available */
		snprintf(path, sizeof(path), "%s/current_now", battery_device_dir);
		if (readulong(path, &val) == 0 && p->voltage_v > 0) {
			double current_a = val / 1000000.0;
			p->power_w = current_a * p->voltage_v;
		} else {
			p->power_w = -1.0;
		}
	}

	/* Calculate time remaining */
	p->time_remaining_h = -1.0;
	if (!p->charging && p->power_w > 0.1 && p->percent >= 0) {
		/* Read energy_now (microwatt-hours) */
		snprintf(path, sizeof(path), "%s/energy_now", battery_device_dir);
		if (readulong(path, &val) == 0) {
			double energy_wh = val / 1000000.0;
			p->time_remaining_h = energy_wh / p->power_w;
		} else {
			/* Try charge_now * voltage */
			snprintf(path, sizeof(path), "%s/charge_now", battery_device_dir);
			if (readulong(path, &val) == 0 && p->voltage_v > 0) {
				double charge_ah = val / 1000000.0;
				double energy_wh = charge_ah * p->voltage_v;
				p->time_remaining_h = energy_wh / p->power_w;
			}
		}
	}
}

static int
battery_popup_clamped_x(Monitor *m, BatteryPopup *p)
{
	int popup_x;

	if (!m || !p)
		return 0;

	popup_x = m->statusbar.battery.x;
	if (p->width > 0 && m->statusbar.area.width > 0) {
		int max_x = m->statusbar.area.width - p->width;
		if (max_x < 0)
			max_x = 0;
		if (popup_x > max_x)
			popup_x = max_x;
		if (popup_x < 0)
			popup_x = 0;
	}
	return popup_x;
}

static void
renderbatterypopup(Monitor *m)
{
	BatteryPopup *p;
	int padding, line_spacing;
	int row_height;
	int max_width = 0;
	int line_count = 0;
	char lines[5][128];
	int popup_x;
	uint64_t now;
	struct wlr_scene_node *node, *tmp;

	if (!m || !m->statusbar.battery_popup.tree)
		return;

	p = &m->statusbar.battery_popup;
	padding = statusbar_module_padding;
	line_spacing = 2;
	row_height = statusfont.height > 0 ? statusfont.height : 16;
	now = monotonic_msec();
	popup_x = m->statusbar.battery.x;

	/* Clear previous content */
	wl_list_for_each_safe(node, tmp, &p->tree->children, link) {
		if (p->bg && node == &p->bg->node)
			continue;
		wlr_scene_node_destroy(node);
	}

	if (!statusfont.font || !battery_available) {
		p->width = p->height = 0;
		if (p->tree)
			wlr_scene_node_set_enabled(&p->tree->node, 0);
		p->visible = 0;
		return;
	}

	/* Fetch data only when refresh_data flag is set */
	if (p->refresh_data) {
		read_battery_info(p);
		p->last_fetch_ms = now;
		p->refresh_data = 0;
	}

	/* Build display lines */
	if (p->charging) {
		snprintf(lines[line_count++], sizeof(lines[0]), "Charging:");
	} else {
		snprintf(lines[line_count++], sizeof(lines[0]), "On Battery:");
	}

	if (p->percent >= 0) {
		snprintf(lines[line_count++], sizeof(lines[0]), "Level: %.0f%%", p->percent);
	}

	if (p->voltage_v > 0) {
		snprintf(lines[line_count++], sizeof(lines[0]), "Voltage: %.2f V", p->voltage_v);
	}

	if (p->power_w > 0) {
		snprintf(lines[line_count++], sizeof(lines[0]), "Power: %.1f W", p->power_w);
	}

	if (!p->charging && p->time_remaining_h > 0) {
		int hours = (int)p->time_remaining_h;
		int mins = (int)((p->time_remaining_h - hours) * 60);
		snprintf(lines[line_count++], sizeof(lines[0]), "Remaining: %dh %dm", hours, mins);
	}

	if (line_count == 0) {
		p->width = p->height = 0;
		if (p->tree)
			wlr_scene_node_set_enabled(&p->tree->node, 0);
		p->visible = 0;
		return;
	}

	/* Calculate dimensions */
	for (int i = 0; i < line_count; i++) {
		int w = status_text_width(lines[i]);
		max_width = MAX(max_width, w);
	}

	p->width = 2 * padding + max_width;
	p->height = 2 * padding + line_count * row_height + (line_count - 1) * line_spacing;

	/* Clamp position */
	if (p->width > 0 && m->statusbar.area.width > 0) {
		int max_x = m->statusbar.area.width - p->width;
		if (max_x < 0)
			max_x = 0;
		if (popup_x > max_x)
			popup_x = max_x;
		if (popup_x < 0)
			popup_x = 0;
	}

	/* Draw background */
	if (!p->bg && !(p->bg = wlr_scene_tree_create(p->tree)))
		return;
	wlr_scene_node_set_enabled(&p->bg->node, 1);
	wlr_scene_node_set_position(&p->bg->node, 0, 0);
	wl_list_for_each_safe(node, tmp, &p->bg->children, link)
		wlr_scene_node_destroy(node);
	drawrect(p->bg, 0, 0, p->width, p->height, statusbar_popup_bg);

	/* Render text lines */
	for (int i = 0; i < line_count; i++) {
		int row_y = padding + i * (row_height + line_spacing);
		struct wlr_scene_tree *row;
		StatusModule mod = {0};

		row = wlr_scene_tree_create(p->tree);
		if (row) {
			wlr_scene_node_set_position(&row->node, padding, row_y);
			mod.tree = row;
			tray_render_label(&mod, lines[i], 0, row_height, statusbar_fg);
		}
	}

	p->last_render_ms = now;
}

static void
updatebatteryhover(Monitor *m, double cx, double cy)
{
	int lx, ly;
	int inside = 0;
	int popup_hover = 0;
	int was_visible;
	BatteryPopup *p;
	int popup_x;
	uint64_t now = monotonic_msec();
	int need_refresh = 0;
	int stale_refresh = 0;

	if (!m || !m->showbar || !m->statusbar.battery.tree || !m->statusbar.battery_popup.tree || !battery_available) {
		if (m && m->statusbar.battery_popup.tree) {
			wlr_scene_node_set_enabled(&m->statusbar.battery_popup.tree->node, 0);
			m->statusbar.battery_popup.visible = 0;
		}
		return;
	}

	p = &m->statusbar.battery_popup;
	lx = (int)floor(cx) - m->statusbar.area.x;
	ly = (int)floor(cy) - m->statusbar.area.y;

	popup_x = battery_popup_clamped_x(m, p);

	/* Check if hovering over popup */
	if (p->visible && p->width > 0 && p->height > 0 &&
			lx >= popup_x &&
			lx < popup_x + p->width &&
			ly >= m->statusbar.area.height &&
			ly < m->statusbar.area.height + p->height) {
		popup_hover = 1;
	}

	/* Check if hovering over battery module */
	if (lx >= m->statusbar.battery.x &&
			lx < m->statusbar.battery.x + m->statusbar.battery.width &&
			ly >= 0 && ly < m->statusbar.area.height &&
			m->statusbar.battery.width > 0) {
		inside = 1;
	} else if (popup_hover) {
		inside = 1;
	}

	was_visible = p->visible;

	if (inside) {
		/* Track when hover started for delay */
		if (p->hover_start_ms == 0)
			p->hover_start_ms = now;

		/* Wait 300ms before showing popup */
		if (!was_visible && (now - p->hover_start_ms) < 300) {
			/* Schedule timer to check again after remaining delay */
			uint64_t remaining = 300 - (now - p->hover_start_ms);
			schedule_popup_delay(remaining + 1);
			return;
		}

		if (!was_visible) {
			/* Short delay to avoid flicker on quick mouse movements */
			p->suppress_refresh_until_ms = now + 100;
			p->refresh_data = 1; /* Trigger immediate fetch when delay passes */
		}
		p->visible = 1;
		wlr_scene_node_set_enabled(&p->tree->node, 1);
		wlr_scene_node_set_position(&p->tree->node,
				popup_x, m->statusbar.area.height);

		/* Check if refresh is needed (every 500ms after delay) */
		stale_refresh = (p->last_fetch_ms == 0 ||
				now < p->last_fetch_ms ||
				(now - p->last_fetch_ms) >= 500);
		need_refresh = stale_refresh &&
				(p->suppress_refresh_until_ms == 0 ||
				 now >= p->suppress_refresh_until_ms);

		if (need_refresh)
			p->refresh_data = 1;

		if (!was_visible || need_refresh ||
				(p->last_render_ms == 0 || (now - p->last_render_ms) >= 100)) {
			renderbatterypopup(m);
			p->last_render_ms = now;
		}
	} else if (p->visible || p->hover_start_ms != 0) {
		p->visible = 0;
		p->suppress_refresh_until_ms = 0;
		p->hover_start_ms = 0;
		wlr_scene_node_set_enabled(&p->tree->node, 0);
	}
}

static void
rendernetpopup(Monitor *m)
{
	NetPopup *p;
	int padding, line_spacing;
	int line_count = 4;
	int max_width = 0;
	int total_height;
	char lines[4][128];
	struct wlr_scene_node *node, *tmp;

	if (!m || !m->statusbar.net_popup.tree)
		return;

	p = &m->statusbar.net_popup;
	padding = statusbar_module_padding;
	line_spacing = 2;

	if (net_is_wireless) {
		int sig = (net_last_wifi_quality >= 0.0) ? (int)lround(net_last_wifi_quality) : -1;
		if (sig >= 0)
			snprintf(lines[0], sizeof(lines[0]), "Wifi: %s | %d%%", net_ssid, sig);
		else
			snprintf(lines[0], sizeof(lines[0]), "Wifi: %s | --", net_ssid);
	} else {
		if (net_link_speed_mbps >= 1000)
			snprintf(lines[0], sizeof(lines[0]), "Ethernet | %.1f Gbps", net_link_speed_mbps / 1000.0);
		else if (net_link_speed_mbps > 0)
			snprintf(lines[0], sizeof(lines[0]), "Ethernet | %d Mbps", net_link_speed_mbps);
		else
			snprintf(lines[0], sizeof(lines[0]), "Ethernet | --");
	}
	snprintf(lines[1], sizeof(lines[1]), "Local: %s", net_local_ip);
	snprintf(lines[2], sizeof(lines[2]), "Public: %s", net_public_ip);
	snprintf(lines[3], sizeof(lines[3]), "Up: %s  Down: %s", net_up_text, net_down_text);

	/* Clear previous buffers but keep bg */
	wl_list_for_each_safe(node, tmp, &p->tree->children, link) {
		if (p->bg && node == &p->bg->node)
			continue;
		wlr_scene_node_destroy(node);
	}

	if (!statusfont.font || !net_available) {
		p->width = p->height = 0;
		if (p->tree)
			wlr_scene_node_set_enabled(&p->tree->node, 0);
		p->visible = 0;
		return;
	}

	/* First pass: compute max width */
	for (int i = 0; i < line_count; i++) {
		const struct fcft_glyph *glyph;
		uint32_t prev_cp = 0;
		int pen_x = 0;
		int min_x = INT_MAX, max_x_local = INT_MIN;
		const char *text = lines[i];

		for (size_t j = 0; text[j]; j++) {
			long kern_x = 0, kern_y = 0;
			uint32_t cp = (unsigned char)text[j];
			if (prev_cp)
				fcft_kerning(statusfont.font, prev_cp, cp, &kern_x, &kern_y);
			pen_x += (int)kern_x;

			glyph = fcft_rasterize_char_utf32(statusfont.font, cp, statusbar_font_subpixel);
			if (!glyph || !glyph->pix) {
				prev_cp = cp;
				continue;
			}

			min_x = MIN(min_x, pen_x + glyph->x);
			max_x_local = MAX(max_x_local, pen_x + glyph->x + glyph->width);
			pen_x += glyph->advance.x;
			if (text[j + 1])
				pen_x += statusbar_font_spacing;
			prev_cp = cp;
		}

		if (min_x == INT_MAX || max_x_local == INT_MIN)
			continue;
		max_width = MAX(max_width, max_x_local - min_x);
	}

	p->width = max_width + 2 * padding;
	p->height = line_count * statusfont.height + (line_count - 1) * line_spacing + 2 * padding;
	total_height = p->height;

	if (!p->bg && !(p->bg = wlr_scene_tree_create(p->tree)))
		return;
	wlr_scene_node_set_enabled(&p->bg->node, 1);
	wlr_scene_node_set_position(&p->bg->node, 0, 0);
	wl_list_for_each_safe(node, tmp, &p->bg->children, link)
		wlr_scene_node_destroy(node);
	drawrect(p->bg, 0, 0, p->width, total_height, statusbar_popup_bg);

	for (int i = 0; i < line_count; i++) {
		const char *text = lines[i];
		int min_x = INT_MAX, max_x_local = INT_MIN;
		int min_y = INT_MAX, max_y = INT_MIN;
		int pen_x = 0;
		int width = 0;
		int origin_x = 0;
		int origin_y = 0;
		uint32_t prev_cp = 0;

		tll(struct GlyphRun) glyphs = tll_init();
		for (size_t j = 0; text[j]; j++) {
			long kern_x = 0, kern_y = 0;
			uint32_t cp = (unsigned char)text[j];
			struct GlyphRun run;
			const struct fcft_glyph *glyph;

			if (prev_cp)
				fcft_kerning(statusfont.font, prev_cp, cp, &kern_x, &kern_y);
			pen_x += (int)kern_x;

			glyph = fcft_rasterize_char_utf32(statusfont.font,
					cp, statusbar_font_subpixel);
			if (!glyph || !glyph->pix) {
				prev_cp = cp;
				continue;
			}

			run.glyph = glyph;
			run.pen_x = pen_x;
			run.codepoint = cp;
			tll_push_back(glyphs, run);

			min_x = MIN(min_x, pen_x + glyph->x);
			min_y = MIN(min_y, -glyph->y);
			max_x_local = MAX(max_x_local, pen_x + glyph->x + glyph->width);
			max_y = MAX(max_y, -glyph->y + glyph->height);

			pen_x += glyph->advance.x;
			if (text[j + 1])
				pen_x += statusbar_font_spacing;
			prev_cp = cp;
		}

		if (tll_length(glyphs) == 0) {
			tll_free(glyphs);
			continue;
		}

		width = max_x_local - min_x;
		origin_x = padding + (max_width - width) / 2;
		origin_y = padding + i * (statusfont.height + line_spacing) + statusfont.ascent;

		tll_foreach(glyphs, it) {
			struct wlr_buffer *buffer;
			struct wlr_scene_buffer *scene_buf;
			const struct fcft_glyph *glyph = it->item.glyph;

			buffer = statusbar_buffer_from_glyph(glyph);
			if (!buffer)
				continue;

			scene_buf = wlr_scene_buffer_create(p->tree, NULL);
			if (scene_buf) {
				wlr_scene_buffer_set_buffer(scene_buf, buffer);
				wlr_scene_node_set_position(&scene_buf->node,
						origin_x + it->item.pen_x + glyph->x,
						origin_y - glyph->y);
			}
			wlr_buffer_drop(buffer);
		}

		tll_free(glyphs);
	}

	if (p->width <= 0 || p->height <= 0)
		wlr_scene_node_set_enabled(&p->tree->node, 0);
	else {
		/* keep anchor so hover detection survives brief relayouts */
		p->anchor_x = m->statusbar.sysicons.x;
		p->anchor_y = m->statusbar.area.height;
		p->anchor_w = m->statusbar.sysicons.width;
	}
}

static void
modal_hide(Monitor *m)
{
	if (!m || !m->modal.tree)
		return;
	modal_file_search_stop(m);
	modal_git_search_stop(m);
	m->modal.visible = 0;
	wlr_scene_node_set_enabled(&m->modal.tree->node, 0);
}

static void
modal_hide_all(void)
{
	Monitor *m;

	wl_list_for_each(m, &mons, link)
		modal_hide(m);
}

static void
modal_show(const Arg *arg)
{
	Monitor *m = selmon ? selmon : xytomon(cursor->x, cursor->y);
	Monitor *vm = modal_visible_monitor();
	ModalOverlay *mo;
	int mw, mh, w, h, x, y;
	int min_w = 300, min_h = 200;
	int max_w = 1400, max_h = 800;
	int cycling = 0;

	(void)arg;

	if (!m || !m->modal.tree)
		return;

	if (vm && vm != m)
		modal_hide_all();
	else if (vm == m)
		cycling = 1;

	mw = m->w.width > 0 ? m->w.width : m->m.width;
	mh = m->w.height > 0 ? m->w.height : m->m.height;
	w = mw > 0 ? (int)(mw * 0.8) : 1100;
	h = mh > 0 ? (int)(mh * 0.6) : 500;
	if (w < min_w)
		w = min_w;
	if (h < min_h)
		h = min_h;
	if (w > max_w)
		w = max_w;
	if (h > max_h)
		h = max_h;

	x = m->m.x + (m->m.width - w) / 2;
	y = m->m.y + (m->m.height - h) / 2;
	if (x < m->m.x)
		x = m->m.x;
	if (y < m->m.y)
		y = m->m.y;

	mo = &m->modal;
	mo->width = w;
	mo->height = h;
	mo->x = x;
	mo->y = y;

	if (!mo->bg)
		mo->bg = wlr_scene_tree_create(mo->tree);
	if (mo->bg) {
		struct wlr_scene_node *node, *tmp;
		wl_list_for_each_safe(node, tmp, &mo->bg->children, link)
			wlr_scene_node_destroy(node);
		drawrect(mo->bg, 0, 0, w, h, statusbar_popup_bg);
	}

	wlr_scene_node_set_position(&mo->tree->node, x, y);
	wlr_scene_node_set_enabled(&mo->tree->node, 1);
	if (cycling)
		mo->active_idx = (mo->active_idx + 1) % 3;
	else if (mo->active_idx < 0 || mo->active_idx > 2)
		mo->active_idx = 0;
	else
		mo->active_idx = 0;
	modal_file_search_stop(m);
	modal_file_search_clear_results(m);
	modal_git_search_stop(m);
	modal_git_search_clear_results(m);
	mo->file_search_last[0] = '\0';
	mo->git_search_last[0] = '\0';
	mo->git_search_done = 0;
	for (int i = 0; i < 3; i++) {
		mo->search[i][0] = '\0';
		mo->search_len[i] = 0;
		mo->search_rendered[i][0] = '\0';
		mo->selected[i] = -1;
		mo->scroll[i] = 0;
	}
	mo->search_field_tree = NULL; /* will be recreated on render */
	mo->render_pending = 0;
	if (mo->render_timer)
		wl_event_source_timer_update(mo->render_timer, 0);
	mo->file_search_fallback = 0;
	mo->visible = 1;
	modal_update_results(m);
	modal_render(m);
}

static void
modal_show_files(const Arg *arg)
{
	Monitor *m = selmon ? selmon : xytomon(cursor->x, cursor->y);
	ModalOverlay *mo;
	int mw, mh, w, h, x, y;
	int min_w = 300, min_h = 200;
	int max_w = 1400, max_h = 800;

	(void)arg;

	if (!m || !m->modal.tree)
		return;

	modal_hide_all();

	mw = m->w.width > 0 ? m->w.width : m->m.width;
	mh = m->w.height > 0 ? m->w.height : m->m.height;
	w = mw > 0 ? (int)(mw * 0.8) : 1100;
	h = mh > 0 ? (int)(mh * 0.6) : 500;
	if (w < min_w) w = min_w;
	if (h < min_h) h = min_h;
	if (w > max_w) w = max_w;
	if (h > max_h) h = max_h;

	x = m->m.x + (m->m.width - w) / 2;
	y = m->m.y + (m->m.height - h) / 2;
	if (x < m->m.x) x = m->m.x;
	if (y < m->m.y) y = m->m.y;

	mo = &m->modal;
	mo->width = w;
	mo->height = h;
	mo->x = x;
	mo->y = y;

	if (!mo->bg)
		mo->bg = wlr_scene_tree_create(mo->tree);
	if (mo->bg) {
		struct wlr_scene_node *node, *tmp;
		wl_list_for_each_safe(node, tmp, &mo->bg->children, link)
			wlr_scene_node_destroy(node);
		drawrect(mo->bg, 0, 0, w, h, statusbar_popup_bg);
	}

	wlr_scene_node_set_position(&mo->tree->node, x, y);
	wlr_scene_node_set_enabled(&mo->tree->node, 1);
	mo->active_idx = 1; /* File search tab */
	modal_file_search_stop(m);
	modal_file_search_clear_results(m);
	modal_git_search_stop(m);
	modal_git_search_clear_results(m);
	mo->file_search_last[0] = '\0';
	mo->git_search_last[0] = '\0';
	mo->git_search_done = 0;
	for (int i = 0; i < 3; i++) {
		mo->search[i][0] = '\0';
		mo->search_len[i] = 0;
		mo->search_rendered[i][0] = '\0';
		mo->selected[i] = -1;
		mo->scroll[i] = 0;
	}
	mo->search_field_tree = NULL;
	mo->render_pending = 0;
	if (mo->render_timer)
		wl_event_source_timer_update(mo->render_timer, 0);
	mo->file_search_fallback = 0;
	mo->visible = 1;
	modal_update_results(m);
	modal_render(m);
}

static void
modal_show_git(const Arg *arg)
{
	Monitor *m = selmon ? selmon : xytomon(cursor->x, cursor->y);
	ModalOverlay *mo;
	int mw, mh, w, h, x, y;
	int min_w = 300, min_h = 200;
	int max_w = 1400, max_h = 800;

	(void)arg;

	if (!m || !m->modal.tree)
		return;

	modal_hide_all();

	mw = m->w.width > 0 ? m->w.width : m->m.width;
	mh = m->w.height > 0 ? m->w.height : m->m.height;
	w = mw > 0 ? (int)(mw * 0.8) : 1100;
	h = mh > 0 ? (int)(mh * 0.6) : 500;
	if (w < min_w) w = min_w;
	if (h < min_h) h = min_h;
	if (w > max_w) w = max_w;
	if (h > max_h) h = max_h;

	x = m->m.x + (m->m.width - w) / 2;
	y = m->m.y + (m->m.height - h) / 2;
	if (x < m->m.x) x = m->m.x;
	if (y < m->m.y) y = m->m.y;

	mo = &m->modal;
	mo->width = w;
	mo->height = h;
	mo->x = x;
	mo->y = y;

	if (!mo->bg)
		mo->bg = wlr_scene_tree_create(mo->tree);
	if (mo->bg) {
		struct wlr_scene_node *node, *tmp;
		wl_list_for_each_safe(node, tmp, &mo->bg->children, link)
			wlr_scene_node_destroy(node);
		drawrect(mo->bg, 0, 0, w, h, statusbar_popup_bg);
	}

	wlr_scene_node_set_position(&mo->tree->node, x, y);
	wlr_scene_node_set_enabled(&mo->tree->node, 1);
	mo->active_idx = 2; /* Git projects tab */
	modal_file_search_stop(m);
	modal_file_search_clear_results(m);
	modal_git_search_stop(m);
	modal_git_search_clear_results(m);
	mo->file_search_last[0] = '\0';
	mo->git_search_last[0] = '\0';
	mo->git_search_done = 0;
	for (int i = 0; i < 3; i++) {
		mo->search[i][0] = '\0';
		mo->search_len[i] = 0;
		mo->search_rendered[i][0] = '\0';
		mo->selected[i] = -1;
		mo->scroll[i] = 0;
	}
	mo->search_field_tree = NULL;
	mo->render_pending = 0;
	if (mo->render_timer)
		wl_event_source_timer_update(mo->render_timer, 0);
	mo->file_search_fallback = 0;
	mo->visible = 1;
	modal_git_search_start(m); /* Start git search immediately */
	modal_render(m);
}

static void
renderworkspaces(Monitor *m, StatusModule *module, int bar_height)
{
	uint32_t mask = 0;
	Client *c;
	int padding, inner, spacing, outer_pad;
	int box_h, box_y, total_w = 0;
	int x, count = 0;
	struct wlr_scene_buffer *scene_buf;
	struct wlr_buffer *buffer;

	if (!m || !module || !module->tree)
		return;
	if (!statusfont.font || bar_height <= 0) {
		module->width = 0;
		return;
	}

	padding = statusbar_module_padding;
	inner = statusbar_workspace_padding;
	spacing = statusbar_workspace_spacing;
	/* give the module a little extra padding so bg extends past boxes */
	outer_pad = padding + spacing + 6;
	module->box_count = 0;
	module->tagmask = 0;
	if (module->hover_tag < -1 || module->hover_tag >= TAGCOUNT)
		module->hover_tag = -1;

	wl_list_for_each(c, &clients, link) {
		if (c->mon != m)
			continue;
		mask |= c->tags;
	}
	mask |= m->tagset[m->seltags];
	mask |= 1u; /* Always show workspace 1 */
	mask &= TAGMASK;

	clearstatusmodule(module);

	box_h = MAX(1, MIN(bar_height - 2, statusfont.height + inner * 2 + 2));
	box_y = (bar_height - box_h) / 2;
	x = outer_pad;

	for (int i = 0; i < TAGCOUNT; i++) {
		const struct fcft_glyph *glyph;
		int min_x, max_x, min_y, max_y;
		int text_w, text_h, box_w;
		int origin_x, origin_y;
		const float *bgcol;
		int active;

		if (!(mask & (1u << i)))
			continue;

		if (count > 0) {
			x += spacing;
			total_w += spacing;
		}

		glyph = fcft_rasterize_char_utf32(statusfont.font,
				(uint32_t)('1' + i), statusbar_font_subpixel);
		if (!glyph || !glyph->pix) {
			continue;
		}

		min_x = glyph->x;
		max_x = glyph->x + glyph->width;
		min_y = -glyph->y;
		max_y = -glyph->y + glyph->height;
		text_w = max_x - min_x;
		text_h = max_y - min_y;
		box_w = text_w + inner * 2;
		origin_x = x + (box_w - text_w) / 2 - min_x;
		origin_y = box_y + (box_h - text_h) / 2 - min_y;

		active = (m->tagset[m->seltags] & (1u << i)) != 0;
		bgcol = statusbar_tag_bg;
		if (active)
			bgcol = statusbar_tag_active_bg;

		drawrect(module->tree, x, box_y, box_w, box_h, bgcol);

		if (!active && module->hover_alpha[i] > 0.0f) {
			drawhoverrect(module->tree, x, box_y, box_w, box_h,
					statusbar_tag_hover_bg, module->hover_alpha[i]);
		}

		buffer = statusbar_buffer_from_glyph(glyph);
		if (buffer) {
			scene_buf = wlr_scene_buffer_create(module->tree, NULL);
			if (scene_buf) {
				wlr_scene_buffer_set_buffer(scene_buf, buffer);
				wlr_scene_node_set_position(&scene_buf->node,
						origin_x + glyph->x,
						origin_y - glyph->y);
			}
			wlr_buffer_drop(buffer);
		}

		x += box_w;
		total_w += box_w;
		if (module->box_count < TAGCOUNT) {
			int idx = module->box_count;
			module->box_x[idx] = outer_pad + total_w - box_w;
			module->box_w[idx] = box_w;
			module->box_tag[idx] = i;
			module->tagmask |= (1u << i);
			module->box_count++;
		}
		count++;
	}

	module->width = total_w + outer_pad * 2;
	updatemodulebg(module, module->width, bar_height, statusbar_tag_bg);
}

static int
readcpustats(struct CpuSample *out, int maxcount)
{
	FILE *fp;
	char line[256];
	int max_idx = -1;

	if (!out || maxcount <= 0)
		return 0;

	for (int i = 0; i < maxcount; i++) {
		out[i].idle = 0;
		out[i].total = 0;
	}

	fp = fopen("/proc/stat", "r");
	if (!fp)
		return -1;

	while (fgets(line, sizeof(line), fp)) {
		int idx = -1;
		unsigned long long user, nice, system, idle, iowait, irq, softirq, steal;
		unsigned long long idle_all, non_idle;

		if (sscanf(line, "cpu%d %llu %llu %llu %llu %llu %llu %llu %llu",
				&idx, &user, &nice, &system, &idle, &iowait, &irq, &softirq,
				&steal) == 9) {
			if (idx < 0 || idx >= maxcount)
				continue;
			idle_all = idle + iowait;
			non_idle = user + nice + system + irq + softirq + steal;
			out[idx].idle = idle_all;
			out[idx].total = idle_all + non_idle;
			if (idx > max_idx)
				max_idx = idx;
		}
	}

	fclose(fp);
	return max_idx + 1;
}

static double
cpuaverage(void)
{
	struct CpuSample curr[MAX_CPU_CORES];
	int count, used, i;
	double sum_busy = 0.0, sum_total = 0.0;
	double busy, perc;

	count = readcpustats(curr, MAX_CPU_CORES);
	if (count <= 0)
		return -1.0;
	if (count > MAX_CPU_CORES)
		count = MAX_CPU_CORES;

	for (i = 0; i < MAX_CPU_CORES; i++)
		cpu_last_core_percent[i] = -1.0;

	if (cpu_prev_count <= 0) {
		memcpy(cpu_prev, curr, count * sizeof(struct CpuSample));
		cpu_prev_count = count;
		cpu_core_count = count;
		return -1.0;
	}

	used = MIN(count, cpu_prev_count);
	cpu_core_count = count;
	for (i = 0; i < used; i++) {
		unsigned long long diff_total = curr[i].total - cpu_prev[i].total;
		unsigned long long diff_idle = curr[i].idle - cpu_prev[i].idle;
		if (curr[i].total == 0 || curr[i].idle == 0 ||
					curr[i].total <= cpu_prev[i].total ||
					curr[i].idle < cpu_prev[i].idle ||
					diff_total == 0) {
			cpu_last_core_percent[i] = -1.0;
			continue;
		}
		busy = (double)(diff_total - diff_idle);
		perc = (busy / (double)diff_total) * 100.0;
		cpu_last_core_percent[i] = perc;
		sum_busy += busy;
		sum_total += (double)diff_total;
	}

	memcpy(cpu_prev, curr, count * sizeof(struct CpuSample));
	cpu_prev_count = count;

	if (sum_total <= 0.0)
		return -1.0;

	return (sum_busy / sum_total) * 100.0;
}

static int
readmeminfo(unsigned long long *total_kb, unsigned long long *avail_kb)
{
	FILE *fp;
	char line[256];
	unsigned long long total = 0, avail = 0;

	fp = fopen("/proc/meminfo", "r");
	if (!fp)
		return -1;

	while (fgets(line, sizeof(line), fp)) {
		if (sscanf(line, "MemTotal: %llu kB", &total) == 1)
			continue;
		if (sscanf(line, "MemAvailable: %llu kB", &avail) == 1)
			continue;
	}

	fclose(fp);

	if (total == 0 || avail == 0)
		return -1;

	if (total_kb)
		*total_kb = total;
	if (avail_kb)
		*avail_kb = avail;
	return 0;
}

static double
ramused_mb(void)
{
	unsigned long long total, avail;

	if (readmeminfo(&total, &avail) != 0)
		return -1.0;

	if (total <= avail)
		return 0.0;

	return (double)(total - avail) / 1024.0;
}

static int
readulong(const char *path, unsigned long long *out)
{
	FILE *fp;
	unsigned long long val = 0;

	if (!path || !out)
		return -1;

	fp = fopen(path, "r");
	if (!fp)
		return -1;
	if (fscanf(fp, "%llu", &val) != 1) {
		fclose(fp);
		return -1;
	}

	fclose(fp);
	*out = val;
	return 0;
}

static int
findbatterydevice(char *capacity_path, size_t capacity_len)
{
	DIR *dir;
	struct dirent *ent;
	int have_battery = 0;
	char found[PATH_MAX] = {0};

	if (!capacity_path || capacity_len == 0)
		return 0;

	dir = opendir("/sys/class/power_supply");
	if (!dir)
		return 0;

	while ((ent = readdir(dir))) {
		char type_path[PATH_MAX];
		char cap_path[PATH_MAX];
		struct stat st;
		FILE *fp;
		char type[32] = {0};
		char *nl;

		if (ent->d_name[0] == '.')
			continue;

		if (snprintf(type_path, sizeof(type_path), "/sys/class/power_supply/%s/type",
					ent->d_name) >= (int)sizeof(type_path))
			continue;
		if (snprintf(cap_path, sizeof(cap_path), "/sys/class/power_supply/%s/capacity",
					ent->d_name) >= (int)sizeof(cap_path))
			continue;

		if (stat(type_path, &st) != 0 || !S_ISREG(st.st_mode))
			continue;
		if (stat(cap_path, &st) != 0 || !S_ISREG(st.st_mode))
			continue;
		if (access(cap_path, R_OK) != 0)
			continue;

		fp = fopen(type_path, "r");
		if (!fp)
			continue;
		if (!fgets(type, sizeof(type), fp)) {
			fclose(fp);
			continue;
		}
		fclose(fp);

		nl = strchr(type, '\n');
		if (nl)
			*nl = '\0';
		if (strcmp(type, "Battery") != 0)
			continue;

		if (snprintf(found, sizeof(found), "%s", cap_path) >= (int)sizeof(found))
			continue;
		/* Also store the device directory */
		snprintf(battery_device_dir, sizeof(battery_device_dir),
				"/sys/class/power_supply/%s", ent->d_name);
		have_battery = 1;
		break;
	}

	closedir(dir);

	if (!have_battery)
		return 0;
	if (snprintf(capacity_path, capacity_len, "%s", found) >= (int)capacity_len)
		return 0;
	return 1;
}

static int
findbluetoothdevice(void)
{
	DIR *dir;
	struct dirent *ent;
	int found = 0;

	dir = opendir("/sys/class/bluetooth");
	if (!dir)
		return 0;

	while ((ent = readdir(dir))) {
		if (ent->d_name[0] == '.')
			continue;
		/* Found at least one bluetooth adapter */
		found = 1;
		break;
	}

	closedir(dir);
	return found;
}

static int
is_process_running(const char *name)
{
	DIR *dir;
	struct dirent *ent;
	char path[PATH_MAX];
	char comm[256];
	FILE *fp;
	int found = 0;

	if (!name || !name[0])
		return 0;

	dir = opendir("/proc");
	if (!dir)
		return 0;

	while ((ent = readdir(dir))) {
		/* Skip non-numeric entries */
		if (ent->d_name[0] < '0' || ent->d_name[0] > '9')
			continue;

		snprintf(path, sizeof(path), "/proc/%s/comm", ent->d_name);
		fp = fopen(path, "r");
		if (!fp)
			continue;

		if (fgets(comm, sizeof(comm), fp)) {
			/* Remove trailing newline */
			char *nl = strchr(comm, '\n');
			if (nl)
				*nl = '\0';
			if (strcasecmp(comm, name) == 0 || strcasestr(comm, name)) {
				found = 1;
				fclose(fp);
				break;
			}
		}
		fclose(fp);
	}

	closedir(dir);
	return found;
}

static Client *
find_client_by_app_id(const char *app_id)
{
	Client *c;

	if (!app_id || !app_id[0])
		return NULL;

	wl_list_for_each(c, &clients, link) {
		if (c->type == XDGShell && c->surface.xdg && c->surface.xdg->toplevel) {
			const char *cid = c->surface.xdg->toplevel->app_id;
			if (cid && (strcasecmp(cid, app_id) == 0 || strcasestr(cid, app_id)))
				return c;
		}
#ifdef XWAYLAND
		if (c->type == X11 && c->surface.xwayland) {
			const char *cls = c->surface.xwayland->class;
			if (cls && (strcasecmp(cls, app_id) == 0 || strcasestr(cls, app_id)))
				return c;
		}
#endif
	}
	return NULL;
}

/* Find Discord client - checks multiple possible app_id variations.
 * Discord on NixOS/Linux can have various app_ids like:
 * "discord", "Discord", ".Discord-wrapped", "vesktop", etc. */
static Client *
find_discord_client(void)
{
	Client *c;
	const char *discord_ids[] = {
		"discord", "Discord", ".Discord", ".Discord-wrapped",
		"vesktop", "Vesktop", "webcord", "WebCord",
		"armcord", "ArmCord", "legcord", "Legcord",
		NULL
	};

	wl_list_for_each(c, &clients, link) {
		const char *cid = NULL;

		if (c->type == XDGShell && c->surface.xdg && c->surface.xdg->toplevel) {
			cid = c->surface.xdg->toplevel->app_id;
		}
#ifdef XWAYLAND
		if (c->type == X11 && c->surface.xwayland) {
			cid = c->surface.xwayland->class;
		}
#endif
		if (!cid)
			continue;

		/* Check exact matches and substring matches */
		for (int i = 0; discord_ids[i]; i++) {
			if (strcasecmp(cid, discord_ids[i]) == 0 ||
			    strcasestr(cid, discord_ids[i]))
				return c;
		}
	}
	return NULL;
}

static void
focus_or_launch_app(const char *app_id, const char *launch_cmd)
{
	Client *found;

	if (!app_id || !app_id[0])
		return;

	/* Find the client with matching app_id.
	 * For Discord, use specialized search that checks multiple app_id variants */
	if (strcasecmp(app_id, "discord") == 0)
		found = find_discord_client();
	else
		found = find_client_by_app_id(app_id);

	if (found) {
		/* Focus the client and switch to its tag/workspace */
		Monitor *m = found->mon;
		if (m && found->tags) {
			/* Switch to the tag where this client is */
			unsigned int newtags = found->tags & TAGMASK;
			if (newtags && newtags != m->tagset[m->seltags]) {
				m->tagset[m->seltags] = newtags;
				focusclient(found, 1);
				arrange(m);
			} else {
				focusclient(found, 1);
			}
		}
	} else if (launch_cmd && launch_cmd[0]) {
		/* No window found - launch/activate the app */
		pid_t pid = fork();
		if (pid == 0) {
			setsid();
			if (should_use_dgpu(launch_cmd))
				set_dgpu_env();
			if (is_steam_cmd(launch_cmd)) {
				set_steam_env();
				/* Launch Steam - Big Picture in HTPC mode, normal otherwise */
				if (htpc_mode_active) {
					execlp("steam", "steam", "-bigpicture", "-cef-force-gpu", "-cef-disable-sandbox", "steam://open/games", (char *)NULL);
				} else {
					execlp("steam", "steam", "-cef-force-gpu", "-cef-disable-sandbox", (char *)NULL);
				}
				_exit(1);
			}
			/* Discord: clean up stale singleton files before launching.
			 * Discord uses Electron which creates SingletonLock/Socket files
			 * that can become stale if the process crashes or is killed. */
			if (strcasecmp(launch_cmd, "discord") == 0) {
				const char *home = getenv("HOME");
				if (home) {
					char path[PATH_MAX];
					snprintf(path, sizeof(path), "%s/.config/discord/SingletonLock", home);
					unlink(path);
					snprintf(path, sizeof(path), "%s/.config/discord/SingletonCookie", home);
					unlink(path);
					snprintf(path, sizeof(path), "%s/.config/discord/SingletonSocket", home);
					unlink(path);
				}
			}
			execlp("sh", "sh", "-c", launch_cmd, NULL);
			_exit(1);
		}
	}
}

static int
readfirstline(const char *path, char *buf, size_t len)
{
	FILE *fp;

	if (!path || !buf || len == 0)
		return -1;
	fp = fopen(path, "r");
	if (!fp)
		return -1;
	if (!fgets(buf, (int)len, fp)) {
		fclose(fp);
		return -1;
	}
	fclose(fp);
	for (size_t i = 0; i < len; i++) {
		if (buf[i] == '\n') {
			buf[i] = '\0';
			break;
		}
	}
	return 0;
}

static int
readlinkspeedmbps(const char *iface, int *out)
{
	char path[PATH_MAX];
	char buf[32];
	long val;
	char *end;

	if (!iface || !out)
		return -1;
	if (snprintf(path, sizeof(path), "/sys/class/net/%s/speed", iface)
			>= (int)sizeof(path))
		return -1;
	if (readfirstline(path, buf, sizeof(buf)) != 0)
		return -1;
	errno = 0;
	val = strtol(buf, &end, 10);
	if (errno != 0 || end == buf)
		return -1;
	if (val <= 0)
		return -1;
	*out = (int)val;
	return 0;
}

static int
iface_is_wireless(const char *iface)
{
	char path[PATH_MAX];
	struct stat st;

	if (!iface)
		return 0;
	if (snprintf(path, sizeof(path), "/sys/class/net/%s/wireless", iface)
			>= (int)sizeof(path))
		return 0;
	return stat(path, &st) == 0 && S_ISDIR(st.st_mode);
}

static int
findactiveinterface(char *iface, size_t len, int *is_wireless)
{
	DIR *dir;
	struct dirent *ent;
	char best_wifi[IF_NAMESIZE] = {0};
	char best_wired[IF_NAMESIZE] = {0};
	char state[32];

	if (!iface || len == 0)
		return 0;

	dir = opendir("/sys/class/net");
	if (!dir)
		return 0;

	while ((ent = readdir(dir))) {
		char oper[PATH_MAX];

		if (ent->d_name[0] == '.')
			continue;
		if (strcmp(ent->d_name, "lo") == 0)
			continue;

		if (snprintf(oper, sizeof(oper), "/sys/class/net/%s/operstate",
					ent->d_name) >= (int)sizeof(oper))
			continue;
		if (readfirstline(oper, state, sizeof(state)) != 0)
			continue;
		if (strcmp(state, "up") != 0)
			continue;

		if (iface_is_wireless(ent->d_name)) {
			snprintf(best_wifi, sizeof(best_wifi), "%s", ent->d_name);
		} else if (!best_wired[0]) {
			snprintf(best_wired, sizeof(best_wired), "%s", ent->d_name);
		}

		if (best_wifi[0])
			break;
	}

	closedir(dir);

	if (best_wifi[0]) {
		if (snprintf(iface, len, "%s", best_wifi) >= (int)len)
			return 0;
		if (is_wireless)
			*is_wireless = 1;
		return 1;
	}
	if (best_wired[0]) {
		if (snprintf(iface, len, "%s", best_wired) >= (int)len)
			return 0;
		if (is_wireless)
			*is_wireless = 0;
		return 1;
	}
	return 0;
}

__attribute__((unused)) static int
readssid(const char *iface, char *out, size_t len)
{
	/* Deprecated: synchronous SSID lookup removed to avoid blocking */
	(void)iface;
	if (!out || len == 0)
		return 0;
	out[0] = '\0';
	return 0;
}

static int
localip(const char *iface, char *out, size_t len)
{
	struct ifaddrs *ifaddr, *ifa;
	int ret = 0;

	if (!iface || !out || len == 0)
		return 0;

	if (getifaddrs(&ifaddr) == -1)
		return 0;

	for (ifa = ifaddr; ifa; ifa = ifa->ifa_next) {
		void *addr;
		if (!ifa->ifa_addr || ifa->ifa_addr->sa_family != AF_INET)
			continue;
		if (!(ifa->ifa_flags & IFF_UP) || !(ifa->ifa_flags & IFF_RUNNING))
			continue;
		if (strcmp(ifa->ifa_name, iface) != 0)
			continue;

		addr = &((struct sockaddr_in *)ifa->ifa_addr)->sin_addr;
		if (inet_ntop(AF_INET, addr, out, (socklen_t)len)) {
			ret = 1;
			break;
		}
	}

	freeifaddrs(ifaddr);
	return ret;
}

static double
wireless_signal_percent(const char *iface)
{
	FILE *fp;
	char line[256];
	double quality = -1.0;

	if (!iface || !*iface)
		return -1.0;

	fp = fopen("/proc/net/wireless", "r");
	if (!fp)
		return -1.0;

	for (int i = 0; i < 2; i++) {
		if (!fgets(line, sizeof(line), fp))
			break;
	}

	while (fgets(line, sizeof(line), fp)) {
		char name[IF_NAMESIZE] = {0};
		double link = -1.0;

		if (sscanf(line, " %[^:]: %*[^ ] %lf", name, &link) == 2) {
			if (strcmp(name, iface) == 0) {
				quality = link;
				break;
			}
		}
	}

	fclose(fp);
	if (quality < 0.0)
		return -1.0;

	quality = (quality / 70.0) * 100.0;
	if (quality > 100.0)
		quality = 100.0;
	if (quality < 0.0)
		quality = 0.0;
	quality = round(quality);
	return quality;
}

static void
format_speed(double bps, char *out, size_t len)
{
	const char *unit = "kbps";
	double val = bps / 1000.0;

	if (!out || len == 0)
		return;

	if (bps < 0.0) {
		snprintf(out, len, "--");
		return;
	}

	if (val >= 1000.0) {
		val /= 1000.0;
		unit = "Mbps";
	}
	if (val >= 1000.0) {
		val /= 1000.0;
		unit = "Gbps";
	}

	if (val >= 100.0)
		snprintf(out, len, "%.0f %s", val, unit);
	else
		snprintf(out, len, "%.1f %s", val, unit);
}

static const char *
wifi_icon_for_quality(double quality_pct)
{
	if (quality_pct >= 75.0)
		return net_icon_wifi_100_resolved[0] ? net_icon_wifi_100_resolved : net_icon_wifi_100;
	if (quality_pct >= 50.0)
		return net_icon_wifi_75_resolved[0] ? net_icon_wifi_75_resolved : net_icon_wifi_75;
	if (quality_pct >= 25.0)
		return net_icon_wifi_50_resolved[0] ? net_icon_wifi_50_resolved : net_icon_wifi_50;
	return net_icon_wifi_25_resolved[0] ? net_icon_wifi_25_resolved : net_icon_wifi_25;
}

static void
set_net_icon_path(const char *path)
{
	if (!path || !*path)
		path = net_icon_no_conn_resolved[0] ? net_icon_no_conn_resolved : net_icon_no_conn;

	if (strncmp(net_icon_path, path, sizeof(net_icon_path)) != 0) {
		snprintf(net_icon_path, sizeof(net_icon_path), "%s", path);
	}
}

static void
request_public_ip_async_ex(int force)
{
	const char *cmd;
	int pipefd[2] = {-1, -1};
	time_t now = time(NULL);

	if (now == (time_t)-1)
		return;

	/* Skip rate limit if force is set (real-time update when hovering) */
	if (!force && net_public_ip_last != 0 && (now - net_public_ip_last) < 300)
		return;

	if (public_ip_pid > 0 || public_ip_event)
		return;

	cmd = getenv("NIXLYTILE_PUBLIC_IP_CMD");
	if (!cmd || !cmd[0])
		cmd = "curl -4 -s https://ifconfig.me";

	if (pipe(pipefd) != 0)
		return;

	public_ip_pid = fork();
	if (public_ip_pid == 0) {
		/* child */
		close(pipefd[0]);
		dup2(pipefd[1], STDOUT_FILENO);
		dup2(pipefd[1], STDERR_FILENO);
		close(pipefd[1]);
		execl("/bin/sh", "/bin/sh", "-c", cmd, NULL);
		_exit(127);
	} else if (public_ip_pid < 0) {
		close(pipefd[0]);
		close(pipefd[1]);
		public_ip_pid = -1;
		return;
	}

	/* parent */
	close(pipefd[1]);
	public_ip_fd = pipefd[0];
	fcntl(public_ip_fd, F_SETFL, fcntl(public_ip_fd, F_GETFL) | O_NONBLOCK);
	public_ip_len = 0;
	public_ip_buf[0] = '\0';
	net_public_ip_last = now; /* rate-limit even if fetch fails */
	public_ip_event = wl_event_loop_add_fd(event_loop, public_ip_fd,
			WL_EVENT_READABLE | WL_EVENT_HANGUP,
			public_ip_event_cb, NULL);
	if (!public_ip_event)
		stop_public_ip_fetch();
}

static void
request_public_ip_async(void)
{
	request_public_ip_async_ex(0);
}

static void
stop_public_ip_fetch(void)
{
	if (public_ip_event) {
		wl_event_source_remove(public_ip_event);
		public_ip_event = NULL;
	}
	if (public_ip_fd >= 0) {
		close(public_ip_fd);
		public_ip_fd = -1;
	}
	if (public_ip_pid > 0) {
		waitpid(public_ip_pid, NULL, WNOHANG);
		public_ip_pid = -1;
	}
	public_ip_len = 0;
	public_ip_buf[0] = '\0';
}

static int
public_ip_event_cb(int fd, uint32_t mask, void *data)
{
	ssize_t n;
	(void)data;

	(void)mask;

	for (;;) {
		if (public_ip_len >= sizeof(public_ip_buf) - 1)
			break;
		n = read(fd, public_ip_buf + public_ip_len,
				sizeof(public_ip_buf) - 1 - public_ip_len);
		if (n > 0) {
			public_ip_len += (size_t)n;
			continue;
		} else if (n == 0) {
			break;
		} else if (errno == EAGAIN || errno == EWOULDBLOCK) {
			return 0;
		} else {
			break;
		}
	}

	public_ip_buf[public_ip_len] = '\0';
	for (size_t i = 0; i < public_ip_len; i++) {
		if (public_ip_buf[i] == '\n' || public_ip_buf[i] == '\r') {
			public_ip_buf[i] = '\0';
			break;
		}
	}
	if (public_ip_buf[0])
		snprintf(net_public_ip, sizeof(net_public_ip), "%s", public_ip_buf);
	else if (!net_public_ip[0])
		snprintf(net_public_ip, sizeof(net_public_ip), "--");
	net_public_ip_last = time(NULL);
	stop_public_ip_fetch();
	return 0;
}

static void
request_ssid_async(const char *iface)
{
	int pipefd[2] = {-1, -1};
	char cmd[256];
	const char *iw = "/run/current-system/sw/bin/iw";
	const char *nmcli = "/run/current-system/sw/bin/nmcli";

	if (!iface || !*iface)
		return;
	if (ssid_pid > 0 || ssid_event)
		return;
	if (access(nmcli, X_OK) != 0) {
		nmcli = "/run/wrappers/bin/nmcli";
		if (access(nmcli, X_OK) != 0)
			nmcli = "nmcli";
	}
	if (access(iw, X_OK) != 0) {
		iw = "/run/wrappers/bin/iw";
		if (access(iw, X_OK) != 0)
			iw = "iw";
	}
	if (snprintf(cmd, sizeof(cmd),
				"%s -t -f active,ssid dev wifi | grep '^yes' | cut -d: -f2 || "
				"%s dev %s link 2>/dev/null",
				nmcli, iw, iface) >= (int)sizeof(cmd))
		return;

	if (pipe(pipefd) != 0)
		return;

	ssid_pid = fork();
	if (ssid_pid == 0) {
		close(pipefd[0]);
		dup2(pipefd[1], STDOUT_FILENO);
		dup2(pipefd[1], STDERR_FILENO);
		close(pipefd[1]);
		execl("/bin/sh", "/bin/sh", "-c", cmd, NULL);
		_exit(127);
	} else if (ssid_pid < 0) {
		close(pipefd[0]);
		close(pipefd[1]);
		ssid_pid = -1;
		return;
	}

	close(pipefd[1]);
	ssid_fd = pipefd[0];
	fcntl(ssid_fd, F_SETFL, fcntl(ssid_fd, F_GETFL) | O_NONBLOCK);
	ssid_len = 0;
	ssid_buf[0] = '\0';
	ssid_event = wl_event_loop_add_fd(event_loop, ssid_fd,
			WL_EVENT_READABLE | WL_EVENT_HANGUP,
			ssid_event_cb, NULL);
	if (!ssid_event)
		stop_ssid_fetch();
}

static void
stop_ssid_fetch(void)
{
	if (ssid_event) {
		wl_event_source_remove(ssid_event);
		ssid_event = NULL;
	}
	if (ssid_fd >= 0) {
		close(ssid_fd);
		ssid_fd = -1;
	}
	if (ssid_pid > 0) {
		waitpid(ssid_pid, NULL, WNOHANG);
		ssid_pid = -1;
	}
	ssid_len = 0;
	ssid_buf[0] = '\0';
}

static int
ssid_event_cb(int fd, uint32_t mask, void *data)
{
	ssize_t n;
	(void)data;
	(void)mask;

	for (;;) {
		if (ssid_len >= sizeof(ssid_buf) - 1)
			break;
		n = read(fd, ssid_buf + ssid_len, sizeof(ssid_buf) - 1 - ssid_len);
		if (n > 0) {
			ssid_len += (size_t)n;
			continue;
		} else if (n == 0) {
			break;
		} else if (errno == EAGAIN || errno == EWOULDBLOCK) {
			return 0;
		} else {
			break;
		}
	}

	ssid_buf[ssid_len] = '\0';
	if (ssid_buf[0]) {
		char *line = ssid_buf;
		while (line && *line) {
			char *next = strpbrk(line, "\r\n");
			if (next)
				*next = '\0';

			/* Try iw-style output first */
			char *ssid = strstr(line, "SSID");
			if (ssid) {
				while (*ssid && *ssid != ':' && *ssid != ' ')
					ssid++;
				while (*ssid == ':' || *ssid == ' ' || *ssid == '\t')
					ssid++;
			} else {
				ssid = line;
				while (*ssid == ' ' || *ssid == '\t')
					ssid++;
			}

			if (ssid && *ssid) {
				snprintf(net_ssid, sizeof(net_ssid), "%s", ssid);
				break;
			}

			line = next ? next + 1 : NULL;
		}
	}
	if (!net_ssid[0])
		snprintf(net_ssid, sizeof(net_ssid), "WiFi");
	ssid_last_time = time(NULL);
	stop_ssid_fetch();
	return 0;
}

static double
net_bytes_to_rate(unsigned long long cur, unsigned long long prev, double elapsed)
{
	if (elapsed <= 0.0 || cur < prev)
		return -1.0;
	return (double)(cur - prev) / elapsed;
}

static uint64_t
monotonic_msec(void)
{
	struct timespec ts;

	clock_gettime(CLOCK_MONOTONIC, &ts);
	return (uint64_t)ts.tv_sec * 1000ull + (uint64_t)(ts.tv_nsec / 1000000);
}

static void
tray_emit_host_registered(void)
{
	if (!tray_bus)
		return;
	sd_bus_emit_signal(tray_bus, NULL, "/StatusNotifierWatcher",
			"org.kde.StatusNotifierWatcher",
			"StatusNotifierHostRegistered", "");
	sd_bus_emit_signal(tray_bus, NULL, "/StatusNotifierWatcher",
			"org.freedesktop.StatusNotifierWatcher",
			"StatusNotifierHostRegistered", "");
}

static int
tray_search_item_path(const char *service, const char *start_path,
		char *out, size_t outlen, int depth)
{
	sd_bus_message *reply = NULL;
	sd_bus_error err = SD_BUS_ERROR_NULL;
	const char *xml;
	const char *p;
	int r = -1;

	if (!tray_bus || !service || !start_path || !out || outlen == 0 || depth <= 0)
		return -EINVAL;

	r = sd_bus_call_method(tray_bus, service, start_path,
			"org.freedesktop.DBus.Introspectable", "Introspect",
			&err, &reply, "");
	if (r < 0)
		goto out;

	if (sd_bus_message_read(reply, "s", &xml) < 0 || !xml) {
		r = -EINVAL;
		goto out;
	}

	if (strstr(xml, "org.kde.StatusNotifierItem")
			|| strstr(xml, "org.freedesktop.StatusNotifierItem")) {
		snprintf(out, outlen, "%s", start_path);
		r = 0;
		goto out;
	}

	if (depth <= 1) {
		r = 1;
		goto out;
	}

	p = xml;
	while ((p = strstr(p, "<node name=\""))) {
		char name[128];
		char child[256];
		const char *end;
		size_t nlen;

		p += strlen("<node name=\"");
		end = strchr(p, '"');
		if (!end)
			break;
		nlen = (size_t)(end - p);
		if (nlen == 0 || nlen >= sizeof(name)) {
			p = end ? end + 1 : p + 1;
			continue;
		}
		memcpy(name, p, nlen);
		name[nlen] = '\0';

		if (strcmp(start_path, "/") == 0)
			snprintf(child, sizeof(child), "/%s", name);
		else
			snprintf(child, sizeof(child), "%s/%s", start_path, name);

		if (tray_search_item_path(service, child, out, outlen, depth - 1) == 0) {
			r = 0;
			goto out;
		}
		p = end + 1;
	}

out:
	sd_bus_error_free(&err);
	sd_bus_message_unref(reply);
	return r;
}

static int
tray_find_item_path(const char *service, char *path, size_t pathlen)
{
	static const char *candidates[] = {
		"/StatusNotifierItem",
		"/org/ayatana/NotificationItem",
	};

	if (!service || !path || pathlen == 0)
		return -EINVAL;

	for (size_t i = 0; i < LENGTH(candidates); i++) {
		if (tray_search_item_path(service, candidates[i], path, pathlen, 1) == 0)
			return 0;
	}

	if (tray_search_item_path(service, "/", path, pathlen, 6) == 0)
		return 0;

	snprintf(path, pathlen, "%s", "/StatusNotifierItem");
	return -1;
}

static void
tray_sanitize_label(const char *src, char *dst, size_t len)
{
	size_t di = 0;
	int in_tag = 0;

	if (!dst || len == 0) {
		return;
	}

	dst[0] = '\0';
	if (!src)
		return;

	for (size_t i = 0; src[i] && di + 1 < len; i++) {
		char c = src[i];
		if (c == '<') {
			in_tag = 1;
			continue;
		}
		if (in_tag) {
			if (c == '>')
				in_tag = 0;
			continue;
		}
		if (c == '_' || c == '&')
			continue;
		dst[di++] = c;
	}

	while (di > 0 && (dst[di - 1] == ' ' || dst[di - 1] == '\t'))
		di--;
	dst[di] = '\0';
}

static void
tray_menu_clear(TrayMenu *menu)
{
	TrayMenuEntry *e, *tmp;

	if (!menu)
		return;

	wl_list_for_each_safe(e, tmp, &menu->entries, link) {
		wl_list_remove(&e->link);
		free(e);
	}
	wl_list_init(&menu->entries);

	menu->width = menu->height = 0;
	menu->x = menu->y = 0;
	menu->visible = 0;
	menu->service[0] = '\0';
	menu->menu_path[0] = '\0';

	if (menu->tree)
		wlr_scene_node_set_enabled(&menu->tree->node, 0);
}

static void
tray_menu_hide(Monitor *m)
{
	if (!m)
		return;
	tray_menu_clear(&m->statusbar.tray_menu);
}

static void
tray_menu_hide_all(void)
{
	Monitor *m;

	wl_list_for_each(m, &mons, link)
		tray_menu_hide(m);
}

static int
tray_item_get_menu_path(TrayItem *it)
{
	static const char *ifaces[] = {
		"org.kde.StatusNotifierItem",
		"org.freedesktop.StatusNotifierItem",
	};
	const char *item_path;
	sd_bus_message *reply = NULL;
	sd_bus_error err = SD_BUS_ERROR_NULL;
	const char *path = NULL;
	int r = -1;

	if (!tray_bus || !it)
		return -EINVAL;

	it->has_menu = 0;
	it->menu[0] = '\0';
	item_path = it->path[0] ? it->path : "/StatusNotifierItem";

	for (size_t i = 0; i < LENGTH(ifaces); i++) {
		sd_bus_error_free(&err);
		reply = NULL;
		r = sd_bus_call_method(tray_bus, it->service,
				item_path,
				"org.freedesktop.DBus.Properties", "Get",
				&err, &reply, "ss", ifaces[i], "Menu");
		if (r < 0)
			continue;
		if (sd_bus_message_enter_container(reply, 'v', "o") < 0) {
			sd_bus_message_unref(reply);
			continue;
		}
		if (sd_bus_message_read(reply, "o", &path) < 0) {
			sd_bus_message_exit_container(reply);
			sd_bus_message_unref(reply);
			continue;
		}
		sd_bus_message_exit_container(reply);
		if (path && path[0] && strcmp(path, "/") != 0) {
			snprintf(it->menu, sizeof(it->menu), "%s", path);
			it->has_menu = 1;
			sd_bus_message_unref(reply);
			sd_bus_error_free(&err);
			return 0;
		}
		wlr_log(WLR_ERROR, "tray: service %s Menu property empty/invalid", it->service);
		sd_bus_message_unref(reply);
	}

	sd_bus_error_free(&err);
	wlr_log(WLR_ERROR, "tray: failed to get Menu property for %s: %s",
			it->service, strerror(-r));
	return -1;
}

static int
tray_menu_parse_node(sd_bus_message *msg, TrayMenu *menu, int depth, int max_depth)
{
	int r;

	if (!msg || !menu)
		return -EINVAL;

	r = sd_bus_message_enter_container(msg, 'r', "ia{sv}av");
	if (r < 0)
		return r;
	if (r == 0)
		return 0;
	if (depth < 0 || depth > max_depth + 4) /* sanity */
		return -EINVAL;

	r = tray_menu_parse_node_body(msg, menu, depth, max_depth);
	sd_bus_message_exit_container(msg);
	return r;
}

static int
tray_menu_parse_node_body(sd_bus_message *msg, TrayMenu *menu, int depth, int max_depth)
{
	TrayMenuEntry *entry;
	int id = 0, r = 0;
	int enabled = 1, visible = 1;
	int is_separator = 0, has_submenu = 0;
	int toggle_type = 0, toggle_state = 0;
	int child_count = 0;
	char label[256] = {0};

	if (!msg || !menu)
		return -EINVAL;
	if (depth > max_depth + 4)
		return -EINVAL;

	if (sd_bus_message_read(msg, "i", &id) < 0)
		return -EINVAL;

	r = sd_bus_message_enter_container(msg, 'a', "{sv}");
	if (r < 0)
		return r;
	while ((r = sd_bus_message_enter_container(msg, 'e', "sv")) > 0) {
		const char *key = NULL;
		if (sd_bus_message_read(msg, "s", &key) < 0) {
			sd_bus_message_exit_container(msg);
			r = -EINVAL;
			break;
		}
		if (key && strcmp(key, "label") == 0) {
			const char *val = NULL;
			if (sd_bus_message_enter_container(msg, 'v', "s") >= 0) {
				if (sd_bus_message_read(msg, "s", &val) >= 0 && val)
					tray_sanitize_label(val, label, sizeof(label));
				sd_bus_message_exit_container(msg);
			} else {
				sd_bus_message_skip(msg, "v");
			}
		} else if (key && strcmp(key, "enabled") == 0) {
			int v = 1;
			if (sd_bus_message_enter_container(msg, 'v', "b") >= 0) {
				sd_bus_message_read(msg, "b", &v);
				enabled = v;
				sd_bus_message_exit_container(msg);
			} else {
				sd_bus_message_skip(msg, "v");
			}
		} else if (key && strcmp(key, "visible") == 0) {
			int v = 1;
			if (sd_bus_message_enter_container(msg, 'v', "b") >= 0) {
				sd_bus_message_read(msg, "b", &v);
				visible = v;
				sd_bus_message_exit_container(msg);
			} else {
				sd_bus_message_skip(msg, "v");
			}
		} else if (key && strcmp(key, "type") == 0) {
			const char *val = NULL;
			if (sd_bus_message_enter_container(msg, 'v', "s") >= 0) {
				if (sd_bus_message_read(msg, "s", &val) >= 0 && val
						&& strcmp(val, "separator") == 0)
					is_separator = 1;
				sd_bus_message_exit_container(msg);
			} else {
				sd_bus_message_skip(msg, "v");
			}
		} else if (key && strcmp(key, "toggle-type") == 0) {
			const char *val = NULL;
			if (sd_bus_message_enter_container(msg, 'v', "s") >= 0) {
				if (sd_bus_message_read(msg, "s", &val) >= 0 && val) {
					if (strcmp(val, "checkmark") == 0)
						toggle_type = 1;
					else if (strcmp(val, "radio") == 0)
						toggle_type = 2;
				}
				sd_bus_message_exit_container(msg);
			} else {
				sd_bus_message_skip(msg, "v");
			}
		} else if (key && strcmp(key, "toggle-state") == 0) {
			int32_t state = 0;
			if (sd_bus_message_enter_container(msg, 'v', "i") >= 0) {
				sd_bus_message_read(msg, "i", &state);
				if (state < 0)
					state = 0;
				toggle_state = state;
				sd_bus_message_exit_container(msg);
			} else {
				sd_bus_message_skip(msg, "v");
			}
		} else if (key && strcmp(key, "children-display") == 0) {
			const char *val = NULL;
			if (sd_bus_message_enter_container(msg, 'v', "s") >= 0) {
				if (sd_bus_message_read(msg, "s", &val) >= 0 && val
						&& strcmp(val, "submenu") == 0)
					has_submenu = 1;
				sd_bus_message_exit_container(msg);
			} else {
				sd_bus_message_skip(msg, "v");
			}
		} else {
			sd_bus_message_skip(msg, "v");
		}
		sd_bus_message_exit_container(msg);
	}
	sd_bus_message_exit_container(msg);
	if (r < 0)
		return r;

	{
		r = sd_bus_message_enter_container(msg, 'a', "(ia{sv}av)");
		if (r < 0)
			return r;
		while ((r = sd_bus_message_enter_container(msg, 'r', "ia{sv}av")) > 0) {
			child_count++;
			if (depth < max_depth) {
				int cr = tray_menu_parse_node_body(msg, menu, depth + 1, max_depth);
				if (cr < 0) {
					sd_bus_message_exit_container(msg);
					r = cr;
					break;
				}
			} else {
				if (sd_bus_message_skip(msg, "ia{sv}av") < 0) {
					sd_bus_message_exit_container(msg);
					r = -EINVAL;
					break;
				}
			}
			sd_bus_message_exit_container(msg);
		}
		sd_bus_message_exit_container(msg);
		if (r < 0)
			return r;
	}

	if (!visible || depth == 0 || depth > max_depth)
		return 0;

	entry = ecalloc(1, sizeof(*entry));
	entry->id = id;
	entry->enabled = enabled;
	entry->is_separator = is_separator;
	entry->depth = depth - 1;
	entry->has_submenu = has_submenu || child_count > 0;
	entry->toggle_type = toggle_type;
	entry->toggle_state = toggle_state;
	if (label[0])
		snprintf(entry->label, sizeof(entry->label), "%s", label);

	wl_list_insert(menu->entries.prev, &entry->link);
	return 0;
}

static void
tray_menu_draw_text(struct wlr_scene_tree *tree, const char *text, int x, int y, int row_h)
{
	tll(struct GlyphRun) glyphs = tll_init();
	const struct fcft_glyph *glyph;
	struct wlr_scene_buffer *scene_buf;
	struct wlr_buffer *buffer;
	uint32_t prev_cp = 0;
	int pen_x = 0;
	int min_y = INT_MAX, max_y = INT_MIN;

	if (!tree || !text || !*text || row_h <= 0)
		return;
	if (!statusfont.font)
		return;

	for (size_t i = 0; text[i]; i++) {
		long kern_x = 0, kern_y = 0;
		uint32_t cp = (unsigned char)text[i];

		if (prev_cp)
			fcft_kerning(statusfont.font, prev_cp, cp, &kern_x, &kern_y);
		pen_x += (int)kern_x;

		glyph = fcft_rasterize_char_utf32(statusfont.font, cp, statusbar_font_subpixel);
		if (glyph && glyph->pix) {
			tll_push_back(glyphs, ((struct GlyphRun){
				.glyph = glyph,
				.pen_x = pen_x,
				.codepoint = cp,
			}));
			if (-glyph->y < min_y)
				min_y = -glyph->y;
			if (-glyph->y + glyph->height > max_y)
				max_y = -glyph->y + glyph->height;
			pen_x += glyph->advance.x;
			if (text[i + 1])
				pen_x += statusbar_font_spacing;
		}
		prev_cp = cp;
	}

	if (tll_length(glyphs) == 0) {
		tll_free(glyphs);
		return;
	}

	{
		int text_height = max_y - min_y;
		int origin_y = y + (row_h - text_height) / 2 - min_y;

		tll_foreach(glyphs, it) {
			glyph = it->item.glyph;
			buffer = statusbar_buffer_from_glyph(glyph);
			if (!buffer)
				continue;

			scene_buf = wlr_scene_buffer_create(tree, NULL);
			if (scene_buf) {
				wlr_scene_buffer_set_buffer(scene_buf, buffer);
				wlr_scene_node_set_position(&scene_buf->node,
						x + it->item.pen_x + glyph->x,
						origin_y - glyph->y);
			}
			wlr_buffer_drop(buffer);
		}
	}

	tll_free(glyphs);
}

static void
tray_menu_render(Monitor *m)
{
	TrayMenu *menu;
	struct wlr_scene_node *node, *tmp;
	TrayMenuEntry *entry;
	int padding, line_spacing, indent_w;
	int max_width = 0;
	int total_height;
	int row_h;

	if (!m || !m->statusbar.tray_menu.tree)
		return;
	menu = &m->statusbar.tray_menu;

	padding = statusbar_module_padding;
	line_spacing = 4;
	indent_w = statusbar_font_spacing > 0 ? statusbar_font_spacing * 2 : 10;

	wl_list_for_each_safe(node, tmp, &menu->tree->children, link) {
		if (menu->bg && node == &menu->bg->node)
			continue;
		wlr_scene_node_destroy(node);
	}

	if (!statusfont.font || wl_list_empty(&menu->entries)) {
		menu->width = menu->height = 0;
		wlr_scene_node_set_enabled(&menu->tree->node, 0);
		menu->visible = 0;
		return;
	}

	row_h = statusfont.height + line_spacing;
	if (row_h < statusfont.height)
		row_h = statusfont.height;
	total_height = padding * 2;

	wl_list_for_each(entry, &menu->entries, link) {
		int text_w = entry->is_separator ? 0 : status_text_width(
				entry->label[0] ? entry->label : " ");
		int row_width = text_w + 2 * padding + indent_w * entry->depth;
		if (entry->toggle_type)
			row_width += row_h;
		if (entry->has_submenu)
			row_width += row_h / 2;
		max_width = MAX(max_width, row_width);
		total_height += entry->is_separator ? line_spacing : row_h;
	}

	if (max_width <= 0)
		max_width = 80;

	menu->width = max_width;
	menu->height = total_height;

	if (!menu->bg && !(menu->bg = wlr_scene_tree_create(menu->tree)))
		return;
	wlr_scene_node_set_enabled(&menu->bg->node, 1);
	wlr_scene_node_set_position(&menu->bg->node, 0, 0);
	wl_list_for_each_safe(node, tmp, &menu->bg->children, link)
		wlr_scene_node_destroy(node);
	drawrect(menu->bg, 0, 0, menu->width, menu->height, statusbar_bg);

	{
		int y = padding;
		wl_list_for_each(entry, &menu->entries, link) {
			char text[512];
			int row = entry->is_separator ? line_spacing : row_h;
			int x = padding + indent_w * entry->depth;

			entry->y = y;
			entry->height = row;

			if (entry->is_separator) {
				int sep_y = y + row / 2;
				drawrect(menu->tree, padding, sep_y, menu->width - 2 * padding, 1, statusbar_fg);
				y += row;
				continue;
			}

			text[0] = '\0';
			if (entry->toggle_type == 1) {
				snprintf(text, sizeof(text), "%s%s%s",
						entry->toggle_state ? "[x] " : "[ ] ",
						entry->label[0] ? entry->label : "",
						entry->has_submenu ? "  >" : "");
			} else if (entry->toggle_type == 2) {
				snprintf(text, sizeof(text), "%s%s%s",
						entry->toggle_state ? "(o) " : "( ) ",
						entry->label[0] ? entry->label : "",
						entry->has_submenu ? "  >" : "");
			} else {
				snprintf(text, sizeof(text), "%s%s",
						entry->label[0] ? entry->label : " ",
						entry->has_submenu ? "  >" : "");
			}

			tray_menu_draw_text(menu->tree, text, x, y, row);
			y += row;
		}
	}
}

static __attribute__((unused)) int
tray_menu_open_at(Monitor *m, TrayItem *it, int icon_x)
{
	sd_bus_message *req = NULL, *reply = NULL;
	sd_bus_error err = SD_BUS_ERROR_NULL;
	char *props[] = {"label", "enabled", "type", "children-display",
		"toggle-type", "toggle-state", "visible", NULL};
	int r;
	int max_depth = 3; /* limited depth for safety; can be raised if needed */
	TrayMenu *menu;
	int desired_x, max_x;
	const char *sig;

	if (!m || !m->showbar || !m->statusbar.tray_menu.tree || !it || !tray_bus)
		return 0;
	if (!m->statusbar.area.width || !m->statusbar.area.height)
		return 0;

	if (tray_item_get_menu_path(it) != 0 || !it->has_menu)
		return 0;

	menu = &m->statusbar.tray_menu;
	tray_menu_hide_all();
	tray_menu_clear(menu);
	wl_list_init(&menu->entries);
	if (!menu->tree) {
		return 0;
	}
	if (max_depth < 1)
		max_depth = 1;

	/* Temporarily disable custom menu parsing to avoid crashes; fall back to client ContextMenu */
	return 0;

	r = sd_bus_message_new_method_call(tray_bus, &req, it->service, it->menu,
			"com.canonical.dbusmenu", "GetLayout");
	if (r < 0)
		goto fail;

	r = sd_bus_message_append(req, "iias", 0, max_depth, props);
	if (r < 0)
		goto fail;

	r = sd_bus_call(tray_bus, req, 2 * 1000 * 1000, &err, &reply);
	if (r < 0)
		goto fail;

	sig = sd_bus_message_get_signature(reply, 0);
	if (!sig || !strstr(sig, "(ia{sv}av)")) {
		r = -EINVAL;
		goto fail;
	}

	{
		int revision = 0;
		if (sd_bus_message_read(reply, "i", &revision) < 0)
			goto fail;
		(void)revision;
		if ((r = tray_menu_parse_node(reply, menu, 0, max_depth)) < 0)
			goto fail;
	}

	sd_bus_message_unref(req);
	sd_bus_message_unref(reply);
	sd_bus_error_free(&err);

	if (wl_list_empty(&menu->entries))
		goto fail;

	snprintf(menu->service, sizeof(menu->service), "%s", it->service);
	snprintf(menu->menu_path, sizeof(menu->menu_path), "%s", it->menu);

	tray_menu_render(m);
	if (menu->width <= 0 || menu->height <= 0)
		goto fail;

	desired_x = icon_x - menu->width / 2;
	if (desired_x < 0)
		desired_x = 0;
	max_x = m->statusbar.area.width - menu->width;
	if (max_x < 0)
		max_x = 0;
	if (desired_x > max_x)
		desired_x = max_x;

	menu->x = desired_x;
	menu->y = m->statusbar.area.height;
	wlr_scene_node_set_position(&menu->tree->node, menu->x, menu->y);
	wlr_scene_node_set_enabled(&menu->tree->node, 1);
	menu->visible = 1;
	return 1;

fail:
	wlr_log(WLR_ERROR, "tray: GetLayout failed for %s%s: %s",
			it->service, it->menu, err.message ? err.message : strerror(-r));
	if (req)
		sd_bus_message_unref(req);
	if (reply)
		sd_bus_message_unref(reply);
	sd_bus_error_free(&err);
	tray_menu_hide_all();
	return 0;
}

static TrayMenuEntry *
tray_menu_entry_at(Monitor *m, int lx, int ly)
{
	TrayMenuEntry *entry;
	TrayMenu *menu;

	if (!m)
		return NULL;
	menu = &m->statusbar.tray_menu;
	wl_list_for_each(entry, &menu->entries, link) {
		if (ly >= entry->y && ly < entry->y + entry->height) {
			if (entry->is_separator || !entry->enabled)
				return NULL;
			return entry;
		}
	}
	return NULL;
}

static int
tray_menu_send_event(TrayMenu *menu, TrayMenuEntry *entry, uint32_t time_msec)
{
	sd_bus_message *msg = NULL, *reply = NULL;
	sd_bus_error err = SD_BUS_ERROR_NULL;
	int r;

	if (!tray_bus || !menu || !entry || !menu->service[0] || !menu->menu_path[0])
		return -EINVAL;

	r = sd_bus_message_new_method_call(tray_bus, &msg, menu->service, menu->menu_path,
			"com.canonical.dbusmenu", "Event");
	if (r < 0)
		goto out;

	r = sd_bus_message_append(msg, "is", entry->id, "clicked");
	if (r < 0)
		goto out;

	r = sd_bus_message_open_container(msg, 'v', "s");
	if (r < 0)
		goto out;
	r = sd_bus_message_append_basic(msg, 's', "");
	if (r < 0)
		goto out;
	r = sd_bus_message_close_container(msg);
	if (r < 0)
		goto out;

	r = sd_bus_message_append(msg, "u", time_msec);
	if (r < 0)
		goto out;

	r = sd_bus_call(tray_bus, msg, 2 * 1000 * 1000, &err, &reply);

out:
	if (msg)
		sd_bus_message_unref(msg);
	if (reply)
		sd_bus_message_unref(reply);
	sd_bus_error_free(&err);
	return r < 0 ? r : 0;
}

static void
connect_wifi_ssid(const char *ssid)
{
	if (!ssid || !*ssid)
		return;
	if (fork() == 0) {
		setsid();
		int fd = open("/dev/null", O_RDWR);
		if (fd >= 0) {
			dup2(fd, STDOUT_FILENO);
			dup2(fd, STDERR_FILENO);
			close(fd);
		}
		/* Include ifname to ensure proper network switching */
		if (net_iface[0])
			execlp("nmcli", "nmcli", "device", "wifi", "connect", ssid, "ifname", net_iface, (char *)NULL);
		else
			execlp("nmcli", "nmcli", "device", "wifi", "connect", ssid, (char *)NULL);
		_exit(0);
	}
}

static void
connect_wifi_with_prompt(const char *ssid, int secure)
{
	if (!ssid || !*ssid)
		return;
	/* Prefer zenity if present, else fallback to a terminal prompt */
	if (secure) {
		char cmd[1024];
		/* Include ifname ($2) to ensure proper network switching */
		snprintf(cmd, sizeof(cmd),
			"if command -v zenity >/dev/null 2>&1; then "
				"pw=$(zenity --entry --hide-text --text=\"Passphrase for $1\" --title=\"Wi-Fi\" 2>/dev/null) || exit 1; "
			"elif command -v wofi >/dev/null 2>&1; then "
				"pw=$(printf '' | wofi --dmenu --password --prompt \"Passphrase for $1\" 2>/dev/null) || exit 1; "
			"elif command -v bemenu >/dev/null 2>&1; then "
				"pw=$(printf '' | bemenu -p \"Passphrase for $1\" -P 2>/dev/null) || exit 1; "
			"elif command -v dmenu >/dev/null 2>&1; then "
				"pw=$(printf '' | dmenu -p \"Passphrase for $1\" 2>/dev/null) || exit 1; "
			"else exit 1; fi; "
			"nmcli device wifi connect \"$1\" password \"$pw\"%s >/dev/null 2>&1",
			net_iface[0] ? " ifname \"$2\"" : "");
		if (fork() == 0) {
			setsid();
			if (net_iface[0])
				execl("/bin/sh", "/bin/sh", "-c", cmd, "nmcli-connect", ssid, net_iface, (char *)NULL);
			else
				execl("/bin/sh", "/bin/sh", "-c", cmd, "nmcli-connect", ssid, (char *)NULL);
			_exit(0);
		}
		return;
	}
	/* Fallback: attempt plain connect (will fail if not saved) */
	connect_wifi_ssid(ssid);
}

static void
connect_wifi_with_password(const char *ssid, const char *password)
{
	if (!ssid || !*ssid || !password)
		return;
	if (fork() == 0) {
		char cmd[512];
		setsid();
		/* Include ifname to ensure proper network switching */
		if (net_iface[0])
			snprintf(cmd, sizeof(cmd),
				"nmcli device wifi connect \"%s\" password \"%s\" ifname \"%s\" >/dev/null 2>&1",
				ssid, password, net_iface);
		else
			snprintf(cmd, sizeof(cmd),
				"nmcli device wifi connect \"%s\" password \"%s\" >/dev/null 2>&1",
				ssid, password);
		execl("/bin/sh", "/bin/sh", "-c", cmd, (char *)NULL);
		_exit(0);
	}
}

static int
wifi_popup_connect_cb(int fd, uint32_t mask, void *data)
{
	Monitor *m = data;
	WifiPasswordPopup *p;
	char buf[256];
	ssize_t n;
	int status = 0;
	int finished = 0;

	(void)mask;

	if (!m)
		return 0;

	p = &m->wifi_popup;

	/* Read until EOF or would block */
	for (;;) {
		n = read(fd, buf, sizeof(buf));
		if (n > 0) {
			continue;  /* More data, keep reading */
		} else if (n == 0) {
			finished = 1;  /* EOF - process finished */
			break;
		} else if (errno == EAGAIN || errno == EWOULDBLOCK) {
			return 0;  /* No more data available yet */
		} else {
			finished = 1;  /* Error - treat as finished */
			break;
		}
	}

	if (!finished)
		return 0;

	/* Process finished - get exit status */
	if (p->connect_pid > 0) {
		waitpid(p->connect_pid, &status, 0);
		p->connect_pid = -1;
	}
	if (p->connect_event) {
		wl_event_source_remove(p->connect_event);
		p->connect_event = NULL;
	}
	if (p->connect_fd >= 0) {
		close(p->connect_fd);
		p->connect_fd = -1;
	}

	p->connecting = 0;
	if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {
		/* Success - hide popup and menu */
		wifi_popup_hide_all();
		net_menu_hide_all();
	} else if (p->try_saved) {
		/* Saved credentials failed - show password popup */
		p->try_saved = 0;
		net_menu_hide_all();  /* Hide menu before showing popup */
		p->visible = 1;
		p->error = 0;
		wifi_popup_render(m);
	} else {
		/* Password entry failed - show error */
		p->error = 1;
		wifi_popup_render(m);
	}
	return 0;
}

static void
wifi_popup_connect(Monitor *m)
{
	WifiPasswordPopup *p;
	int pipefd[2];
	pid_t pid;

	if (!m)
		return;

	p = &m->wifi_popup;

	if (p->connecting || p->password_len == 0)
		return;

	/* Clean up any previous connection attempt */
	if (p->connect_event) {
		wl_event_source_remove(p->connect_event);
		p->connect_event = NULL;
	}
	if (p->connect_fd >= 0) {
		close(p->connect_fd);
		p->connect_fd = -1;
	}
	if (p->connect_pid > 0) {
		kill(p->connect_pid, SIGTERM);
		waitpid(p->connect_pid, NULL, WNOHANG);
		p->connect_pid = -1;
	}

	if (pipe(pipefd) < 0)
		return;

	pid = fork();
	if (pid < 0) {
		close(pipefd[0]);
		close(pipefd[1]);
		return;
	}

	if (pid == 0) {
		/* Child */
		close(pipefd[0]);
		dup2(pipefd[1], STDOUT_FILENO);
		dup2(pipefd[1], STDERR_FILENO);
		close(pipefd[1]);
		setsid();

		/* Delete any existing corrupted connection profile first (ignore errors),
		 * then connect with the new password.
		 * Use execlp with separate args to avoid shell escaping issues. */
		{
			pid_t del_pid = fork();
			if (del_pid == 0) {
				/* Delete child - silence output */
				int null_fd = open("/dev/null", O_RDWR);
				if (null_fd >= 0) {
					dup2(null_fd, STDOUT_FILENO);
					dup2(null_fd, STDERR_FILENO);
					close(null_fd);
				}
				execlp("nmcli", "nmcli", "connection", "delete", p->ssid, (char *)NULL);
				_exit(0);
			}
			if (del_pid > 0)
				waitpid(del_pid, NULL, 0);
		}

		/* Now connect with password */
		if (net_iface[0])
			execlp("nmcli", "nmcli", "device", "wifi", "connect",
				p->ssid, "password", p->password, "ifname", net_iface, (char *)NULL);
		else
			execlp("nmcli", "nmcli", "device", "wifi", "connect",
				p->ssid, "password", p->password, (char *)NULL);
		_exit(1);
	}

	/* Parent */
	close(pipefd[1]);

	int flags = fcntl(pipefd[0], F_GETFL, 0);
	fcntl(pipefd[0], F_SETFL, flags | O_NONBLOCK);

	p->connect_pid = pid;
	p->connect_fd = pipefd[0];
	p->connecting = 1;
	p->error = 0;
	p->connect_event = wl_event_loop_add_fd(event_loop,
		pipefd[0], WL_EVENT_READABLE | WL_EVENT_HANGUP,
		wifi_popup_connect_cb, m);

	wifi_popup_render(m);
}

static void
wifi_try_saved_connect(Monitor *m, const char *ssid)
{
	WifiPasswordPopup *p;
	int pipefd[2];
	pid_t pid;

	if (!m || !ssid || !*ssid)
		return;

	p = &m->wifi_popup;

	/* Store SSID for potential password popup later */
	snprintf(p->ssid, sizeof(p->ssid), "%s", ssid);
	p->password[0] = '\0';
	p->password_len = 0;
	p->visible = 0;  /* Don't show popup yet */
	p->error = 0;
	p->try_saved = 1;  /* Mark that we're trying saved credentials */

	/* Clean up any previous connection attempt */
	if (p->connect_event) {
		wl_event_source_remove(p->connect_event);
		p->connect_event = NULL;
	}
	if (p->connect_fd >= 0) {
		close(p->connect_fd);
		p->connect_fd = -1;
	}
	if (p->connect_pid > 0) {
		kill(p->connect_pid, SIGTERM);
		waitpid(p->connect_pid, NULL, WNOHANG);
		p->connect_pid = -1;
	}

	if (pipe(pipefd) < 0)
		return;

	pid = fork();
	if (pid < 0) {
		close(pipefd[0]);
		close(pipefd[1]);
		return;
	}

	if (pid == 0) {
		/* Child */
		close(pipefd[0]);
		dup2(pipefd[1], STDOUT_FILENO);
		dup2(pipefd[1], STDERR_FILENO);
		close(pipefd[1]);
		setsid();

		/* Try connecting without password - nmcli will use saved credentials
		 * Include ifname to ensure proper network switching */
		if (net_iface[0])
			execlp("nmcli", "nmcli", "device", "wifi", "connect", ssid, "ifname", net_iface, (char *)NULL);
		else
			execlp("nmcli", "nmcli", "device", "wifi", "connect", ssid, (char *)NULL);
		_exit(1);
	}

	/* Parent */
	close(pipefd[1]);

	int flags = fcntl(pipefd[0], F_GETFL, 0);
	fcntl(pipefd[0], F_SETFL, flags | O_NONBLOCK);

	p->connect_pid = pid;
	p->connect_fd = pipefd[0];
	p->connecting = 1;
	p->connect_event = wl_event_loop_add_fd(event_loop,
		pipefd[0], WL_EVENT_READABLE | WL_EVENT_HANGUP,
		wifi_popup_connect_cb, m);
}

static Monitor *
wifi_popup_visible_monitor(void)
{
	Monitor *m;
	wl_list_for_each(m, &mons, link) {
		if (m->wifi_popup.visible)
			return m;
	}
	return NULL;
}

static void
wifi_popup_hide(Monitor *m)
{
	if (!m || !m->wifi_popup.tree)
		return;
	/* Clean up any ongoing connection */
	if (m->wifi_popup.connect_event) {
		wl_event_source_remove(m->wifi_popup.connect_event);
		m->wifi_popup.connect_event = NULL;
	}
	if (m->wifi_popup.connect_fd >= 0) {
		close(m->wifi_popup.connect_fd);
		m->wifi_popup.connect_fd = -1;
	}
	if (m->wifi_popup.connect_pid > 0) {
		kill(m->wifi_popup.connect_pid, SIGTERM);
		waitpid(m->wifi_popup.connect_pid, NULL, WNOHANG);
		m->wifi_popup.connect_pid = -1;
	}
	m->wifi_popup.visible = 0;
	m->wifi_popup.password[0] = '\0';
	m->wifi_popup.password_len = 0;
	m->wifi_popup.ssid[0] = '\0';
	m->wifi_popup.button_hover = 0;
	m->wifi_popup.connecting = 0;
	m->wifi_popup.error = 0;
	m->wifi_popup.try_saved = 0;
	wlr_scene_node_set_enabled(&m->wifi_popup.tree->node, 0);
	/* Also hide on-screen keyboard */
	osk_hide(m);
}

static void
wifi_popup_hide_all(void)
{
	Monitor *m;
	wl_list_for_each(m, &mons, link)
		wifi_popup_hide(m);
}

static void
wifi_popup_show(Monitor *m, const char *ssid)
{
	if (!m || !ssid || !*ssid)
		return;

	/* Copy SSID first - net_menu_hide_all() frees the WifiNetwork structs */
	snprintf(m->wifi_popup.ssid, sizeof(m->wifi_popup.ssid), "%s", ssid);

	wifi_popup_hide_all();
	net_menu_hide_all();

	m->wifi_popup.password[0] = '\0';
	m->wifi_popup.password_len = 0;
	m->wifi_popup.cursor_pos = 0;
	m->wifi_popup.button_hover = 0;
	m->wifi_popup.visible = 1;

	wifi_popup_render(m);

	/* Show on-screen keyboard in HTPC mode */
	if (htpc_mode_active)
		osk_show(m, NULL);
}

static void
wifi_popup_render(Monitor *m)
{
	WifiPasswordPopup *p;
	struct wlr_scene_node *node, *tmp;
	int padding = 20;
	int input_width = 300;
	int input_height;
	int button_width = 120;
	int button_height;
	int title_width = 0;
	int total_width, total_height;
	int center_x, center_y;
	char title[256];
	const char *btn_text;
	int line_spacing = 10;

	if (!m || !m->wifi_popup.tree)
		return;

	p = &m->wifi_popup;

	/* Set button text based on state */
	if (p->connecting)
		btn_text = "Connecting...";
	else if (p->error)
		btn_text = "Retry";
	else
		btn_text = "Connect";

	/* Clear previous content */
	wl_list_for_each_safe(node, tmp, &p->tree->children, link) {
		if (p->bg && node == &p->bg->node)
			continue;
		wlr_scene_node_destroy(node);
	}

	if (!p->visible || !statusfont.font) {
		wlr_scene_node_set_enabled(&p->tree->node, 0);
		return;
	}

	input_height = statusfont.height + 12;
	button_height = statusfont.height + 10;

	snprintf(title, sizeof(title), "Wifi Passphrase:");

	/* Compute title width */
	{
		int pen_x = 0;
		uint32_t prev_cp = 0;
		for (size_t i = 0; title[i]; i++) {
			long kern_x = 0, kern_y = 0;
			uint32_t cp = (unsigned char)title[i];
			const struct fcft_glyph *glyph;
			if (prev_cp)
				fcft_kerning(statusfont.font, prev_cp, cp, &kern_x, &kern_y);
			pen_x += (int)kern_x;
			glyph = fcft_rasterize_char_utf32(statusfont.font, cp, statusbar_font_subpixel);
			if (glyph)
				pen_x += glyph->advance.x;
			if (title[i + 1])
				pen_x += statusbar_font_spacing;
			prev_cp = cp;
		}
		title_width = pen_x;
	}

	total_width = MAX(input_width, title_width) + 2 * padding;
	total_height = statusfont.height + line_spacing + input_height + line_spacing + button_height + 2 * padding;

	p->width = total_width;
	p->height = total_height;

	/* Center on monitor */
	center_x = m->m.x + (m->m.width - total_width) / 2;
	center_y = m->m.y + (m->m.height - total_height) / 2;

	wlr_scene_node_set_position(&p->tree->node, center_x, center_y);

	/* Background */
	if (!p->bg)
		p->bg = wlr_scene_tree_create(p->tree);
	if (p->bg) {
		wl_list_for_each_safe(node, tmp, &p->bg->children, link)
			wlr_scene_node_destroy(node);
		wlr_scene_node_set_position(&p->bg->node, 0, 0);
		drawrect(p->bg, 0, 0, total_width, total_height, statusbar_popup_bg);
		/* Border */
		float border_col[4] = {0.3f, 0.3f, 0.3f, 1.0f};
		drawrect(p->bg, 0, 0, total_width, 1, border_col);
		drawrect(p->bg, 0, total_height - 1, total_width, 1, border_col);
		drawrect(p->bg, 0, 0, 1, total_height, border_col);
		drawrect(p->bg, total_width - 1, 0, 1, total_height, border_col);
	}

	/* Draw title */
	{
		int origin_x = padding + (total_width - 2 * padding - title_width) / 2;
		int origin_y = padding + statusfont.ascent;
		int pen_x = 0;
		uint32_t prev_cp = 0;

		for (size_t i = 0; title[i]; i++) {
			long kern_x = 0, kern_y = 0;
			uint32_t cp = (unsigned char)title[i];
			const struct fcft_glyph *glyph;
			struct wlr_buffer *buffer;
			struct wlr_scene_buffer *scene_buf;

			if (prev_cp)
				fcft_kerning(statusfont.font, prev_cp, cp, &kern_x, &kern_y);
			pen_x += (int)kern_x;

			glyph = fcft_rasterize_char_utf32(statusfont.font, cp, statusbar_font_subpixel);
			if (!glyph || !glyph->pix) {
				prev_cp = cp;
				continue;
			}

			buffer = statusbar_buffer_from_glyph(glyph);
			if (buffer) {
				scene_buf = wlr_scene_buffer_create(p->tree, NULL);
				if (scene_buf) {
					wlr_scene_buffer_set_buffer(scene_buf, buffer);
					wlr_scene_node_set_position(&scene_buf->node,
						origin_x + pen_x + glyph->x,
						origin_y - glyph->y);
				}
				wlr_buffer_drop(buffer);
			}
			pen_x += glyph->advance.x;
			if (title[i + 1])
				pen_x += statusbar_font_spacing;
			prev_cp = cp;
		}
	}

	/* Draw input box */
	{
		int input_x = padding;
		int input_y = padding + statusfont.height + line_spacing;
		float input_bg[4] = {0.1f, 0.1f, 0.1f, 1.0f};
		float input_border[4] = {0.4f, 0.4f, 0.4f, 1.0f};
		float error_border[4] = {0.8f, 0.2f, 0.2f, 1.0f};
		float *border = p->error ? error_border : input_border;

		drawrect(p->tree, input_x, input_y, input_width, input_height, input_bg);
		drawrect(p->tree, input_x, input_y, input_width, 1, border);
		drawrect(p->tree, input_x, input_y + input_height - 1, input_width, 1, border);
		drawrect(p->tree, input_x, input_y, 1, input_height, border);
		drawrect(p->tree, input_x + input_width - 1, input_y, 1, input_height, border);

		/* Draw password as dots */
		{
			int text_x = input_x + 6;
			int text_y = input_y + (input_height - statusfont.height) / 2 + statusfont.ascent;
			int pen_x = 0;

			for (int i = 0; i < p->password_len && i < (int)sizeof(p->password) - 1; i++) {
				const struct fcft_glyph *glyph = fcft_rasterize_char_utf32(
					statusfont.font, 0x2022 /* bullet */, statusbar_font_subpixel);
				if (!glyph)
					glyph = fcft_rasterize_char_utf32(statusfont.font, '*', statusbar_font_subpixel);
				if (glyph && glyph->pix) {
					struct wlr_buffer *buffer = statusbar_buffer_from_glyph(glyph);
					if (buffer) {
						struct wlr_scene_buffer *scene_buf = wlr_scene_buffer_create(p->tree, NULL);
						if (scene_buf) {
							wlr_scene_buffer_set_buffer(scene_buf, buffer);
							wlr_scene_node_set_position(&scene_buf->node,
								text_x + pen_x + glyph->x,
								text_y - glyph->y);
						}
						wlr_buffer_drop(buffer);
					}
					pen_x += glyph->advance.x + statusbar_font_spacing;
				}
			}

			/* Draw cursor */
			float cursor_col[4] = {1.0f, 1.0f, 1.0f, 1.0f};
			drawrect(p->tree, text_x + pen_x, input_y + 4, 2, input_height - 8, cursor_col);
		}
	}

	/* Draw connect button */
	{
		int btn_x = padding + (input_width - button_width) / 2;
		int btn_y = padding + statusfont.height + line_spacing + input_height + line_spacing;
		float btn_bg[4] = {0.2f, 0.4f, 0.6f, 1.0f};
		float btn_hover_bg[4] = {0.3f, 0.5f, 0.7f, 1.0f};

		if (p->button_hover)
			drawrect(p->tree, btn_x, btn_y, button_width, button_height, btn_hover_bg);
		else
			drawrect(p->tree, btn_x, btn_y, button_width, button_height, btn_bg);

		/* Center button text */
		int btn_text_width = 0;
		{
			int pen_x = 0;
			uint32_t prev_cp = 0;
			for (size_t i = 0; btn_text[i]; i++) {
				long kern_x = 0, kern_y = 0;
				uint32_t cp = (unsigned char)btn_text[i];
				const struct fcft_glyph *glyph;
				if (prev_cp)
					fcft_kerning(statusfont.font, prev_cp, cp, &kern_x, &kern_y);
				pen_x += (int)kern_x;
				glyph = fcft_rasterize_char_utf32(statusfont.font, cp, statusbar_font_subpixel);
				if (glyph)
					pen_x += glyph->advance.x;
				if (btn_text[i + 1])
					pen_x += statusbar_font_spacing;
				prev_cp = cp;
			}
			btn_text_width = pen_x;
		}

		int text_x = btn_x + (button_width - btn_text_width) / 2;
		int text_y = btn_y + (button_height - statusfont.height) / 2 + statusfont.ascent;
		int pen_x = 0;
		uint32_t prev_cp = 0;

		for (size_t i = 0; btn_text[i]; i++) {
			long kern_x = 0, kern_y = 0;
			uint32_t cp = (unsigned char)btn_text[i];
			const struct fcft_glyph *glyph;
			struct wlr_buffer *buffer;
			struct wlr_scene_buffer *scene_buf;

			if (prev_cp)
				fcft_kerning(statusfont.font, prev_cp, cp, &kern_x, &kern_y);
			pen_x += (int)kern_x;

			glyph = fcft_rasterize_char_utf32(statusfont.font, cp, statusbar_font_subpixel);
			if (!glyph || !glyph->pix) {
				prev_cp = cp;
				continue;
			}

			buffer = statusbar_buffer_from_glyph(glyph);
			if (buffer) {
				scene_buf = wlr_scene_buffer_create(p->tree, NULL);
				if (scene_buf) {
					wlr_scene_buffer_set_buffer(scene_buf, buffer);
					wlr_scene_node_set_position(&scene_buf->node,
						text_x + pen_x + glyph->x,
						text_y - glyph->y);
				}
				wlr_buffer_drop(buffer);
			}
			pen_x += glyph->advance.x;
			if (btn_text[i + 1])
				pen_x += statusbar_font_spacing;
			prev_cp = cp;
		}
	}

	wlr_scene_node_set_enabled(&p->tree->node, 1);
}

static int
wifi_popup_handle_key(Monitor *m, uint32_t mods, xkb_keysym_t sym)
{
	WifiPasswordPopup *p;

	if (!m || !m->wifi_popup.visible)
		return 0;

	p = &m->wifi_popup;

	if (sym == XKB_KEY_Escape) {
		wifi_popup_hide_all();
		return 1;
	}

	if (sym == XKB_KEY_Return || sym == XKB_KEY_KP_Enter) {
		if (!p->connecting && p->password_len > 0) {
			wifi_popup_connect(m);
		}
		return 1;
	}

	/* Don't allow editing while connecting */
	if (p->connecting)
		return 1;

	if (sym == XKB_KEY_BackSpace && p->password_len > 0) {
		p->password_len--;
		p->password[p->password_len] = '\0';
		p->error = 0;  /* Clear error on edit */
		wifi_popup_render(m);
		return 1;
	}

	/* Handle printable characters
	 * Allow Ctrl+Alt (AltGr) combinations - on many systems AltGr is Ctrl+Alt
	 * Only block Ctrl without Alt (real Ctrl shortcuts) and Logo key */
	{
		int is_altgr = (mods & WLR_MODIFIER_CTRL) && (mods & WLR_MODIFIER_ALT);
		int is_ctrl_only = (mods & WLR_MODIFIER_CTRL) && !is_altgr;
		char ch = 0;

		/* Handle numpad digits (XKB_KEY_KP_0 to XKB_KEY_KP_9) */
		if (sym >= XKB_KEY_KP_0 && sym <= XKB_KEY_KP_9) {
			ch = '0' + (sym - XKB_KEY_KP_0);
		}
		/* Handle other numpad keys */
		else if (sym == XKB_KEY_KP_Space) ch = ' ';
		else if (sym == XKB_KEY_KP_Multiply) ch = '*';
		else if (sym == XKB_KEY_KP_Add) ch = '+';
		else if (sym == XKB_KEY_KP_Subtract) ch = '-';
		else if (sym == XKB_KEY_KP_Decimal) ch = '.';
		else if (sym == XKB_KEY_KP_Divide) ch = '/';
		else if (sym == XKB_KEY_KP_Equal) ch = '=';
		/* Handle regular printable ASCII */
		else if (sym >= 0x20 && sym <= 0x7e && !is_ctrl_only && !(mods & WLR_MODIFIER_LOGO)) {
			ch = (char)sym;
		}

		if (ch && p->password_len + 1 < (int)sizeof(p->password)) {
			p->password[p->password_len] = ch;
			p->password_len++;
			p->password[p->password_len] = '\0';
			p->error = 0;  /* Clear error on edit */
			wifi_popup_render(m);
			return 1;
		}
	}

	return 1; /* Consume all keys while popup is open */
}

static int
wifi_popup_handle_click(Monitor *m, int lx, int ly, uint32_t button)
{
	WifiPasswordPopup *p;
	int popup_x, popup_y;
	int padding = 20;
	int input_width = 300;
	int button_width = 120;
	int button_height;
	int input_height;
	int line_spacing = 10;

	if (!m || !m->wifi_popup.visible)
		return 0;

	p = &m->wifi_popup;

	input_height = statusfont.height + 12;
	button_height = statusfont.height + 10;

	popup_x = m->m.x + (m->m.width - p->width) / 2;
	popup_y = m->m.y + (m->m.height - p->height) / 2;

	/* Check if click is inside popup */
	if (lx < popup_x || lx >= popup_x + p->width ||
	    ly < popup_y || ly >= popup_y + p->height) {
		if (!p->connecting)
			wifi_popup_hide_all();
		return 1;
	}

	/* Check button click */
	if (button == BTN_LEFT && !p->connecting) {
		int btn_x = popup_x + padding + (input_width - button_width) / 2;
		int btn_y = popup_y + padding + statusfont.height + line_spacing + input_height + line_spacing;

		if (lx >= btn_x && lx < btn_x + button_width &&
		    ly >= btn_y && ly < btn_y + button_height) {
			if (p->password_len > 0) {
				wifi_popup_connect(m);
			}
			return 1;
		}
	}

	return 1;
}

/* Sudo password popup functions */
static Monitor *
sudo_popup_visible_monitor(void)
{
	Monitor *m;
	wl_list_for_each(m, &mons, link) {
		if (m->sudo_popup.visible)
			return m;
	}
	return NULL;
}

static void
sudo_popup_hide(Monitor *m)
{
	if (!m)
		return;
	m->sudo_popup.visible = 0;
	m->sudo_popup.password[0] = '\0';
	m->sudo_popup.password_len = 0;
	m->sudo_popup.cursor_pos = 0;
	m->sudo_popup.error = 0;
	m->sudo_popup.running = 0;
	if (m->sudo_popup.wait_timer) {
		wl_event_source_remove(m->sudo_popup.wait_timer);
		m->sudo_popup.wait_timer = NULL;
	}
	if (m->sudo_popup.tree)
		wlr_scene_node_set_enabled(&m->sudo_popup.tree->node, 0);
	/* Also hide on-screen keyboard */
	osk_hide(m);
}

static void
sudo_popup_hide_all(void)
{
	Monitor *m;
	wl_list_for_each(m, &mons, link)
		sudo_popup_hide(m);
}

static void
sudo_popup_render(Monitor *m)
{
	SudoPopup *p;
	struct wlr_scene_node *node, *tmp;
	int padding = 20;
	int input_width = 300;
	int input_height;
	int button_width = 100;
	int button_height;
	int title_width = 0;
	int total_width, total_height;
	int center_x, center_y;
	const char *btn_text;
	int line_spacing = 10;

	if (!m || !m->sudo_popup.tree)
		return;

	p = &m->sudo_popup;

	/* Set button text based on state */
	if (p->running)
		btn_text = "Running...";
	else if (p->error)
		btn_text = "Retry";
	else
		btn_text = "OK";

	/* Clear previous content */
	wl_list_for_each_safe(node, tmp, &p->tree->children, link) {
		if (p->bg && node == &p->bg->node)
			continue;
		wlr_scene_node_destroy(node);
	}

	if (!p->visible || !statusfont.font) {
		wlr_scene_node_set_enabled(&p->tree->node, 0);
		return;
	}

	/* Calculate sizes */
	title_width = status_text_width(p->title);
	input_height = statusfont.height + 12;
	button_height = statusfont.height + 10;

	total_width = input_width + padding * 2;
	if (title_width + padding * 2 > total_width)
		total_width = title_width + padding * 2;

	total_height = padding + statusfont.height + line_spacing +
	               input_height + line_spacing + button_height + padding;

	p->width = total_width;
	p->height = total_height;

	center_x = m->m.x + (m->m.width - total_width) / 2;
	center_y = m->m.y + (m->m.height - total_height) / 2;

	wlr_scene_node_set_position(&p->tree->node, center_x, center_y);

	/* Draw background */
	if (p->bg) {
		wl_list_for_each_safe(node, tmp, &p->bg->children, link)
			wlr_scene_node_destroy(node);
		drawrect(p->bg, 0, 0, total_width, total_height, statusbar_popup_bg);
		/* Border */
		const float border[4] = {0.3f, 0.3f, 0.3f, 1.0f};
		drawrect(p->bg, 0, 0, total_width, 1, border);
		drawrect(p->bg, 0, total_height - 1, total_width, 1, border);
		drawrect(p->bg, 0, 0, 1, total_height, border);
		drawrect(p->bg, total_width - 1, 0, 1, total_height, border);
	}

	/* Draw title */
	{
		struct wlr_scene_tree *title_tree = wlr_scene_tree_create(p->tree);
		if (title_tree) {
			StatusModule mod = {0};
			int title_x = (total_width - title_width) / 2;
			wlr_scene_node_set_position(&title_tree->node, title_x, padding);
			mod.tree = title_tree;
			tray_render_label(&mod, p->title, 0, statusfont.height, statusbar_fg);
		}
	}

	/* Draw password input field */
	{
		struct wlr_scene_tree *input_tree = wlr_scene_tree_create(p->tree);
		if (input_tree) {
			const float input_bg[4] = {0.1f, 0.1f, 0.1f, 0.8f};
			const float input_border[4] = {0.4f, 0.4f, 0.4f, 1.0f};
			int input_x = padding;
			int input_y = padding + statusfont.height + line_spacing;
			StatusModule mod = {0};
			char masked[257];
			int i;

			wlr_scene_node_set_position(&input_tree->node, input_x, input_y);

			/* Input background */
			drawrect(input_tree, 0, 0, input_width, input_height, input_bg);
			drawrect(input_tree, 0, 0, input_width, 1, input_border);
			drawrect(input_tree, 0, input_height - 1, input_width, 1, input_border);
			drawrect(input_tree, 0, 0, 1, input_height, input_border);
			drawrect(input_tree, input_width - 1, 0, 1, input_height, input_border);

			/* Masked password (show dots) */
			for (i = 0; i < p->password_len && i < 256; i++)
				masked[i] = '*';
			masked[i] = '\0';

			mod.tree = input_tree;
			tray_render_label(&mod, masked, 6, input_height, statusbar_fg);

			/* Draw cursor */
			if (!p->running) {
				int cursor_x = 6 + status_text_width(masked);
				const float cursor_color[4] = {1.0f, 1.0f, 1.0f, 0.8f};
				drawrect(input_tree, cursor_x, 4, 2, input_height - 8, cursor_color);
			}
		}
	}

	/* Draw OK button */
	{
		struct wlr_scene_tree *btn_tree = wlr_scene_tree_create(p->tree);
		if (btn_tree) {
			const float btn_bg[4] = {0.2f, 0.4f, 0.6f, 1.0f};
			const float btn_hover_bg[4] = {0.3f, 0.5f, 0.7f, 1.0f};
			int btn_x = padding + (input_width - button_width) / 2;
			int btn_y = padding + statusfont.height + line_spacing + input_height + line_spacing;
			int btn_text_w = status_text_width(btn_text);
			StatusModule mod = {0};

			wlr_scene_node_set_position(&btn_tree->node, btn_x, btn_y);

			drawrect(btn_tree, 0, 0, button_width, button_height,
			         p->button_hover ? btn_hover_bg : btn_bg);

			mod.tree = btn_tree;
			tray_render_label(&mod, btn_text, (button_width - btn_text_w) / 2,
			                  button_height, statusbar_fg);
		}
	}

	/* Show error message if auth failed */
	if (p->error) {
		struct wlr_scene_tree *err_tree = wlr_scene_tree_create(p->tree);
		if (err_tree) {
			const char *err_msg = "Authentication failed";
			const float err_color[4] = {1.0f, 0.3f, 0.3f, 1.0f};
			int err_w = status_text_width(err_msg);
			StatusModule mod = {0};

			wlr_scene_node_set_position(&err_tree->node,
			                            (total_width - err_w) / 2,
			                            total_height - padding + 2);
			mod.tree = err_tree;
			tray_render_label(&mod, err_msg, 0, statusfont.height, err_color);
		}
	}

	wlr_scene_node_set_enabled(&p->tree->node, 1);
}

static int
sudo_popup_wait_timer(void *data)
{
	Monitor *m = data;
	SudoPopup *p;
	int status = 0;
	pid_t result;

	if (!m)
		return 0;

	p = &m->sudo_popup;

	if (p->sudo_pid <= 0) {
		/* No child to wait for */
		if (p->wait_timer) {
			wl_event_source_remove(p->wait_timer);
			p->wait_timer = NULL;
		}
		return 0;
	}

	/* Non-blocking check if child has exited */
	result = waitpid(p->sudo_pid, &status, WNOHANG);
	if (result == 0) {
		/* Child still running, re-arm timer to check again in 100ms */
		if (p->wait_timer)
			wl_event_source_timer_update(p->wait_timer, 100);
		return 0;
	}

	/* Child has exited (result > 0) or error (result < 0) */
	p->sudo_pid = -1;

	/* Remove timer */
	if (p->wait_timer) {
		wl_event_source_remove(p->wait_timer);
		p->wait_timer = NULL;
	}

	p->running = 0;
	if (result > 0 && WIFEXITED(status) && WEXITSTATUS(status) == 0) {
		/* Success */
		char toast_msg[256];
		snprintf(toast_msg, sizeof(toast_msg), "%s installed", p->pending_pkg);
		toast_show(m, toast_msg, 4000);
		sudo_popup_hide_all();
		/* Reload desktop entries to pick up new applications */
		desktop_entries_loaded = 0;
		desktop_entry_count = 0;
	} else {
		/* Auth failed or error - show popup again with error message */
		p->error = 1;
		p->password[0] = '\0';
		p->password_len = 0;
		p->cursor_pos = 0;
		p->visible = 1;
		toast_show(m, "Authentication failed", 3000);
		sudo_popup_render(m);
	}
	return 0;
}

static int
sudo_popup_cb(int fd, uint32_t mask, void *data)
{
	Monitor *m = data;
	SudoPopup *p;
	char buf[256];
	ssize_t n;

	if (!m)
		return 0;

	p = &m->sudo_popup;

	/* Read any available output (non-blocking since fd triggers the callback) */
	for (;;) {
		n = read(fd, buf, sizeof(buf) - 1);
		if (n <= 0)
			break;
		buf[n] = '\0';
		wlr_log(WLR_DEBUG, "sudo output: %s", buf);
	}

	/* Clean up event source for fd */
	if (p->sudo_event) {
		wl_event_source_remove(p->sudo_event);
		p->sudo_event = NULL;
	}
	if (p->sudo_fd >= 0) {
		close(p->sudo_fd);
		p->sudo_fd = -1;
	}

	/* Start a timer to poll for child exit instead of blocking */
	if (p->sudo_pid > 0 && !p->wait_timer) {
		p->wait_timer = wl_event_loop_add_timer(event_loop,
			sudo_popup_wait_timer, m);
		if (p->wait_timer)
			wl_event_source_timer_update(p->wait_timer, 100); /* Check every 100ms */
	}

	return 0;
}

static void
sudo_popup_execute(Monitor *m)
{
	SudoPopup *p;
	int pipefd[2];
	pid_t pid;

	if (!m)
		return;

	p = &m->sudo_popup;

	if (p->password_len == 0 || p->running)
		return;

	if (pipe(pipefd) < 0) {
		wlr_log(WLR_ERROR, "Failed to create pipe for sudo");
		return;
	}

	pid = fork();
	if (pid < 0) {
		close(pipefd[0]);
		close(pipefd[1]);
		return;
	}

	if (pid == 0) {
		/* Child process */
		close(pipefd[0]);
		dup2(pipefd[1], STDOUT_FILENO);
		dup2(pipefd[1], STDERR_FILENO);
		close(pipefd[1]);
		setsid();

		/* Run command with sudo -S (read password from stdin)
		 * Use printf %s to safely pass password without shell interpretation */
		char cmd[2048];
		snprintf(cmd, sizeof(cmd), "printf '%%s\\n' \"$SUDO_PASS\" | sudo -S sh -c '%s' 2>&1",
		         p->pending_cmd);
		setenv("SUDO_PASS", p->password, 1);
		execl("/bin/sh", "sh", "-c", cmd, NULL);
		_exit(127);
	}

	/* Parent */
	close(pipefd[1]);

	/* Set pipe to non-blocking to prevent freezing the compositor */
	fcntl(pipefd[0], F_SETFL, fcntl(pipefd[0], F_GETFL) | O_NONBLOCK);

	p->sudo_pid = pid;
	p->sudo_fd = pipefd[0];
	p->running = 1;
	p->error = 0;

	/* Set up event handler for reading output */
	p->sudo_event = wl_event_loop_add_fd(event_loop, pipefd[0],
	                                      WL_EVENT_READABLE,
	                                      sudo_popup_cb, m);

	/* Show "Installing..." toast */
	{
		char toast_msg[256];
		snprintf(toast_msg, sizeof(toast_msg), "Installing %s...", p->pending_pkg);
		toast_show(m, toast_msg, 60000); /* Long timeout, will be replaced on completion */
	}

	/* Hide popup immediately - installation runs in background */
	p->visible = 0;
	if (p->tree)
		wlr_scene_node_set_enabled(&p->tree->node, 0);
}

static int
sudo_popup_handle_key(Monitor *m, uint32_t mods, xkb_keysym_t sym)
{
	SudoPopup *p;
	char buf[8];
	int len;

	if (!m || !m->sudo_popup.visible)
		return 0;

	p = &m->sudo_popup;

	/* Don't accept input while running */
	if (p->running)
		return 1;

	/* Escape to close */
	if (sym == XKB_KEY_Escape) {
		sudo_popup_hide_all();
		return 1;
	}

	/* Enter to submit */
	if (sym == XKB_KEY_Return || sym == XKB_KEY_KP_Enter) {
		if (p->password_len > 0)
			sudo_popup_execute(m);
		return 1;
	}

	/* Backspace */
	if (sym == XKB_KEY_BackSpace) {
		if (p->password_len > 0) {
			p->password_len--;
			p->password[p->password_len] = '\0';
			sudo_popup_render(m);
		}
		return 1;
	}

	/* Regular character input */
	len = xkb_keysym_to_utf8(sym, buf, sizeof(buf));
	if (len > 0 && len < (int)sizeof(buf) && buf[0] >= 32 && buf[0] < 127) {
		if (p->password_len < (int)sizeof(p->password) - 1) {
			p->password[p->password_len++] = buf[0];
			p->password[p->password_len] = '\0';
			sudo_popup_render(m);
		}
		return 1;
	}

	return 1;
}

static void
sudo_popup_show(Monitor *m, const char *title, const char *cmd, const char *pkg_name)
{
	if (!m || !cmd)
		return;

	sudo_popup_hide_all();

	snprintf(m->sudo_popup.title, sizeof(m->sudo_popup.title), "%s",
	         title ? title : "sudo:");
	snprintf(m->sudo_popup.pending_cmd, sizeof(m->sudo_popup.pending_cmd), "%s", cmd);
	snprintf(m->sudo_popup.pending_pkg, sizeof(m->sudo_popup.pending_pkg), "%s",
	         pkg_name ? pkg_name : "package");

	m->sudo_popup.password[0] = '\0';
	m->sudo_popup.password_len = 0;
	m->sudo_popup.cursor_pos = 0;
	m->sudo_popup.button_hover = 0;
	m->sudo_popup.error = 0;
	m->sudo_popup.running = 0;
	m->sudo_popup.visible = 1;

	sudo_popup_render(m);

	/* Show on-screen keyboard in HTPC mode */
	if (htpc_mode_active)
		osk_show(m, NULL);
}

/* ==================== ON-SCREEN KEYBOARD ==================== */

/* Keyboard layout - Norwegian QWERTY with special characters */
static const char *osk_layout_lower[OSK_ROWS][OSK_COLS] = {
	{"1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "+", "\\"},
	{"q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "", ""},
	{"a", "s", "d", "f", "g", "h", "j", "k", "l", "", "", "'"},
	{"<", "z", "x", "c", "v", "b", "n", "m", ",", ".", "-", ""},
	{"", "@", "#", " ", " ", " ", " ", " ", "?", "!", "", ""},
};

static const char *osk_layout_upper[OSK_ROWS][OSK_COLS] = {
	{"!", "\"", "#", "", "%", "&", "/", "(", ")", "=", "?", "`"},
	{"Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P", "", "^"},
	{"A", "S", "D", "F", "G", "H", "J", "K", "L", "", "", "*"},
	{">", "Z", "X", "C", "V", "B", "N", "M", ";", ":", "_", ""},
	{"", "@", "#", " ", " ", " ", " ", " ", "?", "!", "", ""},
};

static Monitor *
osk_visible_monitor(void)
{
	Monitor *m;
	wl_list_for_each(m, &mons, link) {
		if (m->osk.visible)
			return m;
	}
	return NULL;
}

static void
osk_hide(Monitor *m)
{
	if (!m || !m->osk.tree)
		return;

	m->osk.visible = 0;
	wlr_scene_node_set_enabled(&m->osk.tree->node, 0);
	m->osk.target_surface = NULL;
}

static void
osk_hide_all(void)
{
	Monitor *m;
	wl_list_for_each(m, &mons, link) {
		osk_hide(m);
	}
}

static void
osk_render(Monitor *m)
{
	OnScreenKeyboard *osk;
	struct wlr_scene_node *node, *tmp;
	int key_width = 60;
	int key_height = 50;
	int key_spacing = 4;
	int padding = 10;
	int total_width, total_height;
	int start_x, start_y;
	const char *(*layout)[OSK_COLS];

	if (!m || !m->osk.tree)
		return;

	osk = &m->osk;

	/* Clear previous content */
	wl_list_for_each_safe(node, tmp, &osk->tree->children, link) {
		if (osk->bg && node == &osk->bg->node)
			continue;
		wlr_scene_node_destroy(node);
	}

	if (!osk->visible || !statusfont.font) {
		wlr_scene_node_set_enabled(&osk->tree->node, 0);
		return;
	}

	/* Select layout based on shift state */
	layout = (osk->shift_active || osk->caps_lock) ? osk_layout_upper : osk_layout_lower;

	total_width = OSK_COLS * (key_width + key_spacing) - key_spacing + 2 * padding;
	total_height = OSK_ROWS * (key_height + key_spacing) - key_spacing + 2 * padding;

	osk->width = total_width;
	osk->height = total_height;

	/* Position at bottom center of monitor */
	start_x = m->m.x + (m->m.width - total_width) / 2;
	start_y = m->m.y + m->m.height - total_height - 20;

	wlr_scene_node_set_position(&osk->tree->node, start_x, start_y);

	/* Background */
	if (!osk->bg)
		osk->bg = wlr_scene_tree_create(osk->tree);
	if (osk->bg) {
		wl_list_for_each_safe(node, tmp, &osk->bg->children, link)
			wlr_scene_node_destroy(node);
		wlr_scene_node_set_position(&osk->bg->node, 0, 0);
		float bg_color[4] = {0.1f, 0.1f, 0.12f, 0.95f};
		drawrect(osk->bg, 0, 0, total_width, total_height, bg_color);
		/* Border */
		float border_col[4] = {0.3f, 0.3f, 0.35f, 1.0f};
		drawrect(osk->bg, 0, 0, total_width, 2, border_col);
	}

	/* Draw keys */
	for (int row = 0; row < OSK_ROWS; row++) {
		for (int col = 0; col < OSK_COLS; col++) {
			int key_x = padding + col * (key_width + key_spacing);
			int key_y = padding + row * (key_height + key_spacing);
			const char *label = layout[row][col];
			int is_selected = (row == osk->sel_row && col == osk->sel_col);
			int is_special = 0;
			int actual_width = key_width;

			/* Check for special keys */
			if (strcmp(label, "") == 0 || strcmp(label, "") == 0 ||
			    strcmp(label, "") == 0) {
				is_special = 1;
			}

			/* Space bar spans multiple keys */
			if (row == 4 && col >= 3 && col <= 7) {
				if (col == 3) {
					actual_width = 5 * (key_width + key_spacing) - key_spacing;
				} else {
					continue; /* Skip cells covered by space bar */
				}
			}

			/* Enter key spans 2 columns */
			if (row == 4 && col == 11) {
				continue; /* Already drawn at col 10 */
			}
			if (row == 4 && col == 10) {
				actual_width = 2 * (key_width + key_spacing) - key_spacing;
			}

			/* Key background */
			float key_bg[4];
			if (is_selected) {
				key_bg[0] = 0.3f; key_bg[1] = 0.5f; key_bg[2] = 0.8f; key_bg[3] = 1.0f;
			} else if (is_special) {
				key_bg[0] = 0.25f; key_bg[1] = 0.25f; key_bg[2] = 0.3f; key_bg[3] = 1.0f;
			} else {
				key_bg[0] = 0.2f; key_bg[1] = 0.2f; key_bg[2] = 0.22f; key_bg[3] = 1.0f;
			}

			/* Highlight shift key when active */
			if (strcmp(label, "") == 0 && (osk->shift_active || osk->caps_lock)) {
				key_bg[0] = 0.4f; key_bg[1] = 0.6f; key_bg[2] = 0.3f; key_bg[3] = 1.0f;
			}

			drawrect(osk->tree, key_x, key_y, actual_width, key_height, key_bg);

			/* Key border */
			float key_border[4] = {0.35f, 0.35f, 0.4f, 1.0f};
			drawrect(osk->tree, key_x, key_y, actual_width, 1, key_border);
			drawrect(osk->tree, key_x, key_y + key_height - 1, actual_width, 1, key_border);
			drawrect(osk->tree, key_x, key_y, 1, key_height, key_border);
			drawrect(osk->tree, key_x + actual_width - 1, key_y, 1, key_height, key_border);

			/* Draw label */
			const char *display_label = label;
			if (row == 4 && col == 3) display_label = "SPACE";

			int text_width = 0;
			int pen_x = 0;
			uint32_t prev_cp = 0;

			/* Calculate text width */
			const char *p = display_label;
			while (*p) {
				uint32_t cp;
				int bytes = 1;
				if ((*p & 0x80) == 0) {
					cp = *p;
				} else if ((*p & 0xE0) == 0xC0) {
					cp = (*p & 0x1F) << 6 | (*(p+1) & 0x3F);
					bytes = 2;
				} else if ((*p & 0xF0) == 0xE0) {
					cp = (*p & 0x0F) << 12 | (*(p+1) & 0x3F) << 6 | (*(p+2) & 0x3F);
					bytes = 3;
				} else {
					cp = '?';
				}
				const struct fcft_glyph *glyph = fcft_rasterize_char_utf32(statusfont.font, cp, statusbar_font_subpixel);
				if (glyph)
					text_width += glyph->advance.x;
				p += bytes;
			}

			/* Draw centered text */
			int text_x = key_x + (actual_width - text_width) / 2;
			int text_y = key_y + (key_height + statusfont.height) / 2 - statusfont.descent;

			p = display_label;
			pen_x = 0;
			prev_cp = 0;
			while (*p) {
				uint32_t cp;
				int bytes = 1;
				if ((*p & 0x80) == 0) {
					cp = *p;
				} else if ((*p & 0xE0) == 0xC0) {
					cp = (*p & 0x1F) << 6 | (*(p+1) & 0x3F);
					bytes = 2;
				} else if ((*p & 0xF0) == 0xE0) {
					cp = (*p & 0x0F) << 12 | (*(p+1) & 0x3F) << 6 | (*(p+2) & 0x3F);
					bytes = 3;
				} else {
					cp = '?';
				}

				long kern_x = 0, kern_y = 0;
				if (prev_cp)
					fcft_kerning(statusfont.font, prev_cp, cp, &kern_x, &kern_y);
				pen_x += (int)kern_x;

				const struct fcft_glyph *glyph = fcft_rasterize_char_utf32(statusfont.font, cp, statusbar_font_subpixel);
				if (glyph && glyph->pix) {
					struct wlr_buffer *buffer = statusbar_buffer_from_glyph(glyph);
					if (buffer) {
						struct wlr_scene_buffer *scene_buf = wlr_scene_buffer_create(osk->tree, NULL);
						if (scene_buf) {
							wlr_scene_buffer_set_buffer(scene_buf, buffer);
							wlr_scene_node_set_position(&scene_buf->node,
								text_x + pen_x + glyph->x,
								text_y - glyph->y);
						}
						wlr_buffer_drop(buffer);
					}
				}
				if (glyph)
					pen_x += glyph->advance.x;
				prev_cp = cp;
				p += bytes;
			}
		}
	}

	wlr_scene_node_set_enabled(&osk->tree->node, 1);
	wlr_scene_node_raise_to_top(&osk->tree->node);
}

static void
osk_show(Monitor *m, struct wlr_surface *target)
{
	if (!m)
		return;

	/* Hide any existing OSK on other monitors */
	osk_hide_all();

	/* Create scene tree if needed */
	if (!m->osk.tree) {
		m->osk.tree = wlr_scene_tree_create(layers[LyrBlock]);
		if (!m->osk.tree)
			return;
	}

	m->osk.visible = 1;
	m->osk.sel_row = 2;  /* Start on middle row */
	m->osk.sel_col = 5;  /* Start in middle */
	m->osk.shift_active = 0;
	m->osk.caps_lock = 0;
	m->osk.target_surface = target;

	osk_render(m);
}

/* Send a Unicode character to the focused surface via wlr_seat */
static void
osk_send_text(const char *text)
{
	if (!text || !text[0])
		return;

	/* Use zwp_text_input or direct keyboard events */
	/* For now, we'll use xdotool-style key injection via uinput
	 * or the simpler approach of using wtype */

	/* Fork and use wtype to send text */
	pid_t pid = fork();
	if (pid == 0) {
		setsid();
		execlp("wtype", "wtype", text, (char *)NULL);
		/* Fallback: try ydotool */
		execlp("ydotool", "ydotool", "type", text, (char *)NULL);
		_exit(127);
	}
}

static void
osk_send_backspace(Monitor *m)
{
	(void)m;
	/* Send backspace using wtype */
	pid_t pid = fork();
	if (pid == 0) {
		setsid();
		execlp("wtype", "wtype", "-k", "BackSpace", (char *)NULL);
		_exit(127);
	}
}

static void
osk_send_key(Monitor *m)
{
	OnScreenKeyboard *osk;
	const char *(*layout)[OSK_COLS];
	const char *key;

	if (!m)
		return;

	osk = &m->osk;
	layout = (osk->shift_active || osk->caps_lock) ? osk_layout_upper : osk_layout_lower;
	key = layout[osk->sel_row][osk->sel_col];

	/* Handle special keys */
	if (strcmp(key, "") == 0) {
		/* Toggle shift */
		if (osk->shift_active) {
			osk->caps_lock = !osk->caps_lock;
			osk->shift_active = 0;
		} else {
			osk->shift_active = 1;
		}
		osk_render(m);
		return;
	}

	if (strcmp(key, "") == 0) {
		/* Backspace */
		osk_send_backspace(m);
		return;
	}

	if (strcmp(key, "") == 0) {
		/* Enter - send enter and optionally hide keyboard */
		pid_t pid = fork();
		if (pid == 0) {
			setsid();
			execlp("wtype", "wtype", "-k", "Return", (char *)NULL);
			_exit(127);
		}
		return;
	}

	/* Regular key */
	osk_send_text(key);

	/* Turn off shift after typing (unless caps lock) */
	if (osk->shift_active && !osk->caps_lock) {
		osk->shift_active = 0;
		osk_render(m);
	}
}

static int
osk_handle_button(Monitor *m, int button, int value)
{
	OnScreenKeyboard *osk;

	if (!m || !m->osk.visible)
		return 0;

	/* Only handle button press */
	if (value != 1)
		return 0;

	osk = &m->osk;

	switch (button) {
	case BTN_SOUTH:  /* A button - press selected key */
		osk_send_key(m);
		return 1;

	case BTN_EAST:   /* B button - backspace (delete last character) */
		osk_send_backspace(m);
		return 1;

	case BTN_WEST:   /* X button - toggle shift */
		osk->shift_active = !osk->shift_active;
		osk_render(m);
		return 1;

	case BTN_NORTH:  /* Y button - close keyboard */
		osk_hide(m);
		return 1;

	case BTN_START:  /* Start button - also close keyboard */
	case BTN_SELECT: /* Select button - also close keyboard */
		osk_hide(m);
		return 1;

	case BTN_DPAD_UP:
		if (osk->sel_row > 0) {
			osk->sel_row--;
			/* Skip cells covered by space bar */
			if (osk->sel_row == 4 && osk->sel_col >= 4 && osk->sel_col <= 7)
				osk->sel_col = 3;
			osk_render(m);
		}
		return 1;

	case BTN_DPAD_DOWN:
		if (osk->sel_row < OSK_ROWS - 1) {
			osk->sel_row++;
			/* Skip cells covered by space bar */
			if (osk->sel_row == 4 && osk->sel_col >= 4 && osk->sel_col <= 7)
				osk->sel_col = 3;
			osk_render(m);
		}
		return 1;

	case BTN_DPAD_LEFT:
		if (osk->sel_col > 0) {
			osk->sel_col--;
			/* Skip cells covered by space bar */
			if (osk->sel_row == 4 && osk->sel_col >= 4 && osk->sel_col <= 7)
				osk->sel_col = 3;
			/* Skip enter key duplicate */
			if (osk->sel_row == 4 && osk->sel_col == 11)
				osk->sel_col = 10;
			osk_render(m);
		}
		return 1;

	case BTN_DPAD_RIGHT:
		if (osk->sel_col < OSK_COLS - 1) {
			osk->sel_col++;
			/* Skip cells covered by space bar */
			if (osk->sel_row == 4 && osk->sel_col >= 4 && osk->sel_col <= 7)
				osk->sel_col = 8;
			/* Skip enter key duplicate */
			if (osk->sel_row == 4 && osk->sel_col == 11)
				osk->sel_col = 10;
			osk_render(m);
		}
		return 1;

	case BTN_TL:  /* Left bumper - move to start of row */
		osk->sel_col = 0;
		osk_render(m);
		return 1;

	case BTN_TR:  /* Right bumper - move to end of row */
		osk->sel_col = OSK_COLS - 1;
		if (osk->sel_row == 4)
			osk->sel_col = 10; /* Enter key */
		osk_render(m);
		return 1;
	}

	return 0;
}

/* OSK d-pad repeat timer callback - called repeatedly while d-pad is held */
static int
osk_dpad_repeat_cb(void *data)
{
	(void)data;

	/* Check if still valid */
	if (!osk_dpad_held_button || !osk_dpad_held_mon || !osk_dpad_held_mon->osk.visible) {
		osk_dpad_held_button = 0;
		osk_dpad_held_mon = NULL;
		return 0;
	}

	/* Try to move in the held direction */
	OnScreenKeyboard *osk = &osk_dpad_held_mon->osk;
	int old_row = osk->sel_row;
	int old_col = osk->sel_col;

	/* Call the button handler (it will move if possible) */
	osk_handle_button(osk_dpad_held_mon, osk_dpad_held_button, 1);

	/* If position changed, schedule next repeat */
	if (osk->sel_row != old_row || osk->sel_col != old_col) {
		if (osk_dpad_repeat_timer)
			wl_event_source_timer_update(osk_dpad_repeat_timer, OSK_DPAD_REPEAT_RATE);
	} else {
		/* Hit a wall - stop repeating */
		osk_dpad_held_button = 0;
		osk_dpad_held_mon = NULL;
	}

	return 0;
}

/* Start OSK d-pad repeat for a direction */
static void
osk_dpad_repeat_start(Monitor *m, int button)
{
	if (!m || !m->osk.visible)
		return;

	osk_dpad_held_button = button;
	osk_dpad_held_mon = m;

	/* Create timer if needed */
	if (!osk_dpad_repeat_timer) {
		osk_dpad_repeat_timer = wl_event_loop_add_timer(
			wl_display_get_event_loop(dpy), osk_dpad_repeat_cb, NULL);
	}

	/* Start with initial delay */
	if (osk_dpad_repeat_timer)
		wl_event_source_timer_update(osk_dpad_repeat_timer, OSK_DPAD_INITIAL_DELAY);
}

/* Stop OSK d-pad repeat */
static void
osk_dpad_repeat_stop(void)
{
	osk_dpad_held_button = 0;
	osk_dpad_held_mon = NULL;
	if (osk_dpad_repeat_timer)
		wl_event_source_timer_update(osk_dpad_repeat_timer, 0);
}

static void
wifi_networks_clear(void)
{
	WifiNetwork *n, *tmp;
	wl_list_for_each_safe(n, tmp, &wifi_networks, link) {
		wl_list_remove(&n->link);
		free(n);
	}
	wl_list_init(&wifi_networks);
}

static void
net_menu_hide_all(void)
{
	Monitor *m;
	int any_visible = 0;

	wl_list_for_each(m, &mons, link) {
		if (m->statusbar.net_menu.tree) {
			if (m->statusbar.net_menu.visible)
				any_visible = 1;
			wlr_scene_node_set_enabled(&m->statusbar.net_menu.tree->node, 0);
			m->statusbar.net_menu.visible = 0;
		}
		if (m->statusbar.net_menu.submenu_tree) {
			wlr_scene_node_set_enabled(&m->statusbar.net_menu.submenu_tree->node, 0);
			m->statusbar.net_menu.submenu_visible = 0;
		}
		m->statusbar.net_menu.hover = -1;
		m->statusbar.net_menu.submenu_hover = -1;
	}
	if (any_visible) {
		wifi_networks_accept_updates = 0;
		wifi_networks_freeze_existing = 0;
		wifi_networks_generation++;
		wifi_networks_clear();
	}
}

/* Transfer visible status menus to target monitor when mouse moves */
static void
transfer_status_menus(Monitor *from, Monitor *to)
{
	if (!from || !to || from == to)
		return;

	/* Transfer net_menu */
	if (from->statusbar.net_menu.visible && to->statusbar.net_menu.tree) {
		/* Hide on old monitor */
		wlr_scene_node_set_enabled(&from->statusbar.net_menu.tree->node, 0);
		from->statusbar.net_menu.visible = 0;
		if (from->statusbar.net_menu.submenu_tree) {
			wlr_scene_node_set_enabled(&from->statusbar.net_menu.submenu_tree->node, 0);
			from->statusbar.net_menu.submenu_visible = 0;
		}
		/* Show on new monitor */
		net_menu_render(to);
		if (from->statusbar.net_menu.submenu_visible)
			net_menu_submenu_render(to);
	}

	/* Transfer cpu_popup */
	if (from->statusbar.cpu_popup.visible && to->statusbar.cpu_popup.tree) {
		wlr_scene_node_set_enabled(&from->statusbar.cpu_popup.tree->node, 0);
		from->statusbar.cpu_popup.visible = 0;
		to->statusbar.cpu_popup.visible = 1;
		to->statusbar.cpu_popup.refresh_data = 1;
		rendercpupopup(to);
		wlr_scene_node_set_enabled(&to->statusbar.cpu_popup.tree->node, 1);
	}

	/* Transfer wifi_popup */
	if (from->wifi_popup.visible && to->wifi_popup.tree) {
		/* Copy popup state */
		memcpy(to->wifi_popup.ssid, from->wifi_popup.ssid, sizeof(to->wifi_popup.ssid));
		memcpy(to->wifi_popup.password, from->wifi_popup.password, sizeof(to->wifi_popup.password));
		to->wifi_popup.password_len = from->wifi_popup.password_len;
		to->wifi_popup.cursor_pos = from->wifi_popup.cursor_pos;
		to->wifi_popup.error = from->wifi_popup.error;
		/* Hide on old, show on new */
		wlr_scene_node_set_enabled(&from->wifi_popup.tree->node, 0);
		from->wifi_popup.visible = 0;
		to->wifi_popup.visible = 1;
		wifi_popup_render(to);
	}
}

static void
net_menu_render(Monitor *m)
{
	const char *wifi_label = "Available networks";
	const char *vpn_label = "VPN";
	int padding = statusbar_module_padding;
	int line_spacing = 4;
	int row_h;
	int wifi_text_w, vpn_text_w;
	int max_w;
	NetMenu *menu;
	struct wlr_scene_node *node, *tmp;
	float border_col[4] = {0, 0, 0, 1};
	int border_px = 1;
	int y;

	if (!m || !m->statusbar.net_menu.tree)
		return;
	menu = &m->statusbar.net_menu;

	wl_list_for_each_safe(node, tmp, &menu->tree->children, link) {
		if (menu->bg && node == &menu->bg->node)
			continue;
		wlr_scene_node_destroy(node);
	}

	if (!statusfont.font) {
		menu->width = menu->height = 0;
		wlr_scene_node_set_enabled(&menu->tree->node, 0);
		menu->visible = 0;
		return;
	}

	row_h = statusfont.height + line_spacing;
	if (row_h < statusfont.height)
		row_h = statusfont.height;
	wifi_text_w = status_text_width(wifi_label);
	vpn_text_w = status_text_width(vpn_label);
	max_w = (wifi_text_w > vpn_text_w ? wifi_text_w : vpn_text_w) + 2 * padding + row_h; /* space for arrow */
	menu->width = max_w;
	menu->height = 2 * row_h + 2 * padding; /* Two rows */

	if (!menu->bg && !(menu->bg = wlr_scene_tree_create(menu->tree)))
		return;
	wlr_scene_node_set_enabled(&menu->bg->node, 1);
	wlr_scene_node_set_position(&menu->bg->node, 0, 0);
	wl_list_for_each_safe(node, tmp, &menu->bg->children, link)
		wlr_scene_node_destroy(node);
	drawrect(menu->bg, 0, 0, menu->width, menu->height, net_menu_row_bg);
	drawrect(menu->bg, 0, 0, menu->width, border_px, border_col);
	drawrect(menu->bg, 0, menu->height - border_px, menu->width, border_px, border_col);
	drawrect(menu->bg, 0, 0, border_px, menu->height, border_col);
	drawrect(menu->bg, menu->width - border_px, 0, border_px, menu->height, border_col);

	/* Row 0: Available networks */
	y = padding;
	{
		char text[256];
		snprintf(text, sizeof(text), "%s  >", wifi_label);
		drawrect(menu->tree, padding, y, menu->width - 2 * padding, row_h,
				menu->hover == 0 ? net_menu_row_bg_hover : net_menu_row_bg);
		tray_menu_draw_text(menu->tree, text, padding + 4, y, row_h);
	}

	/* Row 1: VPN */
	y += row_h;
	{
		char text[256];
		snprintf(text, sizeof(text), "%s  >", vpn_label);
		drawrect(menu->tree, padding, y, menu->width - 2 * padding, row_h,
				menu->hover == 1 ? net_menu_row_bg_hover : net_menu_row_bg);
		tray_menu_draw_text(menu->tree, text, padding + 4, y, row_h);
	}

	menu->visible = 1;
	wlr_scene_node_set_enabled(&menu->tree->node, 1);
}

static void
net_menu_submenu_render(Monitor *m)
{
	NetMenu *menu;
	struct wlr_scene_node *node, *tmp;
	int padding = statusbar_module_padding;
	int line_spacing = 4;
	int row_h;
	int max_w = 0;
	int total_h = 0;
	int y;
	int count = 0;
	char line[256];
	float border_col[4] = {0, 0, 0, 1};
	int border_px = 1;

	if (!m || !m->statusbar.net_menu.submenu_tree)
		return;
	menu = &m->statusbar.net_menu;

	wl_list_for_each_safe(node, tmp, &menu->submenu_tree->children, link) {
		if (menu->submenu_bg && node == &menu->submenu_bg->node)
			continue;
		wlr_scene_node_destroy(node);
	}

	if (!statusfont.font) {
		wlr_scene_node_set_enabled(&menu->submenu_tree->node, 0);
		menu->submenu_visible = 0;
		return;
	}

	row_h = statusfont.height + line_spacing;
	if (row_h < statusfont.height)
		row_h = statusfont.height;

	/* Render based on submenu_type: 0 = WiFi, 1 = VPN */
	if (menu->submenu_type == 0) {
		/* WiFi submenu */
		WifiNetwork *n;
		if (wifi_scan_inflight && wl_list_empty(&wifi_networks)) {
			snprintf(line, sizeof(line), "Scanning...");
			max_w = status_text_width(line);
			total_h = row_h + 2 * padding;
		} else if (wl_list_empty(&wifi_networks)) {
			snprintf(line, sizeof(line), "No networks");
			max_w = status_text_width(line);
			total_h = row_h + 2 * padding;
		} else {
			wl_list_for_each(n, &wifi_networks, link) {
				int w;
				int is_connected = (net_ssid[0] && strcmp(n->ssid, net_ssid) == 0);
				count++;
				snprintf(line, sizeof(line), "%s (%d%%%s%s)", n->ssid, n->strength,
						n->secure ? ", secured" : "",
						is_connected ? ", Connected" : "");
				w = status_text_width(line);
				if (w > max_w)
					max_w = w;
			}
			total_h = padding * 2 + count * row_h;
		}
	} else {
		/* VPN submenu */
		VpnConnection *v;
		if (vpn_scan_inflight && wl_list_empty(&vpn_connections)) {
			snprintf(line, sizeof(line), "Loading...");
			max_w = status_text_width(line);
			total_h = row_h + 2 * padding;
		} else if (wl_list_empty(&vpn_connections)) {
			snprintf(line, sizeof(line), "No VPN connections");
			max_w = status_text_width(line);
			total_h = row_h + 2 * padding;
		} else {
			wl_list_for_each(v, &vpn_connections, link) {
				int w;
				count++;
				snprintf(line, sizeof(line), "%s%s", v->name,
						v->active ? " (Connected)" : "");
				w = status_text_width(line);
				if (w > max_w)
					max_w = w;
			}
			total_h = padding * 2 + count * row_h;
		}
	}

	if (max_w <= 0)
		max_w = 100;

	menu->submenu_width = max_w + 2 * padding;
	menu->submenu_height = total_h;

	if (!menu->submenu_bg && !(menu->submenu_bg = wlr_scene_tree_create(menu->submenu_tree)))
		return;
	wlr_scene_node_set_enabled(&menu->submenu_bg->node, 1);
	wlr_scene_node_set_position(&menu->submenu_bg->node, 0, 0);
	wl_list_for_each_safe(node, tmp, &menu->submenu_bg->children, link)
		wlr_scene_node_destroy(node);
	drawrect(menu->submenu_bg, 0, 0, menu->submenu_width, menu->submenu_height, net_menu_row_bg);
	drawrect(menu->submenu_bg, 0, 0, menu->submenu_width, border_px, border_col);
	drawrect(menu->submenu_bg, 0, menu->submenu_height - border_px, menu->submenu_width, border_px, border_col);
	drawrect(menu->submenu_bg, 0, 0, border_px, menu->submenu_height, border_col);
	drawrect(menu->submenu_bg, menu->submenu_width - border_px, 0, border_px, menu->submenu_height, border_col);

	y = padding;
	if (menu->submenu_type == 0) {
		/* WiFi items */
		if (wl_list_empty(&wifi_networks)) {
			drawrect(menu->submenu_tree, padding, y, menu->submenu_width - 2 * padding, row_h,
					net_menu_row_bg);
			tray_menu_draw_text(menu->submenu_tree, line, padding + 4, y, row_h);
		} else {
			WifiNetwork *n;
			int idx = 0;
			wl_list_for_each(n, &wifi_networks, link) {
				int x = padding;
				int hover = (menu->submenu_hover == idx);
				int is_connected = (net_ssid[0] && strcmp(n->ssid, net_ssid) == 0);
				snprintf(line, sizeof(line), "%s (%d%%%s%s)", n->ssid, n->strength,
						n->secure ? ", secured" : "",
						is_connected ? ", Connected" : "");
				drawrect(menu->submenu_tree, x, y, menu->submenu_width - 2 * padding, row_h,
						hover ? net_menu_row_bg_hover : net_menu_row_bg);
				tray_menu_draw_text(menu->submenu_tree, line, x + 4, y, row_h);
				n->secure = n->secure ? 1 : 0;
				idx++;
				y += row_h;
			}
		}
	} else {
		/* VPN items */
		if (wl_list_empty(&vpn_connections)) {
			drawrect(menu->submenu_tree, padding, y, menu->submenu_width - 2 * padding, row_h,
					net_menu_row_bg);
			tray_menu_draw_text(menu->submenu_tree, line, padding + 4, y, row_h);
		} else {
			VpnConnection *v;
			int idx = 0;
			wl_list_for_each(v, &vpn_connections, link) {
				int x = padding;
				int hover = (menu->submenu_hover == idx);
				snprintf(line, sizeof(line), "%s%s", v->name,
						v->active ? " (Connected)" : "");
				drawrect(menu->submenu_tree, x, y, menu->submenu_width - 2 * padding, row_h,
						hover ? net_menu_row_bg_hover : net_menu_row_bg);
				tray_menu_draw_text(menu->submenu_tree, line, x + 4, y, row_h);
				idx++;
				y += row_h;
			}
		}
	}

	menu->submenu_visible = 1;
	wlr_scene_node_set_enabled(&menu->submenu_tree->node, 1);
}

static void
request_wifi_scan(void)
{
	const char *cmd = "nmcli -t -f SSID,SIGNAL,SECURITY device wifi list --rescan auto";
	int pipefd[2] = {-1, -1};

	if (wifi_scan_inflight)
		return;

	if (pipe(pipefd) != 0)
		return;

	wifi_scan_generation = wifi_networks_generation;
	wifi_scan_pid = fork();
	if (wifi_scan_pid == 0) {
		close(pipefd[0]);
		dup2(pipefd[1], STDOUT_FILENO);
		dup2(pipefd[1], STDERR_FILENO);
		close(pipefd[1]);
		execl("/bin/sh", "/bin/sh", "-c", cmd, NULL);
		_exit(127);
	} else if (wifi_scan_pid < 0) {
		close(pipefd[0]);
		close(pipefd[1]);
		wifi_scan_pid = -1;
		return;
	}

	close(pipefd[1]);
	wifi_scan_fd = pipefd[0];
	fcntl(wifi_scan_fd, F_SETFL, fcntl(wifi_scan_fd, F_GETFL) | O_NONBLOCK);
	wifi_scan_len = 0;
	wifi_scan_buf[0] = '\0';
	wifi_scan_inflight = 1;
	wifi_scan_event = wl_event_loop_add_fd(event_loop, wifi_scan_fd,
			WL_EVENT_READABLE | WL_EVENT_HANGUP, wifi_scan_event_cb, NULL);
	if (!wifi_scan_event) {
		wifi_scan_inflight = 0;
		close(wifi_scan_fd);
		wifi_scan_fd = -1;
		if (wifi_scan_pid > 0)
			waitpid(wifi_scan_pid, NULL, WNOHANG);
		wifi_scan_pid = -1;
	}
}

static void
vpn_connections_clear(void)
{
	VpnConnection *v, *tmp;
	wl_list_for_each_safe(v, tmp, &vpn_connections, link) {
		wl_list_remove(&v->link);
		free(v);
	}
}

static void
vpn_scan_finish(void)
{
	if (vpn_scan_event) {
		wl_event_source_remove(vpn_scan_event);
		vpn_scan_event = NULL;
	}
	if (vpn_scan_fd >= 0) {
		close(vpn_scan_fd);
		vpn_scan_fd = -1;
	}
	if (vpn_scan_pid > 0) {
		waitpid(vpn_scan_pid, NULL, WNOHANG);
		vpn_scan_pid = -1;
	}
	vpn_scan_inflight = 0;
}

static int
vpn_scan_event_cb(int fd, uint32_t mask, void *data)
{
	ssize_t n;
	char *saveptr = NULL;
	char *line;
	(void)data;
	(void)mask;

	for (;;) {
		if (vpn_scan_len >= sizeof(vpn_scan_buf) - 1)
			break;
		n = read(fd, vpn_scan_buf + vpn_scan_len,
				sizeof(vpn_scan_buf) - 1 - vpn_scan_len);
		if (n > 0) {
			vpn_scan_len += (size_t)n;
			continue;
		} else if (n == 0) {
			break;
		} else if (errno == EAGAIN || errno == EWOULDBLOCK) {
			return 0;
		} else {
			break;
		}
	}

	vpn_scan_buf[vpn_scan_len] = '\0';

	vpn_connections_clear();

	/* Parse nmcli output: NAME:UUID:TYPE:DEVICE
	 * We only want VPN connections (TYPE=vpn) */
	line = strtok_r(vpn_scan_buf, "\n", &saveptr);
	while (line) {
		char *uuid_s, *type_s, *device_s;
		VpnConnection *ventry;
		char name[128] = {0};
		char uuid[64] = {0};
		int active = 0;

		/* Parse NAME:UUID:TYPE:DEVICE */
		uuid_s = strchr(line, ':');
		if (uuid_s) {
			*uuid_s = '\0';
			uuid_s++;
			type_s = strchr(uuid_s, ':');
			if (type_s) {
				*type_s = '\0';
				type_s++;
				device_s = strchr(type_s, ':');
				if (device_s) {
					*device_s = '\0';
					device_s++;
				}
			} else {
				device_s = NULL;
			}
		} else {
			type_s = NULL;
			device_s = NULL;
		}

		/* Only process VPN connections */
		if (!type_s || strcmp(type_s, "vpn") != 0) {
			line = strtok_r(NULL, "\n", &saveptr);
			continue;
		}

		if (line[0])
			snprintf(name, sizeof(name), "%s", line);
		if (!name[0]) {
			line = strtok_r(NULL, "\n", &saveptr);
			continue;
		}
		if (uuid_s)
			snprintf(uuid, sizeof(uuid), "%s", uuid_s);
		/* Active if DEVICE is not empty (e.g., has interface like "tun0") */
		if (device_s && device_s[0] && strcmp(device_s, "--") != 0)
			active = 1;

		ventry = ecalloc(1, sizeof(*ventry));
		snprintf(ventry->name, sizeof(ventry->name), "%s", name);
		snprintf(ventry->uuid, sizeof(ventry->uuid), "%s", uuid);
		ventry->active = active;
		wl_list_insert(vpn_connections.prev, &ventry->link);

		line = strtok_r(NULL, "\n", &saveptr);
	}

	vpn_scan_finish();

	/* Update submenu if visible and showing VPN */
	{
		Monitor *m;
		wl_list_for_each(m, &mons, link) {
			if (m->statusbar.net_menu.visible && m->statusbar.net_menu.submenu_type == 1) {
				net_menu_submenu_render(m);
				if (m->statusbar.net_menu.submenu_tree)
					wlr_scene_node_set_position(&m->statusbar.net_menu.submenu_tree->node,
							m->statusbar.net_menu.submenu_x, m->statusbar.net_menu.submenu_y);
			}
		}
	}
	return 0;
}

static void
request_vpn_scan(void)
{
	/* Get all VPN connections with their status */
	const char *cmd = "nmcli -t -f NAME,UUID,TYPE,DEVICE connection show";
	int pipefd[2] = {-1, -1};

	if (vpn_scan_inflight)
		return;

	if (pipe(pipefd) != 0)
		return;

	vpn_scan_pid = fork();
	if (vpn_scan_pid == 0) {
		close(pipefd[0]);
		dup2(pipefd[1], STDOUT_FILENO);
		dup2(pipefd[1], STDERR_FILENO);
		close(pipefd[1]);
		execl("/bin/sh", "/bin/sh", "-c", cmd, NULL);
		_exit(127);
	} else if (vpn_scan_pid < 0) {
		close(pipefd[0]);
		close(pipefd[1]);
		vpn_scan_pid = -1;
		return;
	}

	close(pipefd[1]);
	vpn_scan_fd = pipefd[0];
	fcntl(vpn_scan_fd, F_SETFL, fcntl(vpn_scan_fd, F_GETFL) | O_NONBLOCK);
	vpn_scan_len = 0;
	vpn_scan_buf[0] = '\0';
	vpn_scan_inflight = 1;
	vpn_scan_event = wl_event_loop_add_fd(event_loop, vpn_scan_fd,
			WL_EVENT_READABLE | WL_EVENT_HANGUP, vpn_scan_event_cb, NULL);
	if (!vpn_scan_event) {
		vpn_scan_inflight = 0;
		close(vpn_scan_fd);
		vpn_scan_fd = -1;
		if (vpn_scan_pid > 0)
			waitpid(vpn_scan_pid, NULL, WNOHANG);
		vpn_scan_pid = -1;
	}
}

static void
vpn_connect_finish(void)
{
	if (vpn_connect_event) {
		wl_event_source_remove(vpn_connect_event);
		vpn_connect_event = NULL;
	}
	if (vpn_connect_fd >= 0) {
		close(vpn_connect_fd);
		vpn_connect_fd = -1;
	}
	if (vpn_connect_pid > 0) {
		int status;
		waitpid(vpn_connect_pid, &status, 0);
		vpn_connect_pid = -1;
	}
}

static int
vpn_connect_event_cb(int fd, uint32_t mask, void *data)
{
	ssize_t n;
	int success = 0;
	(void)data;
	(void)mask;

	for (;;) {
		if (vpn_connect_len >= sizeof(vpn_connect_buf) - 1)
			break;
		n = read(fd, vpn_connect_buf + vpn_connect_len,
				sizeof(vpn_connect_buf) - 1 - vpn_connect_len);
		if (n > 0) {
			vpn_connect_len += (size_t)n;
			continue;
		} else if (n == 0) {
			break;
		} else if (errno == EAGAIN || errno == EWOULDBLOCK) {
			return 0;
		} else {
			break;
		}
	}

	vpn_connect_buf[vpn_connect_len] = '\0';

	/* Check if connection was successful by looking at the output */
	if (strstr(vpn_connect_buf, "successfully activated") ||
	    strstr(vpn_connect_buf, "Connection successfully activated")) {
		success = 1;
	}

	vpn_connect_finish();

	if (!success && vpn_pending_name[0]) {
		/* Show error toast */
		char error_msg[256];
		/* Extract error message if possible, otherwise generic */
		if (strstr(vpn_connect_buf, "Error:")) {
			snprintf(error_msg, sizeof(error_msg), "VPN failed: %s", vpn_pending_name);
		} else {
			snprintf(error_msg, sizeof(error_msg), "VPN connection failed: %s", vpn_pending_name);
		}
		toast_show(selmon, error_msg, 3000);
	}

	/* Refresh VPN list to update status */
	request_vpn_scan();
	vpn_pending_name[0] = '\0';

	return 0;
}

static void
vpn_connect(const char *name)
{
	char cmd[512];
	int pipefd[2] = {-1, -1};

	if (!name || !name[0])
		return;

	/* Check if already connecting */
	if (vpn_connect_pid > 0)
		return;

	snprintf(cmd, sizeof(cmd), "nmcli connection up \"%s\" 2>&1", name);
	snprintf(vpn_pending_name, sizeof(vpn_pending_name), "%s", name);

	if (pipe(pipefd) != 0) {
		toast_show(selmon, "VPN: Failed to create pipe", 3000);
		return;
	}

	vpn_connect_pid = fork();
	if (vpn_connect_pid == 0) {
		close(pipefd[0]);
		dup2(pipefd[1], STDOUT_FILENO);
		dup2(pipefd[1], STDERR_FILENO);
		close(pipefd[1]);
		execl("/bin/sh", "/bin/sh", "-c", cmd, NULL);
		_exit(127);
	} else if (vpn_connect_pid < 0) {
		close(pipefd[0]);
		close(pipefd[1]);
		vpn_connect_pid = -1;
		toast_show(selmon, "VPN: Failed to fork", 3000);
		return;
	}

	close(pipefd[1]);
	vpn_connect_fd = pipefd[0];
	fcntl(vpn_connect_fd, F_SETFL, fcntl(vpn_connect_fd, F_GETFL) | O_NONBLOCK);
	vpn_connect_len = 0;
	vpn_connect_buf[0] = '\0';
	vpn_connect_event = wl_event_loop_add_fd(event_loop, vpn_connect_fd,
			WL_EVENT_READABLE | WL_EVENT_HANGUP, vpn_connect_event_cb, NULL);
	if (!vpn_connect_event) {
		close(vpn_connect_fd);
		vpn_connect_fd = -1;
		if (vpn_connect_pid > 0)
			waitpid(vpn_connect_pid, NULL, WNOHANG);
		vpn_connect_pid = -1;
		toast_show(selmon, "VPN: Failed to add event", 3000);
	}
}

static VpnConnection *
vpn_connection_at_index(int idx)
{
	VpnConnection *v;
	int i = 0;
	wl_list_for_each(v, &vpn_connections, link) {
		if (i == idx)
			return v;
		i++;
	}
	return NULL;
}

static void
tray_add_item(const char *service, const char *path, int emit_signals)
{
	const char *base;
	TrayItem *it;

	if (!service || !service[0] || !path || !path[0])
		return;

	tray_remove_item(service);
	it = ecalloc(1, sizeof(*it));
	snprintf(it->service, sizeof(it->service), "%s", service);
	snprintf(it->path, sizeof(it->path), "%s", path);
	base = strrchr(service, '.');
	base = base ? base + 1 : service;
	snprintf(it->label, sizeof(it->label), "%s", base);
	it->icon_tried = 0;
	it->icon_failed = 0;
	wl_list_insert(&tray_items, &it->link);
	wlr_log(WLR_INFO, "tray: registered %s%s", service, path);

	tray_update_icons_text();

	if (!emit_signals || !tray_bus)
		return;

	sd_bus_emit_signal(tray_bus, NULL, "/StatusNotifierWatcher",
			"org.kde.StatusNotifierWatcher",
			"StatusNotifierItemRegistered", "s", service);
	sd_bus_emit_signal(tray_bus, NULL, "/StatusNotifierWatcher",
			"org.freedesktop.StatusNotifierWatcher",
			"StatusNotifierItemRegistered", "s", service);
}

static int
tray_method_register_item(sd_bus_message *m, void *userdata, sd_bus_error *ret_error)
{
	const char *arg = NULL;
	const char *sender = sd_bus_message_get_sender(m);
	char service[128] = {0};
	char path[128] = {0};
	sd_bus_error err = SD_BUS_ERROR_NULL;

	(void)userdata;
	(void)ret_error;

	if (sd_bus_message_read(m, "s", &arg) < 0) {
		sd_bus_error_set_const(&err, SD_BUS_ERROR_INVALID_ARGS, "invalid arg");
		return sd_bus_reply_method_error(m, &err);
	}
	if (!sender || !sender[0]) {
		sd_bus_error_set_const(&err, SD_BUS_ERROR_FAILED, "no sender");
		return sd_bus_reply_method_error(m, &err);
	}

	if (arg && strchr(arg, '/')) {
		snprintf(service, sizeof(service), "%s", sender);
		snprintf(path, sizeof(path), "%s", arg);
	} else {
		snprintf(service, sizeof(service), "%s", arg && arg[0] ? arg : sender);
		snprintf(path, sizeof(path), "/StatusNotifierItem");
	}

	if (tray_find_item_path(service, path, sizeof(path)) == 0) {
		/* path updated by helper */
	}

	tray_add_item(service, path, 1);
	tray_emit_host_registered();
	return sd_bus_reply_method_return(m, "");
}

static int
tray_method_register_host(sd_bus_message *m, void *userdata, sd_bus_error *ret_error)
{
	(void)userdata;
	(void)ret_error;
	tray_host_registered = 1;
	tray_emit_host_registered();
	return sd_bus_reply_method_return(m, "");
}

static void
tray_scan_existing_items(void)
{
	sd_bus_message *reply = NULL;
	sd_bus_error err = SD_BUS_ERROR_NULL;
	const char *name;

	if (!tray_bus)
		return;

	if (sd_bus_call_method(tray_bus, "org.freedesktop.DBus", "/org/freedesktop/DBus",
				"org.freedesktop.DBus", "ListNames", &err, &reply, "") < 0)
		goto out;
	if (sd_bus_message_enter_container(reply, 'a', "s") < 0)
		goto out;

	while (sd_bus_message_read_basic(reply, 's', &name) > 0) {
		if (!name)
			continue;
		if (strstr(name, "StatusNotifierItem") || strstr(name, "NotificationItem")) {
			char path[128];
			if (tray_find_item_path(name, path, sizeof(path)) != 0)
				snprintf(path, sizeof(path), "%s", "/StatusNotifierItem");
			tray_add_item(name, path, 1);
		}
	}

	sd_bus_message_exit_container(reply);
out:
	sd_bus_error_free(&err);
	sd_bus_message_unref(reply);
}

static int
tray_property_get_registered(sd_bus *bus, const char *path, const char *interface,
		const char *property, sd_bus_message *reply, void *userdata, sd_bus_error *ret_error)
{
	TrayItem *it;

	(void)bus; (void)path; (void)interface; (void)property; (void)userdata; (void)ret_error;

	if (sd_bus_message_open_container(reply, 'a', "s") < 0)
		return -EINVAL;

	wl_list_for_each(it, &tray_items, link) {
		char full[256];
		snprintf(full, sizeof(full), "%s%s", it->service, it->path);
		sd_bus_message_append_basic(reply, 's', full);
	}

	return sd_bus_message_close_container(reply);
}

static int
tray_property_get_host_registered(sd_bus *bus, const char *path, const char *interface,
		const char *property, sd_bus_message *reply, void *userdata, sd_bus_error *ret_error)
{
	(void)bus; (void)path; (void)interface; (void)property; (void)userdata; (void)ret_error;
	return sd_bus_message_append_basic(reply, 'b', &tray_host_registered);
}

static int
tray_property_get_protocol_version(sd_bus *bus, const char *path, const char *interface,
		const char *property, sd_bus_message *reply, void *userdata, sd_bus_error *ret_error)
{
	int version = 1;

	(void)bus; (void)path; (void)interface; (void)property; (void)userdata; (void)ret_error;
	return sd_bus_message_append_basic(reply, 'i', &version);
}

static int
tray_name_owner_changed(sd_bus_message *m, void *userdata, sd_bus_error *ret_error)
{
	const char *name, *old_owner, *new_owner;

	(void)userdata;
	(void)ret_error;
	if (sd_bus_message_read(m, "sss", &name, &old_owner, &new_owner) < 0)
		return 0;
	if (name && new_owner && *new_owner &&
			(strstr(name, "StatusNotifierItem") || strstr(name, "NotificationItem"))) {
		char path[128];
		if (tray_find_item_path(name, path, sizeof(path)) != 0)
			snprintf(path, sizeof(path), "%s", "/StatusNotifierItem");
		tray_add_item(name, path, 1);
		return 0;
	}
	if (name && old_owner && *old_owner && (!new_owner || !*new_owner))
		tray_remove_item(name);
	return 0;
}

static int
tray_bus_event(int fd, uint32_t mask, void *data)
{
	sd_bus *bus = data;
	int r;
	int events;
	uint32_t newmask;

	(void)fd;
	if (!bus)
		return 0;

	if (mask & (WL_EVENT_HANGUP | WL_EVENT_ERROR))
		return 0;

	while ((r = sd_bus_process(bus, NULL)) > 0)
		;

	events = sd_bus_get_events(bus);
	newmask = 0;
	if (events & SD_BUS_EVENT_READABLE)
		newmask |= WL_EVENT_READABLE;
	if (events & SD_BUS_EVENT_WRITABLE)
		newmask |= WL_EVENT_WRITABLE;
	if (tray_event)
		wl_event_source_fd_update(tray_event, newmask ? newmask : WL_EVENT_READABLE);

	return 0;
}

static void
tray_init(void)
{
	static const sd_bus_vtable tray_vtable[] = {
		SD_BUS_VTABLE_START(0),
		SD_BUS_METHOD("RegisterStatusNotifierItem", "s", "", tray_method_register_item, SD_BUS_VTABLE_UNPRIVILEGED),
		SD_BUS_METHOD("RegisterStatusNotifierHost", "s", "", tray_method_register_host, SD_BUS_VTABLE_UNPRIVILEGED),
		SD_BUS_PROPERTY("RegisteredStatusNotifierItems", "as", tray_property_get_registered, 0, SD_BUS_VTABLE_PROPERTY_EMITS_INVALIDATION),
		SD_BUS_PROPERTY("IsStatusNotifierHostRegistered", "b", tray_property_get_host_registered, 0, SD_BUS_VTABLE_PROPERTY_EMITS_INVALIDATION),
		SD_BUS_PROPERTY("ProtocolVersion", "i", tray_property_get_protocol_version, 0, SD_BUS_VTABLE_PROPERTY_CONST),
		SD_BUS_VTABLE_END
	};
	int r;
	int fd;
	int events;
	uint32_t mask = WL_EVENT_READABLE;
	uint64_t name_flags = SD_BUS_NAME_ALLOW_REPLACEMENT | SD_BUS_NAME_REPLACE_EXISTING;

	if (tray_bus)
		return;

	r = sd_bus_open_user(&tray_bus);
	if (r < 0) {
		wlr_log(WLR_ERROR, "tray: failed to connect to session bus: %s", strerror(-r));
		tray_bus = NULL;
		return;
	}

	/* Keep icon/property queries from stalling the compositor for too long */
	sd_bus_set_method_call_timeout(tray_bus, 2 * 1000 * 1000); /* 2s */

	r = sd_bus_request_name(tray_bus, "org.kde.StatusNotifierWatcher", name_flags);
	if (r < 0) {
		wlr_log(WLR_ERROR, "tray: failed to acquire watcher name: %s", strerror(-r));
		goto fail;
	}
	/* Some implementations also look for the freedesktop alias */
	sd_bus_request_name(tray_bus, "org.freedesktop.StatusNotifierWatcher", name_flags);
	sd_bus_add_object_vtable(tray_bus, &tray_vtable_slot, "/StatusNotifierWatcher",
			"org.kde.StatusNotifierWatcher", tray_vtable, NULL);
	sd_bus_add_object_vtable(tray_bus, &tray_fdo_vtable_slot, "/StatusNotifierWatcher",
			"org.freedesktop.StatusNotifierWatcher", tray_vtable, NULL);
	sd_bus_add_match(tray_bus, &tray_name_slot,
		"type='signal',sender='org.freedesktop.DBus',path='/org/freedesktop/DBus',interface='org.freedesktop.DBus',member='NameOwnerChanged'",
		tray_name_owner_changed, NULL);

	fd = sd_bus_get_fd(tray_bus);
	events = sd_bus_get_events(tray_bus);
	mask = 0;
	if (events & SD_BUS_EVENT_READABLE)
		mask |= WL_EVENT_READABLE;
	if (events & SD_BUS_EVENT_WRITABLE)
		mask |= WL_EVENT_WRITABLE;
	if (mask == 0)
		mask = WL_EVENT_READABLE;

	tray_event = wl_event_loop_add_fd(event_loop, fd, mask, tray_bus_event, tray_bus);
	tray_scan_existing_items();
	tray_host_registered = 1;
	tray_emit_host_registered();
	tray_update_icons_text();
	return;
fail:
	if (tray_vtable_slot)
		sd_bus_slot_unref(tray_vtable_slot);
	tray_vtable_slot = NULL;
	if (tray_fdo_vtable_slot)
		sd_bus_slot_unref(tray_fdo_vtable_slot);
	tray_fdo_vtable_slot = NULL;
	if (tray_name_slot)
		sd_bus_slot_unref(tray_name_slot);
	tray_name_slot = NULL;
	if (tray_event) {
		wl_event_source_remove(tray_event);
		tray_event = NULL;
	}
	if (tray_bus) {
		sd_bus_unref(tray_bus);
		tray_bus = NULL;
	}
}

static int
findbacklightdevice(char *brightness_path, size_t brightness_len,
		char *max_path, size_t max_len)
{
	DIR *dir;
	struct dirent *ent;
	char w_bpath[PATH_MAX] = {0};
	char w_mpath[PATH_MAX] = {0};
	char r_bpath[PATH_MAX] = {0};
	char r_mpath[PATH_MAX] = {0};
	int have_writable = 0;
	int have_readable = 0;

	if (!brightness_path || !max_path || brightness_len == 0 || max_len == 0)
		return 0;

	dir = opendir("/sys/class/backlight");
	if (!dir)
		return 0;

	backlight_writable = 0;

	while ((ent = readdir(dir))) {
		char bpath[PATH_MAX];
		char mpath[PATH_MAX];
		struct stat st;

		if (ent->d_name[0] == '.')
			continue;

		snprintf(bpath, sizeof(bpath), "/sys/class/backlight/%s/brightness",
				ent->d_name);
		snprintf(mpath, sizeof(mpath), "/sys/class/backlight/%s/max_brightness",
				ent->d_name);

		if (stat(bpath, &st) != 0 || !S_ISREG(st.st_mode))
			continue;
		if (stat(mpath, &st) != 0 || !S_ISREG(st.st_mode))
			continue;

		if (access(bpath, R_OK) != 0 || access(mpath, R_OK) != 0)
			continue;

		if (access(bpath, W_OK) == 0 && !have_writable) {
			if (snprintf(w_bpath, sizeof(w_bpath), "%s", bpath) < (int)sizeof(w_bpath)
					&& snprintf(w_mpath, sizeof(w_mpath), "%s", mpath) < (int)sizeof(w_mpath))
				have_writable = 1;
		}

		if (!have_readable) {
			if (snprintf(r_bpath, sizeof(r_bpath), "%s", bpath) < (int)sizeof(r_bpath)
					&& snprintf(r_mpath, sizeof(r_mpath), "%s", mpath) < (int)sizeof(r_mpath))
				have_readable = 1;
		}
	}

	closedir(dir);

	if (have_writable) {
		if (snprintf(brightness_path, brightness_len, "%s", w_bpath) >= (int)brightness_len)
			return 0;
		if (snprintf(max_path, max_len, "%s", w_mpath) >= (int)max_len)
			return 0;
		backlight_writable = 1;
		return 1;
	}

	if (have_readable) {
		if (snprintf(brightness_path, brightness_len, "%s", r_bpath) >= (int)brightness_len)
			return 0;
		if (snprintf(max_path, max_len, "%s", r_mpath) >= (int)max_len)
			return 0;
		backlight_writable = 0;
		return 1;
	}

	return 0;
}

static int
readulong_cmd(const char *cmd, unsigned long long *out)
{
	FILE *fp;
	char buf[64];
	unsigned long long val;
	char *end = NULL;

	if (!cmd || !out)
		return -1;

	fp = popen(cmd, "r");
	if (!fp)
		return -1;
	if (!fgets(buf, sizeof(buf), fp)) {
		pclose(fp);
		return -1;
	}
	pclose(fp);

	errno = 0;
	val = strtoull(buf, &end, 10);
	if (errno != 0)
		return -1;
	if (end == buf)
		return -1;
	*out = val;
	return 0;
}

static double
backlight_percent(void)
{
	unsigned long long cur, max;
	double percent;

	/* Prefer brightnessctl */
	if (readulong_cmd("brightnessctl g", &cur) == 0 &&
			readulong_cmd("brightnessctl m", &max) == 0 && max > 0) {
		if (cur > max)
			cur = max;
		light_cached_percent = ((double)cur * 100.0) / (double)max;
		return light_cached_percent;
	}

	/* Fallback to light -G */
	{
		FILE *fp = popen("light -G", "r");
		if (fp) {
			if (fscanf(fp, "%lf", &percent) == 1) {
				pclose(fp);
				if (percent < 0.0)
					percent = -1.0;
				if (percent > 100.0)
					percent = 100.0;
				if (percent >= 0.0)
					light_cached_percent = percent;
				return percent;
			}
			pclose(fp);
		}
	}

	/* Fallback to sysfs if available */
	if (backlight_available) {
		if (readulong(backlight_brightness_path, &cur) == 0 &&
				readulong(backlight_max_path, &max) == 0 && max > 0) {
			if (cur > max)
				cur = max;
			light_cached_percent = ((double)cur * 100.0) / (double)max;
			return light_cached_percent;
		}
	}

	/* Fallback to brightnessctl */
	if (readulong_cmd("brightnessctl g", &cur) == 0 &&
			readulong_cmd("brightnessctl m", &max) == 0 && max > 0) {
		if (cur > max)
			cur = max;
		light_cached_percent = ((double)cur * 100.0) / (double)max;
		return light_cached_percent;
	}

	/* Fallback to light -G */
	{
		FILE *fp = popen("light -G", "r");
		if (fp) {
			if (fscanf(fp, "%lf", &percent) == 1) {
				pclose(fp);
				if (percent < 0.0)
					percent = -1.0;
				if (percent > 100.0)
					percent = 100.0;
				if (percent >= 0.0)
					light_cached_percent = percent;
				return percent;
			}
			pclose(fp);
		}
	}

	return light_cached_percent;
}

static int
set_backlight_percent(double percent)
{
	unsigned long long max, target;
	FILE *fp;
	int attempted = 0;

	if (percent < 0.0)
		percent = 0.0;
	if (percent > 100.0)
		percent = 100.0;

	if (backlight_available && readulong(backlight_max_path, &max) == 0 && max > 0) {
		target = (unsigned long long)lround((percent / 100.0) * (double)max);
		if (target > max)
			target = max;

		if (backlight_writable && (fp = fopen(backlight_brightness_path, "w"))) {
			attempted = 1;
			if (fprintf(fp, "%llu", target) >= 0) {
				fclose(fp);
				light_cached_percent = percent;
				return 0;
			}
			fclose(fp);
		}
	}

	/* Use external tools (non-blocking) */
	{
		char arg[32];
		snprintf(arg, sizeof(arg), "%.2f%%", percent);

		if (fork() == 0) {
			setsid();
			execlp("brightnessctl", "brightnessctl", "set", arg, (char *)NULL);
			/* If brightnessctl fails, try light */
			snprintf(arg, sizeof(arg), "%.2f", percent);
			execlp("light", "light", "-S", arg, (char *)NULL);
			_exit(127);
		}
		light_cached_percent = percent;
		return 0;
	}
}

static int
set_backlight_relative(double delta_percent)
{
	char arg[32];
	char light_arg[32];
	double cur;

	if (delta_percent == 0.0)
		return 0;

	/* Update cached value */
	cur = light_cached_percent >= 0.0 ? light_cached_percent : backlight_percent();
	if (cur >= 0.0) {
		double target = cur + delta_percent;
		if (target < 0.0)
			target = 0.0;
		if (target > 100.0)
			target = 100.0;
		light_cached_percent = target;
	}

	/* Use external tools (non-blocking) */
	if (delta_percent > 0) {
		snprintf(arg, sizeof(arg), "+%.2f%%", delta_percent);
		snprintf(light_arg, sizeof(light_arg), "%.2f", delta_percent);
	} else {
		snprintf(arg, sizeof(arg), "%.2f%%-", -delta_percent);
		snprintf(light_arg, sizeof(light_arg), "%.2f", -delta_percent);
	}

	if (fork() == 0) {
		setsid();
		execlp("brightnessctl", "brightnessctl", "set", arg, (char *)NULL);
		/* If brightnessctl fails, try light */
		execlp("light", "light", delta_percent > 0 ? "-A" : "-U", light_arg, (char *)NULL);
		_exit(127);
	}

	return 0;
}

static void
apply_startup_defaults(void)
{
	static int applied = 0;
	const double light_default = 40.0;
	const double speaker_default = 70.0;
	const double mic_default = 80.0;

	if (applied)
		return;

	/* Backlight */
	if (set_backlight_percent(light_default) == 0) {
		light_last_percent = light_default;
		light_cached_percent = light_default;
	} else if (light_cached_percent < 0.0) {
		light_cached_percent = light_default;
	}

	/*
	 * Speaker/headset volume - read actual state from PipeWire first,
	 * then unmute and set to default. This ensures statusbar shows
	 * correct state from the very beginning.
	 */
	{
		int is_headset = 0;
		double actual_vol;

		/* Invalidate cache to force fresh read from PipeWire */
		volume_invalidate_cache(0); /* speaker */
		volume_invalidate_cache(1); /* headset */

		/* Read actual current state from PipeWire */
		actual_vol = pipewire_volume_percent(&is_headset);
		(void)actual_vol; /* We just want the mute state synced */

		/* Now unmute and set volume */
		set_pipewire_mute(0);

		/* Update all mute state variables to match */
		volume_muted = 0;
		volume_cached_speaker_muted = 0;
		volume_cached_headset_muted = 0;

		/* Invalidate cache again so next read gets fresh data */
		volume_invalidate_cache(0);
		volume_invalidate_cache(1);
	}

	if (set_pipewire_volume(speaker_default) == 0) {
		speaker_active = speaker_default;
		speaker_stored = speaker_default;
		volume_last_speaker_percent = speaker_default;
		volume_last_headset_percent = speaker_default;
	}

	/*
	 * Microphone volume - read actual state from PipeWire first,
	 * then unmute and set to default.
	 */
	{
		double actual_mic;

		/* Invalidate cache to force fresh read */
		mic_last_read_ms = 0;

		/* Read actual current state from PipeWire */
		actual_mic = pipewire_mic_volume_percent();
		(void)actual_mic;

		/* Now unmute and set volume */
		set_pipewire_mic_mute(0);

		/* Update all mic mute state variables to match */
		mic_muted = 0;
		mic_cached_muted = 0;

		/* Invalidate cache again */
		mic_last_read_ms = 0;
	}

	if (set_pipewire_mic_volume(mic_default) == 0) {
		microphone_active = mic_default;
		microphone_stored = mic_default;
		mic_last_percent = mic_default;
	}

	applied = 1;
}

static double
battery_percent(void)
{
	unsigned long long cur;

	if (!battery_available)
		return -1.0;
	if (readulong(battery_capacity_path, &cur) != 0)
		return -1.0;
	if (cur > 100)
		cur = 100;

	return (double)cur;
}

static void
applyxkbdefaultsfromsystem(struct xkb_rule_names *names)
{
	static int loaded;
	static char layout[128];
	static char model[128];
	static char variant[128];
	static char options[256];
	FILE *fp;
	char line[256];
	char *newline;

	/* If config already provided everything, avoid extra work */
	if (names->model && names->layout && names->variant && names->options)
		return;

	if (!loaded) {
		int need_localectl;
		fp = fopen("/etc/X11/xorg.conf.d/00-keyboard.conf", "r");
		if (fp) {
			while (fgets(line, sizeof(line), fp)) {
				newline = strpbrk(line, "\r\n");
				if (newline)
					*newline = '\0';
				if (!layout[0] && sscanf(line, " Option \"XkbLayout\" \"%127[^\"]\"", layout) == 1)
					continue;
				if (!model[0] && sscanf(line, " Option \"XkbModel\" \"%127[^\"]\"", model) == 1)
					continue;
				if (!variant[0] && sscanf(line, " Option \"XkbVariant\" \"%127[^\"]\"", variant) == 1)
					continue;
				if (!options[0] && sscanf(line, " Option \"XkbOptions\" \"%255[^\"]\"", options) == 1)
					continue;
			}
			fclose(fp);
		}
		need_localectl = !layout[0] || !model[0] || !variant[0] || !options[0];
		/* If the X11 config isn't present (Wayland-only setups) or lacks data, try localectl */
		if (need_localectl) {
			fp = popen("localectl status", "r");
			if (fp) {
				while (fgets(line, sizeof(line), fp)) {
					newline = strpbrk(line, "\r\n");
					if (newline)
						*newline = '\0';
					if (!layout[0] && sscanf(line, " X11 Layout: %127[^\n]", layout) == 1)
						continue;
					if (!model[0] && sscanf(line, " X11 Model: %127[^\n]", model) == 1)
						continue;
					if (!variant[0] && sscanf(line, " X11 Variant: %127[^\n]", variant) == 1)
						continue;
					if (!options[0] && sscanf(line, " X11 Options: %255[^\n]", options) == 1)
						continue;
				}
				pclose(fp);
			}
		}
		loaded = 1;
	}

	if (!names->layout && layout[0])
		names->layout = layout;
	if (!names->model && model[0])
		names->model = model;
	if (!names->variant && variant[0])
		names->variant = variant;
	if (!names->options && options[0])
		names->options = options;
}

static struct xkb_rule_names
getxkbrules(void)
{
	struct xkb_rule_names names = xkb_rules;
	const char *env;

	if (!names.rules && (env = getenv("XKB_DEFAULT_RULES")))
		names.rules = env;
	if (!names.model && (env = getenv("XKB_DEFAULT_MODEL")))
		names.model = env;
	if (!names.layout && (env = getenv("XKB_DEFAULT_LAYOUT")))
		names.layout = env;
	if (!names.variant && (env = getenv("XKB_DEFAULT_VARIANT")))
		names.variant = env;
	if (!names.options && (env = getenv("XKB_DEFAULT_OPTIONS")))
		names.options = env;

	/* NixOS/localectl store XKB defaults system-wide; use them as a fallback so
	 * Wayland sessions pick up the same keyboard layout. */
	applyxkbdefaultsfromsystem(&names);

	return names;
}

static double
volume_last_for_type(int is_headset)
{
	return is_headset ? volume_last_headset_percent : volume_last_speaker_percent;
}

static void
volume_cache_store(int is_headset, double level, int muted, uint64_t now)
{
	if (level < 0.0)
		return;

	if (is_headset) {
		volume_cached_headset = level;
		volume_cached_headset_muted = muted;
		volume_last_read_headset_ms = now;
		volume_last_headset_percent = level;
	} else {
		volume_cached_speaker = level;
		volume_cached_speaker_muted = muted;
		volume_last_read_speaker_ms = now;
		volume_last_speaker_percent = level;
	}
	speaker_active = level;
}

static void
volume_invalidate_cache(int is_headset)
{
	if (is_headset)
		volume_last_read_headset_ms = 0;
	else
		volume_last_read_speaker_ms = 0;
}

static double
pipewire_volume_percent(int *is_headset_out)
{
	FILE *fp;
	char line[128];
	double level = -1.0;
	int muted = 0;
	uint64_t now = monotonic_msec();
	int is_headset = (is_headset_out && (*is_headset_out == 0 || *is_headset_out == 1))
			? *is_headset_out
			: pipewire_sink_is_headset();
	uint64_t last_read = is_headset ? volume_last_read_headset_ms : volume_last_read_speaker_ms;
	double cached = is_headset ? volume_cached_headset : volume_cached_speaker;
	int cached_muted = is_headset ? volume_cached_headset_muted : volume_cached_speaker_muted;

	if (is_headset_out)
		*is_headset_out = is_headset;

	if (last_read != 0 && now - last_read < 8000 && cached >= 0.0) {
		volume_muted = cached_muted;
		if (is_headset)
			volume_last_headset_percent = cached;
		else
			volume_last_speaker_percent = cached;
		return cached;
	}

	fp = popen("wpctl get-volume @DEFAULT_AUDIO_SINK@", "r");
	if (!fp)
		return -1.0;

	if (fgets(line, sizeof(line), fp)) {
		double raw = 0.0;
		if (strstr(line, "[MUTED]"))
			muted = 1;
		if (sscanf(line, "Volume: %lf", &raw) == 1)
			level = raw * 100.0;
	}

	pclose(fp);
	volume_muted = muted;
	volume_cache_store(is_headset, level, muted, now);
	if (level >= 0.0)
		speaker_active = level;
	return level;
}

static double
pipewire_mic_volume_percent(void)
{
	FILE *fp;
	char line[128];
	double level = -1.0;
	int muted = 0;
	uint64_t now = monotonic_msec();

	if (mic_last_read_ms != 0 && now - mic_last_read_ms < 8000) {
		if (mic_cached >= 0.0) {
			mic_muted = mic_cached_muted;
			return mic_cached;
		}
	}

	fp = popen("wpctl get-volume @DEFAULT_AUDIO_SOURCE@", "r");
	if (!fp)
		return -1.0;

	if (fgets(line, sizeof(line), fp)) {
		double raw = 0.0;
		if (strstr(line, "[MUTED]"))
			muted = 1;
		if (sscanf(line, "Volume: %lf", &raw) == 1)
			level = raw * 100.0;
	}

	pclose(fp);
	mic_muted = muted;
	if (level >= 0.0) {
		mic_cached = level;
		mic_cached_muted = muted;
		mic_last_read_ms = now;
		microphone_active = level;
	}
	return level;
}

static int
pipewire_sink_is_headset(void)
{
	FILE *fp;
	char line[512];
	int headset = 0;
	const char *kw[] = {
		"headset", "headphone", "headphones", "earbud", "earbuds",
		"earphone", "handsfree", "bluez", "bluetooth", "a2dp",
		"hfp", "hsp", "head-unit"
	};
	size_t i;

	fp = popen("wpctl inspect @DEFAULT_AUDIO_SINK@", "r");
	if (!fp)
		return 0;

	while (fgets(line, sizeof(line), fp)) {
		for (i = 0; i < LENGTH(kw); i++) {
			if (strcasestr(line, kw[i])) {
				headset = 1;
				break;
			}
		}
		if (headset)
			break;
	}

	pclose(fp);
	if (headset)
		return 1;

	fp = popen("wpctl status", "r");
	if (!fp)
		return 0;

	while (fgets(line, sizeof(line), fp)) {
		if (!strchr(line, '*'))
			continue;
		for (i = 0; i < LENGTH(kw); i++) {
			if (strcasestr(line, kw[i])) {
				headset = 1;
				break;
			}
		}
		if (headset)
			break;
	}

	pclose(fp);
	return headset;
}

static int
set_pipewire_mute(int mute)
{
	char arg[8];

	snprintf(arg, sizeof(arg), "%d", mute ? 1 : 0);

	if (fork() == 0) {
		setsid();
		execlp("wpctl", "wpctl", "set-mute", "@DEFAULT_AUDIO_SINK@", arg, (char *)NULL);
		_exit(127);
	}

	/* Update cached state optimistically */
	volume_muted = mute;
	return 0;
}

static int
set_pipewire_mic_mute(int mute)
{
	char arg[8];

	snprintf(arg, sizeof(arg), "%d", mute ? 1 : 0);

	if (fork() == 0) {
		setsid();
		execlp("wpctl", "wpctl", "set-mute", "@DEFAULT_AUDIO_SOURCE@", arg, (char *)NULL);
		_exit(127);
	}

	/* Update cached state optimistically */
	mic_muted = mute;
	mic_cached_muted = mute;
	return 0;
}

static int
set_pipewire_volume(double percent)
{
	char arg[32];

	if (percent < 0.0)
		percent = 0.0;
	if (percent > volume_max_percent)
		percent = volume_max_percent;

	snprintf(arg, sizeof(arg), "%.2f%%", percent);

	if (fork() == 0) {
		setsid();
		execlp("wpctl", "wpctl", "set-volume", "@DEFAULT_AUDIO_SINK@", arg, (char *)NULL);
		_exit(127);
	}

	return 0;
}

static int
set_pipewire_mic_volume(double percent)
{
	char arg[32];

	if (percent < 0.0)
		percent = 0.0;
	if (percent > mic_max_percent)
		percent = mic_max_percent;

	snprintf(arg, sizeof(arg), "%.2f%%", percent);

	if (fork() == 0) {
		setsid();
		execlp("wpctl", "wpctl", "set-volume", "@DEFAULT_AUDIO_SOURCE@", arg, (char *)NULL);
		_exit(127);
	}

	mic_last_percent = percent;
	return 0;
}

static int
toggle_pipewire_mute(void)
{
	int ret;
	int current;
	int is_headset = pipewire_sink_is_headset();
	double vol;
	uint64_t now;
	double base;
	double target;

	/* Always force a fresh read from PipeWire to get accurate mute state */
	volume_invalidate_cache(is_headset);
	vol = pipewire_volume_percent(&is_headset);
	/*
	 * Determine current mute state. If volume_muted is still -1 (unknown),
	 * treat it as unmuted (0) so first click will mute.
	 */
	current = (vol >= 0.0 && volume_muted == 1) ? 1 : 0;
	base = vol >= 0.0 ? vol : volume_last_for_type(is_headset);

	if (current == 0) { /* muting */
		ret = set_pipewire_mute(1);
		if (ret != 0)
			return -1;
		volume_muted = 1;
		now = monotonic_msec();
		if (base >= 0.0) {
			volume_cache_store(is_headset, base, volume_muted, now);
			speaker_stored = base;
		} else {
			volume_invalidate_cache(is_headset);
		}
	} else { /* unmuting */
		target = speaker_stored >= 0.0 ? speaker_stored : base;
		ret = set_pipewire_mute(0);
		if (ret != 0)
			return -1;
		volume_muted = 0;
		if (target >= 0.0)
			set_pipewire_volume(target);
		if (target >= 0.0) {
			speaker_active = target;
		}
		volume_invalidate_cache(is_headset);
		pipewire_volume_percent(&is_headset); /* refresh cache from PipeWire */
	}

	refreshstatusvolume();
	return 0;
}

static int
toggle_pipewire_mic_mute(void)
{
	int ret;
	int current;
	double vol;
	double base;
	double target;

	/* Always force a fresh read from PipeWire to get accurate mute state */
	mic_last_read_ms = 0;
	vol = pipewire_mic_volume_percent();
	/*
	 * Determine current mute state. If mic_muted is still -1 (unknown),
	 * treat it as unmuted (0) so first click will mute.
	 */
	current = (vol >= 0.0 && mic_muted == 1) ? 1 : 0;
	base = vol >= 0.0 ? vol : mic_last_percent;

	if (current == 0) { /* muting */
		ret = set_pipewire_mic_mute(1);
		if (ret != 0)
			return -1;
		mic_muted = 1;
		mic_cached_muted = mic_muted;
		if (base >= 0.0) {
			mic_cached = base;
			mic_last_percent = base;
			microphone_active = base;
			mic_last_read_ms = monotonic_msec();
			microphone_stored = base;
		}
	} else { /* unmuting */
		target = microphone_stored >= 0.0 ? microphone_stored : base;
		ret = set_pipewire_mic_mute(0);
		if (ret != 0)
			return -1;
		mic_muted = 0;
		mic_cached_muted = mic_muted;
		mic_last_read_ms = 0;
		mic_cached = -1.0;
		if (target >= 0.0) {
			set_pipewire_mic_volume(target);
			mic_cached = target;
			mic_last_percent = target;
			microphone_active = target;
			mic_last_read_ms = monotonic_msec();
		} else {
			pipewire_mic_volume_percent(); /* refresh cache from PipeWire */
		}
	}

	if (mic_last_percent < 0.0)
		mic_last_percent = mic_cached >= 0.0 ? mic_cached : mic_last_percent;
	refreshstatusmic();
	return 0;
}

static int
loadstatusfont(void)
{
	size_t count;
	const char **fonts;

	if (statusfont.font)
		return 1;

	/* Use runtime fonts if configured, otherwise use default */
	if (runtime_fonts_set && runtime_fonts[0]) {
		fonts = (const char **)runtime_fonts;
		for (count = 0; count < 8 && fonts[count]; count++)
			;
	} else {
		fonts = statusbar_fonts;
		/* Count actual non-NULL fonts, not array size */
		for (count = 0; count < LENGTH(statusbar_fonts) && fonts[count]; count++)
			;
	}

	if (count == 0)
		return 0;

	statusfont.font = fcft_from_name(count, fonts, statusbar_font_attributes);
	if (!statusfont.font)
		return 0;

	statusfont.ascent = statusfont.font->ascent;
	statusfont.descent = statusfont.font->descent;
	statusfont.height = statusfont.font->height;
	return 1;
}

static void
freestatusfont(void)
{
	if (statusfont.font)
		fcft_destroy(statusfont.font);
	statusfont.font = NULL;
}

static void
positionstatusmodules(Monitor *m)
{
	int x, spacing;

	if (!m || !m->statusbar.tree)
		return;

	if (!m->showbar || !m->statusbar.area.width || !m->statusbar.area.height) {
		wlr_scene_node_set_enabled(&m->statusbar.tree->node, 0);
		if (m->statusbar.tags.tree) {
			wlr_scene_node_set_enabled(&m->statusbar.tags.tree->node, 0);
			m->statusbar.tags.x = 0;
		}
		if (m->statusbar.traylabel.tree) {
			wlr_scene_node_set_enabled(&m->statusbar.traylabel.tree->node, 0);
			m->statusbar.traylabel.x = 0;
		}
		if (m->statusbar.sysicons.tree) {
			wlr_scene_node_set_enabled(&m->statusbar.sysicons.tree->node, 0);
			m->statusbar.sysicons.x = 0;
		}
		if (m->statusbar.bluetooth.tree) {
			wlr_scene_node_set_enabled(&m->statusbar.bluetooth.tree->node, 0);
			m->statusbar.bluetooth.x = 0;
		}
		if (m->statusbar.steam.tree) {
			wlr_scene_node_set_enabled(&m->statusbar.steam.tree->node, 0);
			m->statusbar.steam.x = 0;
		}
		if (m->statusbar.discord.tree) {
			wlr_scene_node_set_enabled(&m->statusbar.discord.tree->node, 0);
			m->statusbar.discord.x = 0;
		}
		if (m->statusbar.tray_menu.tree) {
			wlr_scene_node_set_enabled(&m->statusbar.tray_menu.tree->node, 0);
			m->statusbar.tray_menu.visible = 0;
		}
		if (m->statusbar.cpu.tree) {
			wlr_scene_node_set_enabled(&m->statusbar.cpu.tree->node, 0);
			m->statusbar.cpu.x = 0;
		}
		if (m->statusbar.net.tree) {
			wlr_scene_node_set_enabled(&m->statusbar.net.tree->node, 0);
			m->statusbar.net.x = 0;
		}
		if (m->statusbar.battery.tree) {
			wlr_scene_node_set_enabled(&m->statusbar.battery.tree->node, 0);
			m->statusbar.battery.x = 0;
		}
			if (m->statusbar.light.tree) {
				wlr_scene_node_set_enabled(&m->statusbar.light.tree->node, 0);
				m->statusbar.light.x = 0;
			}
			if (m->statusbar.mic.tree) {
				wlr_scene_node_set_enabled(&m->statusbar.mic.tree->node, 0);
				m->statusbar.mic.x = 0;
			}
			if (m->statusbar.volume.tree) {
				wlr_scene_node_set_enabled(&m->statusbar.volume.tree->node, 0);
				m->statusbar.volume.x = 0;
			}
		if (m->statusbar.ram.tree) {
			wlr_scene_node_set_enabled(&m->statusbar.ram.tree->node, 0);
			m->statusbar.ram.x = 0;
		}
		if (m->statusbar.clock.tree) {
			wlr_scene_node_set_enabled(&m->statusbar.clock.tree->node, 0);
			m->statusbar.clock.x = 0;
		}
		if (m->statusbar.cpu_popup.tree) {
			wlr_scene_node_set_enabled(&m->statusbar.cpu_popup.tree->node, 0);
			m->statusbar.cpu_popup.visible = 0;
		}
		if (m->statusbar.net_popup.tree) {
			wlr_scene_node_set_enabled(&m->statusbar.net_popup.tree->node, 0);
			m->statusbar.net_popup.visible = 0;
		}
		return;
	}

	wlr_scene_node_set_enabled(&m->statusbar.tree->node, 1);
	if (m->statusbar.tags.tree)
		wlr_scene_node_set_enabled(&m->statusbar.tags.tree->node,
				m->statusbar.tags.width > 0);
	if (m->statusbar.traylabel.tree)
		wlr_scene_node_set_enabled(&m->statusbar.traylabel.tree->node,
				m->statusbar.traylabel.width > 0);
	if (m->statusbar.sysicons.tree)
		wlr_scene_node_set_enabled(&m->statusbar.sysicons.tree->node,
				m->statusbar.sysicons.width > 0);
	if (m->statusbar.bluetooth.tree)
		wlr_scene_node_set_enabled(&m->statusbar.bluetooth.tree->node,
				m->statusbar.bluetooth.width > 0);
	if (m->statusbar.steam.tree)
		wlr_scene_node_set_enabled(&m->statusbar.steam.tree->node,
				m->statusbar.steam.width > 0);
	if (m->statusbar.discord.tree)
		wlr_scene_node_set_enabled(&m->statusbar.discord.tree->node,
				m->statusbar.discord.width > 0);
	if (m->statusbar.cpu.tree)
		wlr_scene_node_set_enabled(&m->statusbar.cpu.tree->node,
				m->statusbar.cpu.width > 0);
	if (m->statusbar.net.tree)
		wlr_scene_node_set_enabled(&m->statusbar.net.tree->node,
				m->statusbar.net.width > 0);
	if (m->statusbar.battery.tree)
		wlr_scene_node_set_enabled(&m->statusbar.battery.tree->node,
				m->statusbar.battery.width > 0);
	if (m->statusbar.light.tree)
		wlr_scene_node_set_enabled(&m->statusbar.light.tree->node,
				m->statusbar.light.width > 0);
	if (m->statusbar.mic.tree)
		wlr_scene_node_set_enabled(&m->statusbar.mic.tree->node,
				m->statusbar.mic.width > 0);
	if (m->statusbar.volume.tree)
		wlr_scene_node_set_enabled(&m->statusbar.volume.tree->node,
				m->statusbar.volume.width > 0);
	if (m->statusbar.ram.tree)
		wlr_scene_node_set_enabled(&m->statusbar.ram.tree->node,
				m->statusbar.ram.width > 0);
	if (m->statusbar.clock.tree)
		wlr_scene_node_set_enabled(&m->statusbar.clock.tree->node,
				m->statusbar.clock.width > 0);
	if (m->statusbar.cpu_popup.tree && m->statusbar.cpu.width > 0) {
		if (!m->statusbar.cpu_popup.visible)
			wlr_scene_node_set_enabled(&m->statusbar.cpu_popup.tree->node, 0);
	}
	x = 0;
	spacing = statusbar_module_spacing;

	if (m->statusbar.tags.width > 0) {
		wlr_scene_node_set_position(&m->statusbar.tags.tree->node, x, 0);
		m->statusbar.tags.x = x;
		x += m->statusbar.tags.width + spacing;
	}
	/* Group connection-related icons together with minimal spacing */
	if (m->statusbar.sysicons.width > 0) {
		wlr_scene_node_set_position(&m->statusbar.sysicons.tree->node, x, 0);
		m->statusbar.sysicons.x = x;
		x += m->statusbar.sysicons.width + 2;
	}
	if (m->statusbar.bluetooth.width > 0) {
		wlr_scene_node_set_position(&m->statusbar.bluetooth.tree->node, x, 0);
		m->statusbar.bluetooth.x = x;
		x += m->statusbar.bluetooth.width + 2;
	}
	if (m->statusbar.steam.width > 0) {
		wlr_scene_node_set_position(&m->statusbar.steam.tree->node, x, 0);
		m->statusbar.steam.x = x;
		x += m->statusbar.steam.width + 2;
	}
	if (m->statusbar.discord.width > 0) {
		wlr_scene_node_set_position(&m->statusbar.discord.tree->node, x, 0);
		m->statusbar.discord.x = x;
		x += m->statusbar.discord.width + spacing;
	}
	if (m->statusbar.net.width > 0) {
		wlr_scene_node_set_position(&m->statusbar.net.tree->node, x, 0);
		m->statusbar.net.x = x;
		x += m->statusbar.net.width + spacing;
	}
	if (m->statusbar.traylabel.width > 0) {
		wlr_scene_node_set_position(&m->statusbar.traylabel.tree->node, x, 0);
		m->statusbar.traylabel.x = x;
		x += m->statusbar.traylabel.width + spacing;
	}

	x = m->statusbar.area.width;
	spacing = statusbar_module_spacing;

	if (m->statusbar.clock.width > 0) {
		x -= m->statusbar.clock.width;
		wlr_scene_node_set_position(&m->statusbar.clock.tree->node, x, 0);
		m->statusbar.clock.x = x;
		x -= spacing;
	}
	if (m->statusbar.ram.width > 0) {
		x -= m->statusbar.ram.width;
		wlr_scene_node_set_position(&m->statusbar.ram.tree->node, x, 0);
		m->statusbar.ram.x = x;
		x -= spacing;
	}
	if (m->statusbar.cpu.width > 0) {
		x -= m->statusbar.cpu.width;
		wlr_scene_node_set_position(&m->statusbar.cpu.tree->node, x, 0);
		m->statusbar.cpu.x = x;
		x -= spacing;
	}
	if (m->statusbar.mic.width > 0) {
		x -= m->statusbar.mic.width;
		wlr_scene_node_set_position(&m->statusbar.mic.tree->node, x, 0);
		m->statusbar.mic.x = x;
		x -= spacing;
	}
	if (m->statusbar.volume.width > 0) {
		x -= m->statusbar.volume.width;
		wlr_scene_node_set_position(&m->statusbar.volume.tree->node, x, 0);
		m->statusbar.volume.x = x;
		x -= spacing;
	}
	if (m->statusbar.light.width > 0) {
		x -= m->statusbar.light.width;
		wlr_scene_node_set_position(&m->statusbar.light.tree->node, x, 0);
		m->statusbar.light.x = x;
		x -= spacing;
	}
	if (m->statusbar.battery.width > 0) {
		x -= m->statusbar.battery.width;
		wlr_scene_node_set_position(&m->statusbar.battery.tree->node, x, 0);
		m->statusbar.battery.x = x;
		x -= spacing;
	}
	if (m->statusbar.cpu_popup.tree) {
		if (m->statusbar.cpu.width > 0 && m->statusbar.area.height > 0) {
			int popup_x = m->statusbar.cpu.x;
			int max_x = m->statusbar.area.width - m->statusbar.cpu_popup.width;
			if (max_x < 0)
				max_x = 0;
			if (popup_x > max_x)
				popup_x = max_x;
			if (popup_x < 0)
				popup_x = 0;
			wlr_scene_node_set_position(&m->statusbar.cpu_popup.tree->node,
					popup_x, m->statusbar.area.height);
			m->statusbar.cpu_popup.refresh_data = 1;
		} else {
			wlr_scene_node_set_enabled(&m->statusbar.cpu_popup.tree->node, 0);
			m->statusbar.cpu_popup.visible = 0;
			m->statusbar.cpu_popup.refresh_data = 0;
		}
	}
	if (m->statusbar.net_popup.tree) {
		int icon_w = m->statusbar.sysicons.width;
		int pos_x = icon_w > 0 ? m->statusbar.sysicons.x : m->statusbar.net_popup.anchor_x;

		if (m->statusbar.area.height > 0) {
			wlr_scene_node_set_position(&m->statusbar.net_popup.tree->node,
					pos_x, m->statusbar.area.height);
			if (icon_w > 0) {
				m->statusbar.net_popup.anchor_x = pos_x;
				m->statusbar.net_popup.anchor_y = m->statusbar.area.height;
				m->statusbar.net_popup.anchor_w = icon_w;
			}
			if (!m->statusbar.net_popup.visible)
				wlr_scene_node_set_enabled(&m->statusbar.net_popup.tree->node, 0);
		} else {
			wlr_scene_node_set_enabled(&m->statusbar.net_popup.tree->node, 0);
			m->statusbar.net_popup.visible = 0;
		}
	}
	if (m->statusbar.tray_menu.tree) {
		if (m->statusbar.tray_menu.visible && m->statusbar.area.height > 0) {
			int max_x = m->statusbar.area.width - m->statusbar.tray_menu.width;
			int menu_x = m->statusbar.tray_menu.x;
			if (max_x < 0)
				max_x = 0;
			if (menu_x > max_x)
				menu_x = max_x;
			if (menu_x < 0)
				menu_x = 0;
			m->statusbar.tray_menu.x = menu_x;
			m->statusbar.tray_menu.y = m->statusbar.area.height;
			wlr_scene_node_set_position(&m->statusbar.tray_menu.tree->node,
					m->statusbar.tray_menu.x, m->statusbar.tray_menu.y);
			wlr_scene_node_set_enabled(&m->statusbar.tray_menu.tree->node, 1);
		} else {
			wlr_scene_node_set_enabled(&m->statusbar.tray_menu.tree->node, 0);
			m->statusbar.tray_menu.visible = 0;
		}
	}
}

static int
wifi_network_exists(const char *ssid)
{
	WifiNetwork *it;

	if (!ssid || !*ssid)
		return 0;
	wl_list_for_each(it, &wifi_networks, link) {
		if (strncmp(it->ssid, ssid, sizeof(it->ssid)) == 0)
			return 1;
	}
	return 0;
}

static void
wifi_networks_insert_sorted(WifiNetwork *n)
{
	WifiNetwork *it;

	/* de-duplicate by SSID, keep strongest and mark secure if any entry is secure */
	wl_list_for_each(it, &wifi_networks, link) {
		if (strncmp(it->ssid, n->ssid, sizeof(it->ssid)) == 0) {
			if (n->strength > it->strength)
				it->strength = n->strength;
			if (n->secure)
				it->secure = 1;
			free(n);
			return;
		}
	}

	wl_list_for_each(it, &wifi_networks, link) {
		if (n->strength > it->strength) {
			wl_list_insert(it->link.prev, &n->link);
			return;
		}
	}
	wl_list_insert(wifi_networks.prev, &n->link);
}

static void
wifi_scan_finish(void)
{
	if (wifi_scan_event) {
		wl_event_source_remove(wifi_scan_event);
		wifi_scan_event = NULL;
	}
	if (wifi_scan_fd >= 0) {
		close(wifi_scan_fd);
		wifi_scan_fd = -1;
	}
	if (wifi_scan_pid > 0) {
		waitpid(wifi_scan_pid, NULL, WNOHANG);
		wifi_scan_pid = -1;
	}
	wifi_scan_inflight = 0;
}

static int
wifi_scan_event_cb(int fd, uint32_t mask, void *data)
{
	ssize_t n;
	char *saveptr = NULL;
	char *line;
	int discard_results;
	(void)data;

	discard_results = (!wifi_networks_accept_updates)
			|| (wifi_scan_generation != wifi_networks_generation);

	for (;;) {
		if (wifi_scan_len >= sizeof(wifi_scan_buf) - 1)
			break;
		n = read(fd, wifi_scan_buf + wifi_scan_len,
				sizeof(wifi_scan_buf) - 1 - wifi_scan_len);
		if (n > 0) {
			wifi_scan_len += (size_t)n;
			continue;
		} else if (n == 0) {
			break;
		} else if (errno == EAGAIN || errno == EWOULDBLOCK) {
			return 0;
		} else {
			break;
		}
	}

	wifi_scan_buf[wifi_scan_len] = '\0';

	if (discard_results) {
		wifi_scan_finish();
		if (wifi_networks_accept_updates && !wifi_scan_inflight)
			request_wifi_scan();
		wifi_scan_plan_rescan();
		return 0;
	}

	if (!wifi_networks_freeze_existing)
		wifi_networks_clear();

	line = strtok_r(wifi_scan_buf, "\n", &saveptr);
	while (line) {
		char *sig_s, *sec_s;
		WifiNetwork *nentry;
		int strength = 0;
		int secure = 0;
		char ssid[128] = {0};

		sig_s = strchr(line, ':');
		if (sig_s) {
			*sig_s = '\0';
			sig_s++;
			sec_s = strchr(sig_s, ':');
			if (sec_s) {
				*sec_s = '\0';
				sec_s++;
			}
		} else {
			sec_s = NULL;
		}

		if (line[0])
			snprintf(ssid, sizeof(ssid), "%s", line);
		if (!ssid[0]) {
			line = strtok_r(NULL, "\n", &saveptr);
			continue;
		}
		if (wifi_networks_freeze_existing && wifi_network_exists(ssid)) {
			line = strtok_r(NULL, "\n", &saveptr);
			continue;
		}
		if (sig_s)
			strength = atoi(sig_s);
		if (sec_s && *sec_s && strcmp(sec_s, "--") != 0)
			secure = 1;

		nentry = ecalloc(1, sizeof(*nentry));
		snprintf(nentry->ssid, sizeof(nentry->ssid), "%s", ssid);
		nentry->strength = strength;
		nentry->secure = secure;
		wifi_networks_insert_sorted(nentry);

		line = strtok_r(NULL, "\n", &saveptr);
	}

	wifi_scan_finish();

	/* Update submenu if visible and showing WiFi */
	{
		Monitor *m;
		wl_list_for_each(m, &mons, link) {
			if (m->statusbar.net_menu.visible && m->statusbar.net_menu.submenu_type == 0) {
				net_menu_submenu_render(m);
				if (m->statusbar.net_menu.submenu_tree)
					wlr_scene_node_set_position(&m->statusbar.net_menu.submenu_tree->node,
							m->statusbar.net_menu.submenu_x, m->statusbar.net_menu.submenu_y);
			}
		}
	}
	wifi_scan_plan_rescan();
	return 0;
}

static void
wifi_scan_plan_rescan(void)
{
	if (wifi_scan_timer)
		wl_event_source_timer_update(wifi_scan_timer, 500);
}

static int
wifi_scan_timer_cb(void *data)
{
	Monitor *m;
	int visible = 0;
	(void)data;

	wl_list_for_each(m, &mons, link) {
		if (m->statusbar.net_menu.visible) {
			visible = 1;
			break;
		}
	}

	if (!visible)
		return 0;

	if (!wifi_scan_inflight)
		request_wifi_scan();

	/* Always reschedule while menu is visible */
	wifi_scan_plan_rescan();

	return 0;
}

static int
cpu_popup_refresh_timeout(void *data)
{
	Monitor *m;
	int any_visible = 0;

	(void)data;

	wl_list_for_each(m, &mons, link) {
		CpuPopup *p = &m->statusbar.cpu_popup;
		if (!p || !p->tree || !p->visible)
			continue;
		p->suppress_refresh_until_ms = 0;
		p->refresh_data = 1;
		rendercpupopup(m);
		any_visible = 1;
	}

	if (any_visible)
		wl_event_source_timer_update(cpu_popup_refresh_timer, cpu_popup_refresh_interval_ms);

	return 0;
}

static void
schedule_cpu_popup_refresh(uint32_t ms)
{
	if (!event_loop)
		return;
	if (!cpu_popup_refresh_timer)
		cpu_popup_refresh_timer = wl_event_loop_add_timer(event_loop,
				cpu_popup_refresh_timeout, NULL);
	if (cpu_popup_refresh_timer)
		wl_event_source_timer_update(cpu_popup_refresh_timer, ms);
}

static int
popup_delay_timeout(void *data)
{
	Monitor *m;
	(void)data;

	wl_list_for_each(m, &mons, link) {
		if (!m->showbar)
			continue;
		/* Re-run hover checks to show popup after delay */
		if (m->statusbar.cpu_popup.hover_start_ms != 0 && !m->statusbar.cpu_popup.visible)
			updatecpuhover(m, cursor->x, cursor->y);
		if (m->statusbar.ram_popup.hover_start_ms != 0 && !m->statusbar.ram_popup.visible)
			updateramhover(m, cursor->x, cursor->y);
		if (m->statusbar.battery_popup.hover_start_ms != 0 && !m->statusbar.battery_popup.visible)
			updatebatteryhover(m, cursor->x, cursor->y);
		if (m->statusbar.net_popup.hover_start_ms != 0 && !m->statusbar.net_popup.visible)
			updatenethover(m, cursor->x, cursor->y);
	}
	return 0;
}

static void
schedule_popup_delay(uint32_t ms)
{
	if (!event_loop)
		return;
	if (!popup_delay_timer)
		popup_delay_timer = wl_event_loop_add_timer(event_loop,
				popup_delay_timeout, NULL);
	if (popup_delay_timer)
		wl_event_source_timer_update(popup_delay_timer, ms);
}

/*
 * Game refocus timer - re-focuses game clients after a short delay.
 * This fixes keyboard input not working immediately for XWayland games
 * (like Witcher 3 via Steam/Proton) which need time to fully initialize
 * their input handling after the window maps.
 */
static int
game_refocus_timer_cb(void *data)
{
	Client *c = game_refocus_client;
	(void)data;

	game_refocus_client = NULL;

	if (!c || !client_surface(c) || !client_surface(c)->mapped)
		return 0;

	/* Only refocus if this client is still the focused client */
	if (seat->keyboard_state.focused_surface != client_surface(c))
		return 0;

	wlr_log(WLR_INFO, "game_refocus: re-focusing game '%s' after delay",
		client_get_appid(c) ? client_get_appid(c) : "(unknown)");

	/* Re-send keyboard enter to ensure the client has focus */
	struct wlr_keyboard *kb = wlr_seat_get_keyboard(seat);
	client_notify_enter(client_surface(c), kb);
	client_activate_surface(client_surface(c), 1);

#ifdef XWAYLAND
	/* For XWayland clients, also re-activate the X11 surface */
	if (c->type == X11 && c->surface.xwayland) {
		wlr_xwayland_surface_activate(c->surface.xwayland, 1);
		wlr_xwayland_surface_restack(c->surface.xwayland, NULL, XCB_STACK_MODE_ABOVE);
	}
#endif

	return 0;
}

static void
schedule_game_refocus(Client *c, uint32_t ms)
{
	if (!event_loop || !c)
		return;
	if (!game_refocus_timer)
		game_refocus_timer = wl_event_loop_add_timer(event_loop,
				game_refocus_timer_cb, NULL);
	if (game_refocus_timer) {
		game_refocus_client = c;
		wl_event_source_timer_update(game_refocus_timer, ms);
	}
}

static void request_vpn_scan(void);

static void
net_menu_open(Monitor *m)
{
	const int offset = statusbar_module_padding;
	int desired_x, max_x;
	NetMenu *menu;

	if (!m || !m->showbar || !m->statusbar.net_menu.tree || !m->statusbar.sysicons.tree)
		return;
	if (!m->statusbar.area.width || !m->statusbar.area.height)
		return;

	menu = &m->statusbar.net_menu;
	net_menu_hide_all();
	wifi_networks_generation++;
	wifi_networks_accept_updates = 1;
	wifi_networks_freeze_existing = 0;
	wifi_networks_clear();
	if (m->statusbar.net_popup.tree) {
		wlr_scene_node_set_enabled(&m->statusbar.net_popup.tree->node, 0);
		m->statusbar.net_popup.visible = 0;
	}
	/* Pre-fetch both WiFi and VPN data */
	request_wifi_scan();
	request_vpn_scan();
	net_menu_render(m);
	if (menu->width <= 0 || menu->height <= 0)
		return;

	desired_x = m->statusbar.sysicons.x - menu->width / 2 + m->statusbar.sysicons.width / 2;
	if (desired_x < 0)
		desired_x = 0;
	max_x = m->statusbar.area.width - menu->width;
	if (max_x < 0)
		max_x = 0;
	if (desired_x > max_x)
		desired_x = max_x;

	menu->x = desired_x;
	menu->y = m->statusbar.area.height + statusbar_module_padding;
	wlr_scene_node_set_position(&menu->tree->node, menu->x, menu->y);
	wlr_scene_node_set_enabled(&menu->tree->node, 1);
	menu->visible = 1;
	menu->hover = -1;  /* No row hovered initially */
	menu->submenu_visible = 0;
	menu->submenu_type = -1;

	menu->submenu_x = menu->x + menu->width + offset;
	menu->submenu_y = menu->y + offset;
	/* Don't show submenu automatically - wait for hover */
	if (menu->submenu_tree) {
		wlr_scene_node_set_enabled(&menu->submenu_tree->node, 0);
	}
	wifi_scan_plan_rescan();
}

static void
net_menu_update_hover(Monitor *m, double cx, double cy)
{
	NetMenu *menu;
	int lx, ly;
	int row_h, padding;
	int prev_hover, prev_sub, prev_submenu_type;
	int new_hover = -1, new_sub = -1;
	int show_submenu = 0;
	const int offset = statusbar_module_padding;

	if (!m || !m->statusbar.net_menu.visible || !m->statusbar.net_menu.submenu_tree)
		return;
	menu = &m->statusbar.net_menu;
	lx = (int)floor(cx) - m->statusbar.area.x;
	ly = (int)floor(cy) - m->statusbar.area.y;
	padding = statusbar_module_padding;
	row_h = statusfont.height + 4;
	if (row_h < statusfont.height)
		row_h = statusfont.height;

	/* Check if hovering over main menu rows */
	if (lx >= menu->x && lx < menu->x + menu->width &&
			ly >= menu->y && ly < menu->y + menu->height) {
		int rel_y = ly - menu->y - padding;
		if (rel_y >= 0 && rel_y < row_h) {
			new_hover = 0;  /* WiFi row */
		} else if (rel_y >= row_h && rel_y < 2 * row_h) {
			new_hover = 1;  /* VPN row */
		}
	}

	/* Check if hovering over submenu */
	if (menu->submenu_visible &&
			lx >= menu->submenu_x && lx < menu->submenu_x + menu->submenu_width &&
			ly >= menu->submenu_y && ly < menu->submenu_y + menu->submenu_height) {
		/* Keep current main menu hover when in submenu */
		new_hover = menu->hover;
		if (menu->submenu_type == 0) {
			/* WiFi submenu */
			if (!wl_list_empty(&wifi_networks)) {
				int rel_y = ly - menu->submenu_y - padding;
				if (rel_y >= 0) {
					new_sub = rel_y / row_h;
				}
			}
		} else if (menu->submenu_type == 1) {
			/* VPN submenu */
			if (!wl_list_empty(&vpn_connections)) {
				int rel_y = ly - menu->submenu_y - padding;
				if (rel_y >= 0) {
					new_sub = rel_y / row_h;
				}
			}
		}
	}

	prev_hover = menu->hover;
	prev_sub = menu->submenu_hover;
	prev_submenu_type = menu->submenu_type;
	menu->hover = new_hover;
	menu->submenu_hover = new_sub;

	/* Determine if we should show submenu and which type */
	if (new_hover == 0) {
		menu->submenu_type = 0;  /* WiFi */
		show_submenu = 1;
		/* Adjust submenu Y position for WiFi row */
		menu->submenu_y = menu->y + offset;
	} else if (new_hover == 1) {
		menu->submenu_type = 1;  /* VPN */
		show_submenu = 1;
		/* Adjust submenu Y position for VPN row */
		menu->submenu_y = menu->y + row_h + offset;
	} else if (new_hover == -1 && !menu->submenu_visible) {
		/* Not hovering over anything and submenu not visible */
		show_submenu = 0;
	} else {
		/* Keep submenu if hovering over it */
		show_submenu = menu->submenu_visible;
	}

	if (menu->hover != prev_hover)
		net_menu_render(m);

	if (show_submenu) {
		if (menu->submenu_type != prev_submenu_type || !menu->submenu_visible) {
			menu->submenu_hover = -1;
			net_menu_submenu_render(m);
			wlr_scene_node_set_position(&menu->submenu_tree->node, menu->submenu_x, menu->submenu_y);
		} else if (menu->submenu_hover != prev_sub) {
			net_menu_submenu_render(m);
			wlr_scene_node_set_position(&menu->submenu_tree->node, menu->submenu_x, menu->submenu_y);
		}
	} else if (menu->submenu_visible) {
		/* Hide submenu */
		wlr_scene_node_set_enabled(&menu->submenu_tree->node, 0);
		menu->submenu_visible = 0;
	}
}

static WifiNetwork *
wifi_network_at_index(int idx)
{
	WifiNetwork *n;
	int i = 0;
	wl_list_for_each(n, &wifi_networks, link) {
		if (i == idx)
			return n;
		i++;
	}
	return NULL;
}

static int
net_menu_handle_click(Monitor *m, int lx, int ly, uint32_t button)
{
	NetMenu *menu;
	int padding = statusbar_module_padding;
	int row_h;

	if (!m || !m->statusbar.net_menu.visible)
		return 0;
	menu = &m->statusbar.net_menu;
	row_h = statusfont.height + 4;
	if (row_h < statusfont.height)
		row_h = statusfont.height;

	if (lx >= menu->x && lx < menu->x + menu->width &&
			ly >= menu->y && ly < menu->y + menu->height) {
		/* main menu rows - just consume click, hover handles submenu */
		return 1;
	}

	if (menu->submenu_visible &&
			lx >= menu->submenu_x && lx < menu->submenu_x + menu->submenu_width &&
			ly >= menu->submenu_y && ly < menu->submenu_y + menu->submenu_height) {
		if (button != BTN_LEFT)
			return 1;

		int rel_y = ly - menu->submenu_y - padding;
		int idx = rel_y / row_h;

		if (menu->submenu_type == 0) {
			/* WiFi submenu */
			if (!wl_list_empty(&wifi_networks) && rel_y >= 0) {
				WifiNetwork *n = wifi_network_at_index(idx);
				if (n) {
					/* Copy SSID before hiding menu - net_menu_hide_all() frees WifiNetwork structs */
					char ssid_copy[128];
					int secure = n->secure;
					snprintf(ssid_copy, sizeof(ssid_copy), "%s", n->ssid);
					net_menu_hide_all();
					if (secure) {
						/* Secure network: try saved credentials first,
						 * password popup will appear if not saved */
						wifi_try_saved_connect(m, ssid_copy);
					} else {
						/* Open network: connect directly without password */
						connect_wifi_ssid(ssid_copy);
					}
					return 1;
				}
			}
		} else if (menu->submenu_type == 1) {
			/* VPN submenu */
			if (!wl_list_empty(&vpn_connections) && rel_y >= 0) {
				VpnConnection *v = vpn_connection_at_index(idx);
				if (v) {
					/* Copy name before hiding menu */
					char name_copy[128];
					snprintf(name_copy, sizeof(name_copy), "%s", v->name);
					net_menu_hide_all();
					/* Connect to VPN immediately */
					vpn_connect(name_copy);
					return 1;
				}
			}
		}
		return 1;
	}

	net_menu_hide_all();
	return 1;
}

static void
layoutstatusbar(Monitor *m, const struct wlr_box *area, struct wlr_box *client_area)
{
	int gap, bar_height;
	struct wlr_box bar_area = {0};

	if (!m || !m->statusbar.tree || !area || !client_area)
		return;

	if (!m->showbar) {
		wlr_scene_node_set_enabled(&m->statusbar.tree->node, 0);
		hidetagthumbnail(m);
		*client_area = *area;
		m->statusbar.area = (struct wlr_box){0};
		return;
	}

	gap = m->gaps ? gappx : 0;
	bar_height = MIN((int)statusbar_height, area->height);

	bar_area.x = area->x + gap;
	bar_area.y = area->y + statusbar_top_gap;
	bar_area.width = area->width - 2 * gap;
	bar_area.height = bar_height;

	if (bar_area.width < 0)
		bar_area.width = 0;
	if (bar_area.height < 0)
		bar_area.height = 0;

	wlr_scene_node_set_enabled(&m->statusbar.tree->node, 1);
	wlr_scene_node_set_position(&m->statusbar.tree->node, bar_area.x, bar_area.y);
	m->statusbar.area = bar_area;

	renderworkspaces(m, &m->statusbar.tags, bar_area.height);
	if (m->statusbar.traylabel.tree) {
		clearstatusmodule(&m->statusbar.traylabel);
		m->statusbar.traylabel.width = 0;
		wlr_scene_node_set_enabled(&m->statusbar.traylabel.tree->node, 0);
	}
	if (m->statusbar.sysicons.tree)
		rendertrayicons(m, bar_area.height);
	if (m->statusbar.bluetooth.tree)
		renderbluetooth(m, bar_area.height);
	if (m->statusbar.steam.tree)
		rendersteam(m, bar_area.height);
	if (m->statusbar.discord.tree)
		renderdiscord(m, bar_area.height);
	if (m->statusbar.cpu.tree)
		rendercpu(&m->statusbar.cpu, bar_area.height, cpu_text);
	if (m->statusbar.net.tree)
		rendernet(&m->statusbar.net, bar_area.height, net_text);
	if (m->statusbar.light.tree)
		renderlight(&m->statusbar.light, bar_area.height, light_text);
	if (m->statusbar.battery.tree)
		renderbattery(&m->statusbar.battery, bar_area.height, battery_text);
	if (m->statusbar.volume.tree)
		rendervolume(&m->statusbar.volume, bar_area.height, volume_text);
	if (m->statusbar.ram.tree)
		renderram(&m->statusbar.ram, bar_area.height, ram_text);
	if (m->statusbar.cpu_popup.tree && m->statusbar.cpu_popup.visible)
		rendercpupopup(m);
	if (m->statusbar.net_popup.tree && m->statusbar.net_popup.visible)
		rendernetpopup(m);
	positionstatusmodules(m);

	*client_area = *area;
	client_area->y = area->y + statusbar_top_gap + bar_area.height;
	client_area->height = area->height - bar_area.height - statusbar_top_gap;
	if (client_area->height < 0)
		client_area->height = 0;
}

static void
refreshstatusclock(void)
{
	time_t now;
	struct tm tm;
	char timestr[6] = {0};
	Monitor *m;
	int barh;

	now = time(NULL);
	if (now == (time_t)-1)
		return;
	if (!localtime_r(&now, &tm))
		return;
	if (!strftime(timestr, sizeof(timestr), "%H:%M", &tm))
		return;

	wl_list_for_each(m, &mons, link) {
		if (!m->statusbar.clock.tree || !m->showbar)
			continue;
		barh = m->statusbar.area.height ? m->statusbar.area.height : (int)statusbar_height;
		renderclock(&m->statusbar.clock, barh, timestr);
		positionstatusmodules(m);
	}
}

static void
refreshstatuslight(void)
{
	Monitor *m;
	int barh;
	double percent, display;

	if (!backlight_paths_initialized) {
		backlight_available = findbacklightdevice(backlight_brightness_path,
				sizeof(backlight_brightness_path),
				backlight_max_path, sizeof(backlight_max_path));
		if (!backlight_available)
			backlight_writable = 0;
		backlight_paths_initialized = 1;
	}

	percent = backlight_percent();
	display = percent;

	if (percent >= 0.0) {
		light_last_percent = percent;
		display = percent;
	} else if (light_last_percent >= 0.0) {
		display = light_last_percent;
	}

	if (display < 0.0) {
		snprintf(light_text, sizeof(light_text), "--%%");
	} else {
		if (display > 100.0)
			display = 100.0;
		if (display < 0.0)
			display = 0.0;
		snprintf(light_text, sizeof(light_text), "%d%%", (int)lround(display));
	}

	wl_list_for_each(m, &mons, link) {
		if (!m->statusbar.light.tree || !m->showbar)
			continue;
		barh = m->statusbar.area.height ? m->statusbar.area.height : (int)statusbar_height;
		if (status_should_render(&m->statusbar.light, barh, light_text,
					last_light_render, sizeof(last_light_render), &last_light_h)) {
			renderlight(&m->statusbar.light, barh, light_text);
			positionstatusmodules(m);
		}
	}
}

static void
refreshstatusnet(void)
	{
		Monitor *m;
		int barh;
		char iface[IF_NAMESIZE] = {0};
		char path[PATH_MAX];
		time_t now_sec = time(NULL);
		unsigned long long rx = 0, tx = 0;
	struct timespec now_ts = {0};
	double elapsed = 0.0;
	int rx_ok = 0, tx_ok = 0;
	double wifi_quality = -1.0;
	const char *icon_path = net_icon_no_conn_resolved[0] ? net_icon_no_conn_resolved : net_icon_no_conn;
	int link_speed = -1;
	int popup_active = 0;

	wl_list_for_each(m, &mons, link) {
		if (m->statusbar.net_popup.visible) {
			popup_active = 1;
			break;
		}
	}
	net_available = findactiveinterface(iface, sizeof(iface), &net_is_wireless);
	if (!net_available) {
		snprintf(net_text, sizeof(net_text), "Net: --");
		snprintf(net_local_ip, sizeof(net_local_ip), "--");
		snprintf(net_down_text, sizeof(net_down_text), "--");
		snprintf(net_up_text, sizeof(net_up_text), "--");
		snprintf(net_ssid, sizeof(net_ssid), "--");
		net_last_wifi_quality = -1.0;
		net_link_speed_mbps = -1;
		net_last_down_bps = net_last_up_bps = -1.0;
		net_prev_valid = 0;
		net_prev_iface[0] = '\0';
		stop_ssid_fetch();
		ssid_last_time = 0;
	} else {
		int need_ssid;

		snprintf(net_iface, sizeof(net_iface), "%s", iface);
		if (strncmp(net_prev_iface, net_iface, sizeof(net_prev_iface)) != 0) {
			net_prev_valid = 0;
			net_prev_rx = net_prev_tx = 0;
			snprintf(net_prev_iface, sizeof(net_prev_iface), "%s", net_iface);
			if (net_is_wireless) {
				stop_ssid_fetch();
				ssid_last_time = 0;
			}
		}

		if (net_is_wireless) {
			need_ssid = (!net_ssid[0] || strcmp(net_ssid, "--") == 0 ||
					(now_sec != (time_t)-1 &&
					 (now_sec - ssid_last_time > 60 || ssid_last_time == 0)));
			if ((popup_active || need_ssid) && now_sec != (time_t)-1 &&
					!ssid_event && ssid_pid <= 0) {
				request_ssid_async(net_iface);
			}
			if (!net_ssid[0])
				snprintf(net_ssid, sizeof(net_ssid), "WiFi");
			snprintf(net_text, sizeof(net_text), "WiFi: %s", net_ssid);
		} else {
			stop_ssid_fetch();
			ssid_last_time = 0;
			snprintf(net_text, sizeof(net_text), "Wired");
			snprintf(net_ssid, sizeof(net_ssid), "Ethernet");
		}

		if (!net_is_wireless) {
			icon_path = net_icon_eth_resolved[0] ? net_icon_eth_resolved : net_icon_eth;
			if (readlinkspeedmbps(net_iface, &link_speed) == 0)
				net_link_speed_mbps = link_speed;
			else
				net_link_speed_mbps = -1;
			net_last_wifi_quality = -1.0;
		} else {
			wifi_quality = wireless_signal_percent(net_iface);
			if (wifi_quality < 0.0)
				wifi_quality = 50.0;
			icon_path = wifi_icon_for_quality(wifi_quality);
			net_last_wifi_quality = wifi_quality;
			if (readlinkspeedmbps(net_iface, &link_speed) == 0)
				net_link_speed_mbps = link_speed;
			else
				net_link_speed_mbps = -1;
		}

		if (!localip(net_iface, net_local_ip, sizeof(net_local_ip)))
			snprintf(net_local_ip, sizeof(net_local_ip), "--");

		if (popup_active)
			request_public_ip_async_ex(1); /* force update when hovering */

		clock_gettime(CLOCK_MONOTONIC, &now_ts);

		if (popup_active) {
			if (snprintf(path, sizeof(path), "/sys/class/net/%s/statistics/rx_bytes", net_iface)
					< (int)sizeof(path))
				rx_ok = (readulong(path, &rx) == 0);
			if (snprintf(path, sizeof(path), "/sys/class/net/%s/statistics/tx_bytes", net_iface)
					< (int)sizeof(path))
				tx_ok = (readulong(path, &tx) == 0);

			if (net_prev_valid) {
				elapsed = (now_ts.tv_sec - net_prev_ts.tv_sec)
					+ (now_ts.tv_nsec - net_prev_ts.tv_nsec) / 1e9;
			}
			net_last_down_bps = (net_prev_valid && rx_ok) ? net_bytes_to_rate(rx, net_prev_rx, elapsed) : -1.0;
			net_last_up_bps = (net_prev_valid && tx_ok) ? net_bytes_to_rate(tx, net_prev_tx, elapsed) : -1.0;
			format_speed(net_last_down_bps, net_down_text, sizeof(net_down_text));
			format_speed(net_last_up_bps, net_up_text, sizeof(net_up_text));

			if (rx_ok && tx_ok) {
				net_prev_rx = rx;
				net_prev_tx = tx;
				net_prev_ts = now_ts;
				net_prev_valid = 1;
			}
		}
	}
	set_net_icon_path(icon_path);

	wl_list_for_each(m, &mons, link) {
		if (!m->statusbar.net.tree || !m->showbar)
			continue;
		barh = m->statusbar.area.height ? m->statusbar.area.height : (int)statusbar_height;
		if (status_should_render(&m->statusbar.net, barh, net_text,
					last_net_render, sizeof(last_net_render), &last_net_h)
				|| m->statusbar.net_popup.visible) {
			rendernet(&m->statusbar.net, barh, net_text);
			if (m->statusbar.net_popup.visible)
				rendernetpopup(m);
			positionstatusmodules(m);
		} else if (m->statusbar.net_popup.visible) {
			rendernetpopup(m);
		}
	}
}

static void
tray_remove_item(const char *service)
{
	TrayItem *it, *tmp;
	Monitor *m;

	if (!service)
		return;

	wl_list_for_each(m, &mons, link) {
		if (strcmp(m->statusbar.tray_menu.service, service) == 0)
			tray_menu_hide(m);
	}

	wl_list_for_each_safe(it, tmp, &tray_items, link) {
		if (strcmp(it->service, service) == 0) {
			wl_list_remove(&it->link);
			if (it->icon_buf)
				wlr_buffer_drop(it->icon_buf);
			free(it);
			tray_update_icons_text();
			sd_bus_emit_signal(tray_bus, NULL, "/StatusNotifierWatcher",
					"org.kde.StatusNotifierWatcher",
					"StatusNotifierItemUnregistered", "s", service);
			sd_bus_emit_signal(tray_bus, NULL, "/StatusNotifierWatcher",
					"org.freedesktop.StatusNotifierWatcher",
					"StatusNotifierItemUnregistered", "s", service);
			return;
		}
	}
}

static __attribute__((unused)) TrayItem *
tray_first_item(void)
{
	TrayItem *sample = NULL;

	if (wl_list_empty(&tray_items))
		return NULL;
	return wl_container_of(tray_items.next, sample, link);
}

static __attribute__((unused)) void
tray_item_activate(TrayItem *it, int button, int context_menu, int x, int y)
{
	const char *method;
	const char *ifaces[] = {
		"org.kde.StatusNotifierItem",
		"org.freedesktop.StatusNotifierItem",
	};
	const char *item_path;
	int r = -1;

	if (!tray_bus || !it)
		return;
	if (context_menu)
		method = "ContextMenu";
	else if (button == BTN_MIDDLE)
		method = "SecondaryActivate";
	else
		method = "Activate";
	tray_anchor_x = x;
	tray_anchor_y = y;
	tray_anchor_time_ms = monotonic_msec();
	if (context_menu) {
		/* ensure transient menus are placed near the icon even if GetLayout fails */
		tray_anchor_x = x;
		tray_anchor_y = y;
	}
	item_path = it->path[0] ? it->path : "/StatusNotifierItem";
	for (int attempt = 0; attempt < 2; attempt++) {
		for (size_t i = 0; i < LENGTH(ifaces); i++) {
			r = sd_bus_call_method(tray_bus, it->service, item_path,
					ifaces[i], method, NULL, NULL, "ii", x, y);
			if (r >= 0)
				return;
		}
		/* If bus is broken, try to re-init once */
		if (r == -EBADFD || r == -EPIPE || r == -ENOTCONN) {
			tray_init();
			if (!tray_bus)
				break;
		} else {
			break;
		}
	}
	wlr_log(WLR_ERROR, "tray: %s %s failed on %s%s: %s",
			method, it->service, item_path, it->path[0] ? "" : "(null)", strerror(-r));
}

static void
refreshstatusbattery(void)
{
	Monitor *m;
	int barh;
	double percent, display;
	const char *icon = battery_icon_100;

	if (!battery_path_initialized) {
		battery_available = findbatterydevice(battery_capacity_path,
				sizeof(battery_capacity_path));
		battery_path_initialized = 1;
	}

	percent = battery_percent();
	display = percent;

	if (percent >= 0.0) {
		battery_last_percent = percent;
		display = percent;
	} else if (battery_last_percent >= 0.0) {
		display = battery_last_percent;
	}

	if (display < 0.0) {
		snprintf(battery_text, sizeof(battery_text), "--%%");
	} else {
		if (display > 100.0)
			display = 100.0;
		if (display < 0.0)
			display = 0.0;
		snprintf(battery_text, sizeof(battery_text), "%d%%", (int)lround(display));
	}

	if (display >= 0.0) {
		if (display <= 25.0)
			icon = battery_icon_25;
		else if (display <= 50.0)
			icon = battery_icon_50;
		else if (display <= 75.0)
			icon = battery_icon_75;
		else
			icon = battery_icon_100;
	}
	if (strncmp(battery_icon_path, icon, sizeof(battery_icon_path)) != 0) {
		snprintf(battery_icon_path, sizeof(battery_icon_path), "%s", icon);
	}

	wl_list_for_each(m, &mons, link) {
		if (!m->statusbar.battery.tree || !m->showbar)
			continue;
		barh = m->statusbar.area.height ? m->statusbar.area.height : (int)statusbar_height;
		if (status_should_render(&m->statusbar.battery, barh, battery_text,
					last_battery_render, sizeof(last_battery_render), &last_battery_h)) {
			renderbattery(&m->statusbar.battery, barh, battery_text);
			positionstatusmodules(m);
		}
	}
}

static void
refreshstatuscpu(void)
{
	double usage = cpuaverage();
	Monitor *m;
	int barh;

	if (usage >= 0.0)
		cpu_last_percent = usage;

	if (cpu_last_percent < 0.0)
		snprintf(cpu_text, sizeof(cpu_text), "--%%");
	else {
		int avg_disp = (cpu_last_percent < 1.0) ? 0 : (int)lround(cpu_last_percent);
		snprintf(cpu_text, sizeof(cpu_text), "%d%%", avg_disp);
	}

	wl_list_for_each(m, &mons, link) {
		if (!m->statusbar.cpu.tree || !m->showbar)
			continue;
		barh = m->statusbar.area.height ? m->statusbar.area.height : (int)statusbar_height;
		if (status_should_render(&m->statusbar.cpu, barh, cpu_text,
					last_cpu_render, sizeof(last_cpu_render), &last_cpu_h)
				|| m->statusbar.cpu_popup.visible) {
			rendercpu(&m->statusbar.cpu, barh, cpu_text);
			if (m->statusbar.cpu_popup.visible)
				rendercpupopup(m);
			positionstatusmodules(m);
		}
	}
}

static void
refreshstatusram(void)
{
	double used_mb = ramused_mb();
	Monitor *m;
	int barh;

	if (used_mb >= 0.0)
		ram_last_mb = used_mb;

	if (ram_last_mb < 0.0) {
		snprintf(ram_text, sizeof(ram_text), "--");
	} else if (ram_last_mb >= 1024.0) {
		double gb = ram_last_mb / 1024.0;
		snprintf(ram_text, sizeof(ram_text), "%.1fGB", gb);
	} else {
		snprintf(ram_text, sizeof(ram_text), "%dMB", (int)lround(ram_last_mb));
	}

	wl_list_for_each(m, &mons, link) {
		if (!m->statusbar.ram.tree || !m->showbar)
			continue;
		barh = m->statusbar.area.height ? m->statusbar.area.height : (int)statusbar_height;
		if (status_should_render(&m->statusbar.ram, barh, ram_text,
					last_ram_render, sizeof(last_ram_render), &last_ram_h)) {
			renderram(&m->statusbar.ram, barh, ram_text);
			positionstatusmodules(m);
		}
	}
}

static void
refreshstatusvolume(void)
{
	int is_headset = pipewire_sink_is_headset();
	double vol = speaker_active;
	Monitor *m;
	int barh;
	double display = vol;
	int force_render = 0;
	int use_muted_color = 0;
	const char *icon = volume_icon_speaker_100;

	if (vol < 0.0) {
		double read = pipewire_volume_percent(&is_headset);
		if (read >= 0.0) {
			vol = read;
			speaker_active = read;
		}
	}
	display = vol;

	if (display > volume_max_percent)
		display = volume_max_percent;
	if (display < 0.0 && volume_muted == 1)
		display = 0.0;

	if (volume_muted == 1) {
		use_muted_color = 1;
		display = display < 0.0 ? 0.0 : display;
	}

	if (display < 0.0) {
		snprintf(volume_text, sizeof(volume_text), "--%%");
	} else {
		if (display < 0.0)
			display = 0.0;
		if (display > volume_max_percent)
			display = volume_max_percent;
		if (volume_muted == 1)
			display = 0.0;
		snprintf(volume_text, sizeof(volume_text), "%d%%", (int)lround(display));
	}

	if (is_headset) {
		if (volume_muted == 1)
			icon = volume_icon_headset_muted;
		else
			icon = volume_icon_headset;
	} else if (volume_muted == 1) {
		icon = volume_icon_speaker_muted;
	} else if (display <= 25.0) {
		icon = volume_icon_speaker_25;
	} else if (display <= 75.0) {
		icon = volume_icon_speaker_50;
	} else {
		icon = volume_icon_speaker_100;
	}

	if (strncmp(volume_icon_path, icon, sizeof(volume_icon_path)) != 0) {
		snprintf(volume_icon_path, sizeof(volume_icon_path), "%s", icon);
		force_render = 1;
	}

	volume_text_color = use_muted_color ? statusbar_volume_muted_fg : statusbar_fg;
	if (use_muted_color != volume_last_color_is_muted) {
		force_render = 1;
	}
	volume_last_color_is_muted = use_muted_color;

	wl_list_for_each(m, &mons, link) {
		if (!m->statusbar.volume.tree || !m->showbar)
			continue;
		barh = m->statusbar.area.height ? m->statusbar.area.height : (int)statusbar_height;
		if (status_should_render(&m->statusbar.volume, barh, volume_text,
					last_volume_render, sizeof(last_volume_render), &last_volume_h)
				|| force_render) {
			rendervolume(&m->statusbar.volume, barh, volume_text);
			positionstatusmodules(m);
		}
	}
}

static void
refreshstatusmic(void)
{
	double vol = microphone_active;
	Monitor *m;
	int barh;
	double display = vol;
	int force_render = 0;
	int use_muted_color = 0;
	const char *icon = mic_icon_unmuted;

	if (vol < 0.0) {
		double read = pipewire_mic_volume_percent();
		if (read >= 0.0) {
			vol = read;
			microphone_active = read;
			mic_last_percent = read;
		}
	}
	if (vol >= 0.0)
		mic_last_percent = vol;
	display = vol >= 0.0 ? vol : mic_last_percent;

	if (display > mic_max_percent)
		display = mic_max_percent;
	if (display < 0.0 && mic_muted == 1)
		display = 0.0;

	if (mic_muted == 1) {
		use_muted_color = 1;
		display = display < 0.0 ? 0.0 : display;
	}

	if (display < 0.0) {
		snprintf(mic_text, sizeof(mic_text), "--%%");
	} else {
		if (display < 0.0)
			display = 0.0;
		if (display > mic_max_percent)
			display = mic_max_percent;
		if (mic_muted == 1)
			display = 0.0;
		snprintf(mic_text, sizeof(mic_text), "%d%%", (int)lround(display));
	}

	if (mic_muted == 1)
		icon = mic_icon_muted;
	else
		icon = mic_icon_unmuted;

	if (strncmp(mic_icon_path, icon, sizeof(mic_icon_path)) != 0) {
		snprintf(mic_icon_path, sizeof(mic_icon_path), "%s", icon);
		force_render = 1;
	}

	mic_text_color = use_muted_color ? statusbar_mic_muted_fg : statusbar_fg;
	if (use_muted_color != mic_last_color_is_muted) {
		force_render = 1;
		mic_last_color_is_muted = use_muted_color;
	}

	wl_list_for_each(m, &mons, link) {
		if (!m->statusbar.mic.tree || !m->showbar)
			continue;
		barh = m->statusbar.area.height ? m->statusbar.area.height : (int)statusbar_height;
		if (status_should_render(&m->statusbar.mic, barh, mic_text,
					last_mic_render, sizeof(last_mic_render), &last_mic_h)
				|| force_render) {
			rendermic(&m->statusbar.mic, barh, mic_text);
			positionstatusmodules(m);
		}
	}
}

static void
refreshstatusicons(void)
{
	Monitor *m;
	int barh;

	wl_list_for_each(m, &mons, link) {
		if (!m->showbar)
			continue;
		barh = m->statusbar.area.height ? m->statusbar.area.height : (int)statusbar_height;
		if (m->statusbar.sysicons.tree)
			rendertrayicons(m, barh);
		if (m->statusbar.bluetooth.tree)
			renderbluetooth(m, barh);
		if (m->statusbar.steam.tree)
			rendersteam(m, barh);
		if (m->statusbar.discord.tree)
			renderdiscord(m, barh);
		positionstatusmodules(m);
	}
}

static void
tray_update_icons_text(void)
{
	TrayItem *it;
	size_t off = 0;
	int running_width;
	char segment[256];

	snprintf(sysicons_text, sizeof(sysicons_text), "Tray");
	off = strlen(sysicons_text);
	if (off >= sizeof(sysicons_text))
		off = sizeof(sysicons_text) - 1;
	running_width = status_text_width(sysicons_text);

	wl_list_for_each(it, &tray_items, link) {
		const char *label = it->label[0] ? it->label : it->service;
		int n;
		it->x = running_width;
		if (off ? snprintf(segment, sizeof(segment), " %s", label)
				: snprintf(segment, sizeof(segment), "%s", label))
			it->w = status_text_width(segment);
		else
			it->w = status_text_width(label);
		if (it->w <= 0)
			it->w = statusbar_font_spacing;
		n = snprintf(sysicons_text + off, sizeof(sysicons_text) - off,
				off ? " %s" : "%s", label);
		if (n < 0)
			break;
		if ((size_t)n >= sizeof(sysicons_text) - off) {
			sysicons_text[sizeof(sysicons_text) - 1] = '\0';
			break;
		}
		off += (size_t)n;
		running_width += it->w;
	}

	refreshstatusicons();
}

static void
refreshstatustags(void)
{
	Monitor *m;
	int barh;

	wl_list_for_each(m, &mons, link) {
		if (!m->statusbar.tags.tree || !m->showbar)
			continue;
		barh = m->statusbar.area.height ? m->statusbar.area.height : (int)statusbar_height;
		renderworkspaces(m, &m->statusbar.tags, barh);
		if (m->statusbar.traylabel.tree) {
			clearstatusmodule(&m->statusbar.traylabel);
			m->statusbar.traylabel.width = 0;
			wlr_scene_node_set_enabled(&m->statusbar.traylabel.tree->node, 0);
		}
		m->statusbar.tags.hover_tag = -1;
		for (int i = 0; i < TAGCOUNT; i++)
			m->statusbar.tags.hover_alpha[i] = 0.0f;
		positionstatusmodules(m);
	}
}

static void
seed_status_rng(void)
{
	struct timespec ts;

	if (status_rng_seeded)
		return;
	if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0)
		srand((unsigned)(ts.tv_sec ^ ts.tv_nsec));
	else
		srand((unsigned)time(NULL));
	status_rng_seeded = 1;
}

static int
status_should_render(StatusModule *module, int barh, const char *text,
		char *last_text, size_t last_len, int *last_h)
{
	if (!module || !text || !last_text || last_len == 0)
		return 1;

	if ((last_h && *last_h != barh) || last_text[0] == '\0'
			|| strncmp(last_text, text, last_len) != 0) {
		snprintf(last_text, last_len, "%s", text);
		if (last_h)
			*last_h = barh;
		return 1;
	}
	return 0;
}

static void
initial_status_refresh(void)
{
	apply_startup_defaults();
	refreshstatusclock();
	refreshstatuscpu();
	refreshstatusram();
	refreshstatuslight();
	refreshstatusmic();
	refreshstatusvolume();
	refreshstatusbattery();
	refreshstatusnet();
	request_public_ip_async(); /* prefetch public IP in background */
	refreshstatusicons();
	refreshstatustags();
}

static uint32_t
random_status_delay_ms(void)
{
	seed_status_rng();
	return 5000u + (uint32_t)(rand() % 5001);
}

static void
init_status_refresh_tasks(void)
{
	uint64_t now = monotonic_msec();
	uint32_t offset = 100;

	for (size_t i = 0; i < LENGTH(status_tasks); i++) {
		status_tasks[i].next_due_ms = now + offset;
		offset += 200; /* stagger initial fills to avoid clumping */
	}
}

static void
trigger_status_task_now(void (*fn)(void))
{
	uint64_t now = monotonic_msec();

	for (size_t i = 0; i < LENGTH(status_tasks); i++) {
		if (status_tasks[i].fn == fn) {
			status_tasks[i].next_due_ms = now;
			schedule_next_status_refresh();
			return;
		}
	}
}

static void
set_status_task_due(void (*fn)(void), uint64_t due_ms)
{
	for (size_t i = 0; i < LENGTH(status_tasks); i++) {
		if (status_tasks[i].fn == fn) {
			status_tasks[i].next_due_ms = due_ms;
			schedule_next_status_refresh();
			return;
		}
	}
}

static int
status_task_hover_active(void (*fn)(void))
{
	Monitor *m;

	if (fn == refreshstatuscpu) {
		return 0;
	}
	if (fn == refreshstatusnet) {
		wl_list_for_each(m, &mons, link) {
			if (m->showbar && m->statusbar.net_popup.visible)
				return 1;
		}
	}
	return 0;
}

static Monitor *
modal_visible_monitor(void)
{
	Monitor *m;

	wl_list_for_each(m, &mons, link) {
		if (m->modal.visible)
			return m;
	}
	return NULL;
}

static void
modal_layout_metrics(int *btn_h, int *field_h, int *line_h, int *pad)
{
	int bh = statusfont.height > 0 ? statusfont.height + 16 : 48;
	int fh;
	int lh;
	int pd = 12;

	if (bh < 40)
		bh = 40;
	fh = bh > 40 ? bh - 8 : 36;
	lh = statusfont.height > 0 ? statusfont.height + 6 : 22;

	if (btn_h)
		*btn_h = bh;
	if (field_h)
		*field_h = fh;
	if (line_h)
		*line_h = lh;
	if (pad)
		*pad = pd;
}

static int
modal_max_visible_lines(Monitor *m)
{
	ModalOverlay *mo;
	int btn_h, field_h, line_h, pad;
	int line_y, avail;

	if (!m)
		return 0;
	mo = &m->modal;
	modal_layout_metrics(&btn_h, &field_h, &line_h, &pad);

	line_y = btn_h + pad + field_h + pad;
	avail = mo->height - line_y - pad;
	if (avail <= 0 || line_h <= 0)
		return 0;
	return avail / line_h;
}

static void
modal_ensure_selection_visible(Monitor *m)
{
	ModalOverlay *mo;
	int active;
	int max_lines;
	int max_scroll;
	int sel;

	if (!m)
		return;
	mo = &m->modal;
	active = mo->active_idx;
	if (active < 0 || active > 2)
		return;

	max_lines = modal_max_visible_lines(m);
	if (max_lines <= 0) {
		mo->scroll[active] = 0;
		return;
	}
	if (mo->result_count[active] <= max_lines) {
		mo->scroll[active] = 0;
		return;
	}

	max_scroll = mo->result_count[active] - max_lines;
	sel = mo->selected[active];

	if (sel < 0) {
		if (mo->scroll[active] > max_scroll)
			mo->scroll[active] = max_scroll;
		if (mo->scroll[active] < 0)
			mo->scroll[active] = 0;
		return;
	}

	if (sel < mo->scroll[active])
		mo->scroll[active] = sel;
	else if (sel >= mo->scroll[active] + max_lines)
		mo->scroll[active] = sel - max_lines + 1;

	if (mo->scroll[active] > max_scroll)
		mo->scroll[active] = max_scroll;
	if (mo->scroll[active] < 0)
		mo->scroll[active] = 0;
}

static void
modal_file_search_clear_results(Monitor *m)
{
	ModalOverlay *mo;

	if (!m)
		return;
	mo = &m->modal;
		mo->result_count[1] = 0;
		for (int i = 0; i < (int)LENGTH(mo->results[1]); i++) {
			mo->results[1][i][0] = '\0';
			mo->result_entry_idx[1][i] = -1;
			mo->file_results_name[i][0] = '\0';
			mo->file_results_path[i][0] = '\0';
			mo->file_results_mtime[i] = 0;
	}
	mo->selected[1] = -1;
	mo->scroll[1] = 0;
	mo->file_search_fallback = 0;
}

static int
ci_contains(const char *hay, const char *needle)
{
	size_t hlen, nlen;

	if (!needle || !*needle)
		return 1;
	if (!hay || !*hay)
		return 0;
	hlen = strlen(hay);
	nlen = strlen(needle);
	if (nlen > hlen)
		return 0;
	for (size_t i = 0; i + nlen <= hlen; i++) {
		size_t j = 0;
		for (; j < nlen; j++) {
			char a = (char)tolower((unsigned char)hay[i + j]);
			char b = (char)tolower((unsigned char)needle[j]);
			if (a != b)
				break;
		}
		if (j == nlen)
			return 1;
	}
	return 0;
}

static int
modal_handle_key(Monitor *m, uint32_t mods, xkb_keysym_t sym)
{
	ModalOverlay *mo;

	if (!m)
		return 0;
	mo = &m->modal;

	if (sym == XKB_KEY_Escape) {
		modal_hide_all();
		return 1;
	}

	/* Mod+E: Open all file search results in Thunar via symlinks */
	if ((sym == XKB_KEY_e || sym == XKB_KEY_E) && (mods & WLR_MODIFIER_LOGO) &&
			mo->active_idx == 1 && mo->result_count[1] > 0) {
		const char *base = "/tmp/nixlytile-search-results";
		DIR *d;
		struct dirent *ent;
		char entpath[PATH_MAX];
		int i;

		/* Remove old temp dir contents (symlinks only) */
		d = opendir(base);
		if (d) {
			while ((ent = readdir(d)) != NULL) {
				if (ent->d_name[0] == '.')
					continue;
				snprintf(entpath, sizeof(entpath), "%s/%s", base, ent->d_name);
				unlink(entpath);
			}
			closedir(d);
			rmdir(base);
		}
		mkdir(base, 0755);
		{
			/* Create symlinks for all results */
			for (i = 0; i < mo->result_count[1]; i++) {
				const char *path = mo->file_results_path[i];
				const char *name = mo->file_results_name[i];
				char linkpath[PATH_MAX];
				char safename[256];
				int j, k;

				if (!path || !*path || !name || !*name)
					continue;

				/* Sanitize filename: replace / with _ */
				for (j = 0, k = 0; name[j] && k < (int)sizeof(safename) - 1; j++) {
					if (name[j] == '/')
						safename[k++] = '_';
					else
						safename[k++] = name[j];
				}
				safename[k] = '\0';

				/* Add index prefix to preserve order and handle duplicates */
				snprintf(linkpath, sizeof(linkpath), "%s/%03d_%s", base, i + 1, safename);
				symlink(path, linkpath);
			}

			/* Open in Thunar */
			char *cmd[] = { "thunar", (char *)base, NULL };
			Arg arg = { .v = cmd };
			spawn(&arg);
			modal_hide_all();
		}
		return 1;
	}

	if (sym == XKB_KEY_BackSpace && mo->search_len[mo->active_idx] > 0 && mods == 0) {
		mo->search_len[mo->active_idx]--;
		mo->search[mo->active_idx][mo->search_len[mo->active_idx]] = '\0';
		return 1;
	}
	if (sym == XKB_KEY_Down && mo->result_count[mo->active_idx] > 0) {
		int sel = mo->selected[mo->active_idx];
		if (sel < 0)
			sel = 0;
		else if (sel + 1 < mo->result_count[mo->active_idx])
			sel++;
		else
			sel = 0; /* wrap to top */
		mo->selected[mo->active_idx] = sel;
		modal_ensure_selection_visible(m);
		return 1;
	}
	if (sym == XKB_KEY_Up && mo->result_count[mo->active_idx] > 0) {
		int sel = mo->selected[mo->active_idx];
		if (sel < 0)
			sel = mo->result_count[mo->active_idx] - 1;
		else if (sel > 0)
			sel--;
		else
			sel = mo->result_count[mo->active_idx] - 1; /* wrap to bottom */
		mo->selected[mo->active_idx] = sel;
		modal_ensure_selection_visible(m);
		return 1;
	}
	if (sym == XKB_KEY_Return || sym == XKB_KEY_KP_Enter) {
		int sel = mo->selected[mo->active_idx];
		if (mo->active_idx == 0 && sel >= 0 && sel < mo->result_count[0]) {
			int idx = mo->result_entry_idx[0][sel];
			if (idx >= 0 && idx < desktop_entry_count) {
				char cmd_str[512];
				desktop_entries[idx].used++;
				snprintf(cmd_str, sizeof(cmd_str), "%s", desktop_entries[idx].exec[0]
						? desktop_entries[idx].exec : desktop_entries[idx].name);
				/* Launch with dGPU if desktop entry prefers it or command matches dgpu_programs */
				pid_t pid = fork();
				if (pid == 0) {
					setsid();
					if (desktop_entries[idx].prefers_dgpu || should_use_dgpu(cmd_str))
						set_dgpu_env();
					if (is_steam_cmd(cmd_str)) {
						set_steam_env();
						/* Launch Steam - Big Picture in HTPC mode, normal otherwise */
						if (htpc_mode_active) {
							execlp("steam", "steam", "-bigpicture", "-cef-force-gpu", "-cef-disable-sandbox", "steam://open/games", (char *)NULL);
						} else {
							execlp("steam", "steam", "-cef-force-gpu", "-cef-disable-sandbox", (char *)NULL);
						}
					}
					execl("/bin/sh", "sh", "-c", cmd_str, NULL);
					_exit(127);
				}
				modal_hide_all();
			}
		} else if (mo->active_idx == 1 && sel >= 0 && sel < mo->result_count[1]) {
			const char *path = mo->file_results_path[sel];
			if (path && *path) {
				char *cmd[] = { "xdg-open", (char *)path, NULL };
				Arg arg = { .v = cmd };
				spawn(&arg);
				modal_hide_all();
			}
		} else if (mo->active_idx == 2 && sel >= 0 && sel < mo->result_count[2]) {
			const char *path = mo->git_results_path[sel];
			if (path && *path) {
				char cmd_str[PATH_MAX + 64];
				char *cmd[4] = { "sh", "-c", cmd_str, NULL };
				Arg arg;
				/* Open terminal in the git project directory */
				snprintf(cmd_str, sizeof(cmd_str), "cd '%s' && alacritty", path);
				arg.v = cmd;
				spawn(&arg);
				modal_hide_all();
			}
		}
		return 1;
	}
	/* Allow Ctrl+Alt (AltGr) combinations - on many systems AltGr is Ctrl+Alt
	 * Only block Ctrl without Alt (real Ctrl shortcuts) and Logo key */
	{
		int is_altgr = (mods & WLR_MODIFIER_CTRL) && (mods & WLR_MODIFIER_ALT);
		int is_ctrl_only = (mods & WLR_MODIFIER_CTRL) && !is_altgr;
		if (sym >= 0x20 && sym <= 0x7e && !is_ctrl_only && !(mods & WLR_MODIFIER_LOGO)) {
			int len = mo->search_len[mo->active_idx];
			if (len + 1 < (int)sizeof(mo->search[0])) {
				mo->search[mo->active_idx][len] = (char)sym;
				mo->search[mo->active_idx][len + 1] = '\0';
				mo->search_len[mo->active_idx] = len + 1;
			}
			return 1;
		}
	}

	return 0;
}

static void
modal_file_search_stop(Monitor *m)
{
	ModalOverlay *mo;

	if (!m)
		return;
	mo = &m->modal;

	if (mo->file_search_timer)
		wl_event_source_timer_update(mo->file_search_timer, 0);
	if (mo->file_search_event) {
		wl_event_source_remove(mo->file_search_event);
		mo->file_search_event = NULL;
	}
	if (mo->file_search_fd >= 0) {
		close(mo->file_search_fd);
		mo->file_search_fd = -1;
	}
	if (mo->file_search_pid > 0) {
		wlr_log(WLR_INFO, "modal file search stop: killing pid=%d", mo->file_search_pid);
		kill(mo->file_search_pid, SIGTERM);
		waitpid(mo->file_search_pid, NULL, WNOHANG);
		mo->file_search_pid = -1;
	}
	mo->file_search_len = 0;
	mo->file_search_buf[0] = '\0';
	if (mo->file_search_timer) {
		wl_event_source_remove(mo->file_search_timer);
		mo->file_search_timer = NULL;
	}
}

static void
shorten_path_display(const char *full, char *out, size_t len)
{
	const char *home = getenv("HOME");
	const char *p = full;
	size_t flen;
	size_t keep;
	const char *tail;

	if (!out || len == 0)
		return;
	out[0] = '\0';
	if (!p)
		return;

	if (home && *home && strncmp(full, home, strlen(home)) == 0 && strlen(home) < strlen(full)) {
		static char tmp[PATH_MAX];
		size_t hlen = strlen(home);
		size_t rem = strlen(full) - hlen;
		if (hlen + 1 + rem < sizeof(tmp)) {
			tmp[0] = '~';
			memcpy(tmp + 1, full + hlen, rem + 1);
			p = tmp;
		}
	}

	flen = strlen(p);
	if (flen < len) {
		snprintf(out, len, "%s", p);
		return;
	}
	if (len < 5) {
		snprintf(out, len, "%s", p + (flen - (len - 1)));
		return;
	}

	keep = (len - 4) / 2;
	tail = p + flen - (len - keep - 4);
	if (tail < p)
		tail = p;
	snprintf(out, len, "%.*s...%s", (int)keep, p, tail);
}

static void
modal_file_search_add_line(Monitor *m, const char *line)
{
	ModalOverlay *mo;
	int idx;
	const char *tab1;
	const char *tab2;
	size_t name_len, path_len;
	char name[128];
	char path[PATH_MAX];
	char dir[PATH_MAX];
	char when[32] = {0};
	char path_disp[128] = {0};
	double epoch = 0.0;
	time_t t;
	struct tm tm;
	char needle[256];

	if (!m || !line || !*line)
		return;
	mo = &m->modal;
	if (mo->result_count[1] >= (int)LENGTH(mo->results[1]))
		return;

	tab1 = strchr(line, '\t');
	if (!tab1)
		return;
	tab2 = strchr(tab1 + 1, '\t');
	if (!tab2)
		return;

	name_len = (size_t)(tab1 - line);
	path_len = (size_t)(tab2 - (tab1 + 1));
	if (name_len == 0 || path_len == 0)
		return;
	if (name_len >= sizeof(name))
		name_len = sizeof(name) - 1;
	if (path_len >= sizeof(path))
		path_len = sizeof(path) - 1;

	snprintf(name, sizeof(name), "%.*s", (int)name_len, line);
	snprintf(path, sizeof(path), "%.*s", (int)path_len, tab1 + 1);
	snprintf(dir, sizeof(dir), "%s", path);
	{
		char *slash = strrchr(dir, '/');
		if (slash && slash != dir) {
			*slash = '\0';
		} else if (slash) {
			*(slash + 1) = '\0';
		} else {
			snprintf(dir, sizeof(dir), ".");
		}
	}

	epoch = strtod(tab2 + 1, NULL);
	t = (time_t)epoch;
	if (localtime_r(&t, &tm))
		strftime(when, sizeof(when), "%Y-%m-%d %H:%M", &tm);
	shorten_path_display(dir, path_disp, sizeof(path_disp));

	/* Always filter locally to allow any substring/character combination to match */
	const char *q = mo->file_search_last;
	int qlen = q ? (int)strlen(q) : 0;
	int qstart = 0, qend = qlen;
	if (qlen >= (int)sizeof(needle))
		qlen = (int)sizeof(needle) - 1;
	while (qstart < qlen && isspace((unsigned char)q[qstart]))
		qstart++;
	while (qend > qstart && isspace((unsigned char)q[qend - 1]))
		qend--;
	qlen = qend - qstart;
	if (qlen <= 0)
		return;
	for (int i = 0; i < qlen; i++)
		needle[i] = (char)q[qstart + i];
	needle[qlen] = '\0';
	if (!ci_contains(name, needle) && !ci_contains(path, needle))
		return;

	wlr_log(WLR_INFO, "modal file search result: name='%s' dir='%s'", name, path_disp[0] ? path_disp : dir);

	idx = mo->result_count[1];
	snprintf(mo->results[1][idx], sizeof(mo->results[1][idx]),
			"%s  %s", name, path_disp[0] ? path_disp : dir);
	snprintf(mo->file_results_name[idx], sizeof(mo->file_results_name[idx]), "%s", name);
	snprintf(mo->file_results_path[idx], sizeof(mo->file_results_path[idx]), "%s", path);
	mo->file_results_mtime[idx] = t;
	mo->result_entry_idx[1][idx] = -1;
	mo->result_count[1]++;
	if (mo->selected[1] < 0)
		mo->selected[1] = idx;
	if (mo->result_count[1] >= (int)LENGTH(mo->results[1]))
		modal_file_search_stop(m);
}

static void
modal_file_search_flush_buffer(Monitor *m)
{
	ModalOverlay *mo;
	size_t start = 0;

	if (!m)
		return;
	mo = &m->modal;
	for (size_t i = 0; i < mo->file_search_len; i++) {
		if (mo->file_search_buf[i] == '\n') {
			mo->file_search_buf[i] = '\0';
			modal_file_search_add_line(m, mo->file_search_buf + start);
			if (mo->result_count[1] >= (int)LENGTH(mo->results[1])) {
				modal_file_search_stop(m);
				start = mo->file_search_len;
				break;
			}
			start = i + 1;
		}
	}

	if (start > 0) {
		size_t remaining = mo->file_search_len - start;
		memmove(mo->file_search_buf, mo->file_search_buf + start, remaining);
		mo->file_search_len = remaining;
		mo->file_search_buf[mo->file_search_len] = '\0';
	} else if (mo->file_search_len >= sizeof(mo->file_search_buf) - 1) {
		/* avoid getting stuck with an overfull buffer if no newline arrives */
		mo->file_search_len = 0;
		mo->file_search_buf[0] = '\0';
	}
}

static void
modal_file_search_start_mode(Monitor *m, int fallback)
{
	ModalOverlay *mo;
	int pipefd[2] = {-1, -1};
	pid_t pid;

	(void)fallback;

	if (!m)
		return;
	mo = &m->modal;

	modal_file_search_stop(m);
	modal_file_search_clear_results(m);

	if (mo->search_len[1] < modal_file_search_minlen) {
		mo->file_search_last[0] = '\0';
		return;
	}
	mo->file_search_fallback = 1; /* always filter locally */

	if (pipe(pipefd) != 0) {
		wlr_log(WLR_ERROR, "modal file search: pipe failed: %s", strerror(errno));
		mo->file_search_last[0] = '\0';
		return;
	}
	fcntl(pipefd[0], F_SETFD, fcntl(pipefd[0], F_GETFD) | FD_CLOEXEC);
	fcntl(pipefd[0], F_SETFL, fcntl(pipefd[0], F_GETFL) | O_NONBLOCK);

	pid = fork();
	if (pid == 0) {
		close(pipefd[0]);
		dup2(pipefd[1], STDOUT_FILENO);
		dup2(pipefd[1], STDERR_FILENO);
		close(pipefd[1]);
		setsid();

		/* Read file search from cache (cache updated at nixlytile startup) */
		execlp("sh", "sh", "-c",
			"cat \"${XDG_CACHE_HOME:-$HOME/.cache}/nixlytile-file-search\" 2>/dev/null",
			(char *)NULL);
		_exit(127);
	} else if (pid < 0) {
		close(pipefd[0]);
		close(pipefd[1]);
		wlr_log(WLR_ERROR, "modal file search: fork failed: %s", strerror(errno));
		mo->file_search_last[0] = '\0';
		return;
	}

	close(pipefd[1]);
	mo->file_search_pid = pid;
	mo->file_search_fd = pipefd[0];
	fcntl(mo->file_search_fd, F_SETFL, fcntl(mo->file_search_fd, F_GETFL) | O_NONBLOCK);
	mo->file_search_len = 0;
	mo->file_search_buf[0] = '\0';
	mo->file_search_event = wl_event_loop_add_fd(event_loop, mo->file_search_fd,
			WL_EVENT_READABLE | WL_EVENT_HANGUP, modal_file_search_event, m);
	if (!mo->file_search_event) {
		wlr_log(WLR_ERROR, "modal file search: failed to watch results fd");
		modal_file_search_stop(m);
		mo->file_search_last[0] = '\0';
		return;
	}

	snprintf(mo->file_search_last, sizeof(mo->file_search_last), "%s", mo->search[1]);
	wlr_log(WLR_INFO, "modal file search start: '%s' (len=%d, fd=%d pid=%d event=%p)",
			mo->file_search_last, mo->search_len[1], mo->file_search_fd, mo->file_search_pid, (void *)mo->file_search_event);
}

static void
modal_file_search_start(Monitor *m)
{
	modal_file_search_start_mode(m, 1);
}

/* Debounce timer callback - starts search after typing pause */
static int
modal_file_search_debounce_cb(void *data)
{
	Monitor *m = data;
	ModalOverlay *mo;

	if (!m)
		return 0;
	mo = &m->modal;

	/* Only start if search string still differs from last search */
	if (mo->search_len[1] >= modal_file_search_minlen &&
	    strncmp(mo->search[1], mo->file_search_last, sizeof(mo->file_search_last)) != 0) {
		modal_file_search_start(m);
	}

	return 0;
}

/* Schedule a debounced file search (150ms delay) */
static void
modal_file_search_schedule(Monitor *m)
{
	ModalOverlay *mo;

	if (!m)
		return;
	mo = &m->modal;

	/* Create timer if it doesn't exist */
	if (!mo->file_search_timer) {
		mo->file_search_timer = wl_event_loop_add_timer(event_loop,
				modal_file_search_debounce_cb, m);
	}

	/* Reset timer to 150ms */
	if (mo->file_search_timer)
		wl_event_source_timer_update(mo->file_search_timer, 150);
}

static int
modal_file_search_event(int fd, uint32_t mask, void *data)
{
	Monitor *m = data;
	ModalOverlay *mo;
	char buf[512];
	ssize_t n;

	if (!m)
		return 0;
	(void)mask;
	mo = &m->modal;
	if (fd != mo->file_search_fd)
		return 0;

	wlr_log(WLR_INFO, "modal file search event: mask=0x%x pid=%d fd=%d", mask, mo->file_search_pid, fd);

	for (;;) {
		n = read(fd, buf, sizeof(buf));
		if (n > 0) {
			wlr_log(WLR_INFO, "modal file search read %zd bytes (buf_len=%zu)", n, mo->file_search_len);
			if (mo->file_search_len >= sizeof(mo->file_search_buf) - 1)
				modal_file_search_flush_buffer(m);
			if (mo->file_search_len < sizeof(mo->file_search_buf) - 1) {
				size_t avail = sizeof(mo->file_search_buf) - 1 - mo->file_search_len;
				if ((size_t)n > avail)
					n = (ssize_t)avail;
				memcpy(mo->file_search_buf + mo->file_search_len, buf, (size_t)n);
				mo->file_search_len += (size_t)n;
				mo->file_search_buf[mo->file_search_len] = '\0';
			}
			modal_file_search_flush_buffer(m);
			if (mo->file_search_fd < 0 || mo->file_search_pid <= 0)
				break;
		} else if (n == 0) {
			modal_file_search_flush_buffer(m);
			if (mo->file_search_len > 0 && mo->file_search_len < sizeof(mo->file_search_buf)) {
				mo->file_search_buf[mo->file_search_len] = '\0';
				modal_file_search_add_line(m, mo->file_search_buf);
				mo->file_search_len = 0;
				mo->file_search_buf[0] = '\0';
			}
			wlr_log(WLR_INFO, "modal file search done: '%s' (%d results)", mo->file_search_last, mo->result_count[1]);
			modal_file_search_stop(m);
			break;
		} else {
			if (errno == EAGAIN || errno == EWOULDBLOCK)
				break;
			modal_file_search_stop(m);
			wlr_log(WLR_ERROR, "modal file search read error: %s", strerror(errno));
			break;
		}
	}

	if (mo->result_count[1] > 0 && mo->selected[1] < 0)
		mo->selected[1] = 0;
	if (mo->active_idx == 1 && mo->result_count[1] > 0)
		modal_ensure_selection_visible(m);
	/* Only render if user is not actively typing */
	if (m->modal.visible && !mo->render_pending)
		modal_render(m);
	return 0;
}

/* Git project search functions */
static void
modal_git_search_clear_results(Monitor *m)
{
	ModalOverlay *mo;

	if (!m)
		return;
	mo = &m->modal;
	mo->git_result_count = 0;
	mo->result_count[2] = 0;
	for (int i = 0; i < MODAL_MAX_RESULTS; i++) {
		mo->git_results_name[i][0] = '\0';
		mo->git_results_path[i][0] = '\0';
		mo->git_results_mtime[i] = 0;
		mo->results[2][i][0] = '\0';
	}
	mo->selected[2] = -1;
	mo->scroll[2] = 0;
}

static void
modal_git_search_stop(Monitor *m)
{
	ModalOverlay *mo;

	if (!m)
		return;
	mo = &m->modal;

	if (mo->git_search_event) {
		wl_event_source_remove(mo->git_search_event);
		mo->git_search_event = NULL;
	}
	if (mo->git_search_fd >= 0) {
		close(mo->git_search_fd);
		mo->git_search_fd = -1;
	}
	if (mo->git_search_pid > 0) {
		wlr_log(WLR_INFO, "modal git search stop: killing pid=%d", mo->git_search_pid);
		kill(mo->git_search_pid, SIGTERM);
		waitpid(mo->git_search_pid, NULL, WNOHANG);
		mo->git_search_pid = -1;
	}
	mo->git_search_len = 0;
	mo->git_search_buf[0] = '\0';
}

static void
modal_git_search_add_line(Monitor *m, const char *line)
{
	ModalOverlay *mo;
	int idx;
	const char *tab;
	double epoch;
	time_t t;
	char *name;
	char path[PATH_MAX];
	char short_path[128];

	if (!m || !line || !*line)
		return;
	mo = &m->modal;
	if (mo->git_result_count >= MODAL_MAX_RESULTS)
		return;

	/* Format: "mtime_epoch\tpath" */
	tab = strchr(line, '\t');
	if (!tab)
		return;

	epoch = strtod(line, NULL);
	t = (time_t)epoch;
	snprintf(path, sizeof(path), "%s", tab + 1);

	/* Extract project name from path */
	name = strrchr(path, '/');
	if (name)
		name++;
	else
		name = path;

	/* Filter by search query if any */
	if (mo->search_len[2] > 0) {
		char needle[256];
		int nlen = mo->search_len[2];
		if (nlen >= (int)sizeof(needle))
			nlen = (int)sizeof(needle) - 1;
		for (int i = 0; i < nlen; i++)
			needle[i] = (char)tolower((unsigned char)mo->search[2][i]);
		needle[nlen] = '\0';
		if (!ci_contains(name, needle) && !ci_contains(path, needle))
			return;
	}

	idx = mo->git_result_count;
	snprintf(mo->git_results_name[idx], sizeof(mo->git_results_name[idx]), "%s", name);
	snprintf(mo->git_results_path[idx], sizeof(mo->git_results_path[idx]), "%s", path);
	mo->git_results_mtime[idx] = t;

	shorten_path_display(path, short_path, sizeof(short_path));
	snprintf(mo->results[2][idx], sizeof(mo->results[2][idx]), "%s", short_path);
	mo->result_count[2]++;
	mo->git_result_count++;

	if (mo->selected[2] < 0)
		mo->selected[2] = 0;
}

static void
modal_git_search_flush_buffer(Monitor *m)
{
	ModalOverlay *mo;
	size_t start = 0;

	if (!m)
		return;
	mo = &m->modal;
	for (size_t i = 0; i < mo->git_search_len; i++) {
		if (mo->git_search_buf[i] == '\n') {
			mo->git_search_buf[i] = '\0';
			modal_git_search_add_line(m, mo->git_search_buf + start);
			if (mo->git_result_count >= MODAL_MAX_RESULTS) {
				modal_git_search_stop(m);
				start = mo->git_search_len;
				break;
			}
			start = i + 1;
		}
	}
	if (start > 0 && start < mo->git_search_len) {
		memmove(mo->git_search_buf, mo->git_search_buf + start, mo->git_search_len - start);
		mo->git_search_len -= start;
	} else if (start == mo->git_search_len) {
		mo->git_search_len = 0;
	}
	mo->git_search_buf[mo->git_search_len] = '\0';
}

static int
modal_git_search_event(int fd, uint32_t mask, void *data)
{
	Monitor *m = data;
	ModalOverlay *mo;
	char buf[512];
	ssize_t n;

	if (!m)
		return 0;
	(void)mask;
	mo = &m->modal;
	if (fd != mo->git_search_fd)
		return 0;

	while ((n = read(fd, buf, sizeof(buf) - 1)) > 0) {
		buf[n] = '\0';
		size_t space = sizeof(mo->git_search_buf) - mo->git_search_len - 1;
		if ((size_t)n > space)
			n = (ssize_t)space;
		if (n > 0) {
			memcpy(mo->git_search_buf + mo->git_search_len, buf, (size_t)n);
			mo->git_search_len += (size_t)n;
			mo->git_search_buf[mo->git_search_len] = '\0';
		}
		modal_git_search_flush_buffer(m);
		if (mo->git_result_count >= MODAL_MAX_RESULTS)
			break;
	}

	if (n == 0 || (n < 0 && errno != EAGAIN && errno != EWOULDBLOCK)) {
		mo->git_search_done = 1;
		modal_git_search_stop(m);
		if (n < 0 && errno != EAGAIN && errno != EWOULDBLOCK)
			wlr_log(WLR_ERROR, "modal git search read error: %s", strerror(errno));
	}

	if (mo->result_count[2] > 0 && mo->selected[2] < 0)
		mo->selected[2] = 0;
	if (mo->active_idx == 2 && mo->result_count[2] > 0)
		modal_ensure_selection_visible(m);
	/* Render after receiving git search results */
	if (mo->active_idx == 2)
		modal_render(m);
	return 0;
}

static void
modal_git_search_start(Monitor *m)
{
	ModalOverlay *mo;
	pid_t pid;
	int pipefd[2];
	const char *home;

	if (!m)
		return;
	mo = &m->modal;

	modal_git_search_stop(m);
	modal_git_search_clear_results(m);
	mo->git_search_done = 0;

	home = getenv("HOME");
	if (!home || !*home)
		home = "/";

	if (pipe(pipefd) != 0) {
		wlr_log(WLR_ERROR, "modal git search: pipe failed: %s", strerror(errno));
		return;
	}
	fcntl(pipefd[0], F_SETFD, fcntl(pipefd[0], F_GETFD) | FD_CLOEXEC);
	fcntl(pipefd[0], F_SETFL, fcntl(pipefd[0], F_GETFL) | O_NONBLOCK);

	pid = fork();
	if (pid == 0) {
		close(pipefd[0]);
		dup2(pipefd[1], STDOUT_FILENO);
		dup2(pipefd[1], STDERR_FILENO);
		close(pipefd[1]);
		setsid();

		/* Read git projects from cache only (cache updated at nixlytile startup) */
		execlp("sh", "sh", "-c",
			"cat \"${XDG_CACHE_HOME:-$HOME/.cache}/nixlytile-git-projects\" 2>/dev/null",
			(char *)NULL);
		_exit(127);
	} else if (pid < 0) {
		close(pipefd[0]);
		close(pipefd[1]);
		wlr_log(WLR_ERROR, "modal git search: fork failed: %s", strerror(errno));
		return;
	}

	close(pipefd[1]);
	mo->git_search_pid = pid;
	mo->git_search_fd = pipefd[0];
	fcntl(mo->git_search_fd, F_SETFL, fcntl(mo->git_search_fd, F_GETFL) | O_NONBLOCK);
	mo->git_search_len = 0;
	mo->git_search_buf[0] = '\0';
	mo->git_search_event = wl_event_loop_add_fd(event_loop, mo->git_search_fd,
			WL_EVENT_READABLE | WL_EVENT_HANGUP, modal_git_search_event, m);
	if (!mo->git_search_event) {
		wlr_log(WLR_ERROR, "modal git search: failed to watch results fd");
		modal_git_search_stop(m);
		return;
	}

	/* Save current search query */
	{
		int qlen = mo->search_len[2];
		if (qlen > (int)sizeof(mo->git_search_last) - 1)
			qlen = (int)sizeof(mo->git_search_last) - 1;
		if (qlen > 0)
			memcpy(mo->git_search_last, mo->search[2], (size_t)qlen);
		mo->git_search_last[qlen] = '\0';
	}
	wlr_log(WLR_INFO, "modal git search start: fd=%d pid=%d query='%s'", mo->git_search_fd, mo->git_search_pid, mo->git_search_last);
}

static void
git_cache_update_start(void)
{
	pid_t pid;

	if (game_mode_active || htpc_mode_active)
		return;

	pid = fork();
	if (pid == 0) {
		setsid();
		/* Update git projects cache in background with low priority */
		execlp("nice", "nice", "-n", "19", "ionice", "-c", "3", "sh", "-c",
			"cache=\"${XDG_CACHE_HOME:-$HOME/.cache}/nixlytile-git-projects\"; "
			"fd -H -t d '^\\.git$' -E '.local' -E '.config' -E '.cache' -E '.npm' -E '.cargo' -E 'node_modules' -E '.Trash*' \"$HOME\" /mnt /media /run/media 2>/dev/null | "
			"sed 's|/\\.git/$||' | while IFS= read -r d; do "
			"  mtime=$(stat -c %Y \"$d\" 2>/dev/null || echo 0); "
			"  printf '%s\\t%s\\n' \"$mtime\" \"$d\"; "
			"done | sort -rn | head -500 > \"$cache.tmp\" && mv \"$cache.tmp\" \"$cache\"",
			(char *)NULL);
		_exit(127);
	} else if (pid > 0) {
		wlr_log(WLR_INFO, "git cache update started: pid=%d", pid);
	}
}

static void
file_cache_update_start(void)
{
	pid_t pid;

	if (game_mode_active || htpc_mode_active)
		return;

	pid = fork();
	if (pid == 0) {
		setsid();
		/* Update file search cache in background with low priority
		 * No -H flag = ignores hidden files/directories by default */
		execlp("nice", "nice", "-n", "19", "ionice", "-c", "3", "sh", "-c",
			"cache=\"${XDG_CACHE_HOME:-$HOME/.cache}/nixlytile-file-search\"; "
			"fd -t f . -E 'node_modules' -E '__pycache__' \"$HOME\" /mnt /media /run/media 2>/dev/null | "
			"awk -F/ '{print $NF\"\\t\"$0\"\\t0\"}' > \"$cache.tmp\" && mv \"$cache.tmp\" \"$cache\"",
			(char *)NULL);
		_exit(127);
	} else if (pid > 0) {
		wlr_log(WLR_INFO, "file cache update started: pid=%d", pid);
	}
}

static void
pc_gaming_cache_update_start(void)
{
	pid_t pid;
	char *home;

	home = getenv("HOME");
	if (!home)
		return;

	pid = fork();
	if (pid == 0) {
		setsid();
		/* Update PC gaming cache in background with low priority - scans Steam and fetches game info */
		execlp("nice", "nice", "-n", "19", "ionice", "-c", "3", "sh", "-c",
			"home=\"$HOME\"\n"
			"cache=\"${XDG_CACHE_HOME:-$home/.cache}/nixlytile/games.cache\"\n"
			"mkdir -p \"$(dirname \"$cache\")\"\n"
			"steam_root=\"$home/.local/share/Steam\"\n"
			"tmp=$(mktemp)\n"
			"trap 'rm -f \"$tmp\" \"$tmp.api\" \"$tmp.playtime\" \"$tmp.lastplayed\" \"$tmp.installed\" \"$tmp.script\"' EXIT\n"
			"\n"
			"# Find all app ID directories with portrait images only\n"
			"for d in \"$steam_root/appcache/librarycache\"/[0-9]*; do\n"
			"  [ -d \"$d\" ] || continue\n"
			"  appid=$(basename \"$d\")\n"
			"  [ -f \"$d/library_600x900.jpg\" ] || continue\n"
			"  echo \"$appid\" >> \"$tmp\"\n"
			"done\n"
			"\n"
			"# Get installed apps\n"
			"for f in \"$steam_root/steamapps\"/appmanifest_*.acf; do\n"
			"  [ -f \"$f\" ] || continue\n"
			"  basename \"$f\" | sed 's/appmanifest_//;s/.acf//'\n"
			"done > \"$tmp.installed\"\n"
			"\n"
			"# Find userdata directory (use first found)\n"
			"userdir=$(ls -d \"$steam_root/userdata\"/[0-9]* 2>/dev/null | head -1)\n"
			"lcfg=\"$userdir/config/localconfig.vdf\"\n"
			"# Parse playtime and LastPlayed from localconfig.vdf\n"
			"if [ -f \"$lcfg\" ]; then\n"
			"  awk '/^[[:space:]]*\"[0-9]+\"[[:space:]]*$/{gsub(/\\\"/,\"\",$0);gsub(/[[:space:]]/,\"\",$0);if($0~/^[0-9]+$/)id=$0} /\"Playtime\"/{split($0,a,\"\\\"\");if(id)print id\"|\"a[4]}' \"$lcfg\" > \"$tmp.playtime\"\n"
			"  awk '/^[[:space:]]*\"[0-9]+\"[[:space:]]*$/{gsub(/\\\"/,\"\",$0);gsub(/[[:space:]]/,\"\",$0);if($0~/^[0-9]+$/)id=$0} /\"LastPlayed\"/{split($0,a,\"\\\"\");v=a[4];if(id && v>86400)print id\"|\"v}' \"$lcfg\" > \"$tmp.lastplayed\"\n"
			"fi\n"
			"\n"
			"# Fetch from Steam API - name, type, controller support, deck status\n"
			"rm -f \"$tmp.api\"\n"
			"touch \"$tmp.api\"\n"
			"count=0\n"
			"while read -r appid; do\n"
			"  [ -z \"$appid\" ] && continue\n"
			"  echo \"(r=\\$(curl -s --max-time 8 -A 'Mozilla/5.0' 'https://store.steampowered.com/api/appdetails?appids=$appid');\"\n"
			"  echo \" n=\\$(echo \\\"\\$r\\\" | grep -o '\\\"name\\\":\\\"[^\\\"]*\\\"' | head -1 | sed 's/\\\"name\\\":\\\"//;s/\\\"\\$//');\"\n"
			"  echo \" t=\\$(echo \\\"\\$r\\\" | grep -o '\\\"type\\\":\\\"[^\\\"]*\\\"' | head -1 | sed 's/\\\"type\\\":\\\"//;s/\\\"\\$//');\"\n"
			"  echo \" ctrl=0; echo \\\"\\$r\\\" | grep -q '\\\"id\\\":28' && ctrl=2; echo \\\"\\$r\\\" | grep -q '\\\"id\\\":18' && [ \\$ctrl -eq 0 ] && ctrl=1;\"\n"
			"  echo \" deck=0; dr=\\$(curl -s --max-time 5 -A 'Mozilla/5.0' 'https://store.steampowered.com/saleaction/ajaxgetdeckappcompatibilityreport?nAppID=$appid');\"\n"
			"  echo \" case \\\"\\$dr\\\" in *\\\"category\\\":3*) deck=3;; *\\\"category\\\":2*) deck=2;; *\\\"category\\\":1*) deck=1;; esac;\"\n"
			"  echo \" [ -n \\\"\\$n\\\" ] && echo '$appid|'\\\"\\$n\\\"'|'\\\"\\$t\\\"'|'\\\"\\$ctrl\\\"'|'\\\"\\$deck\\\" >> '$tmp.api') &\"\n"
			"  count=$((count+1))\n"
			"  if [ $count -ge 25 ]; then\n"
			"    echo 'wait'\n"
			"    count=0\n"
			"  fi\n"
			"done < \"$tmp\" > \"$tmp.script\"\n"
			"echo 'wait' >> \"$tmp.script\"\n"
			"sh \"$tmp.script\" 2>/dev/null\n"
			"\n"
			"# Build cache - only deck-ready games with controller support\n"
			"games=0\n"
			"output=$(mktemp)\n"
			"while read -r appid; do\n"
			"  [ -z \"$appid\" ] && continue\n"
			"  line=$(grep \"^$appid|\" \"$tmp.api\" 2>/dev/null | head -1)\n"
			"  [ -z \"$line\" ] && continue\n"
			"  name=$(echo \"$line\" | cut -d'|' -f2)\n"
			"  type=$(echo \"$line\" | cut -d'|' -f3)\n"
			"  ctrl=$(echo \"$line\" | cut -d'|' -f4)\n"
			"  deck=$(echo \"$line\" | cut -d'|' -f5)\n"
			"  [ -z \"$name\" ] && continue\n"
			"  [ -z \"$ctrl\" ] && ctrl=0\n"
			"  [ -z \"$deck\" ] && deck=0\n"
			"  # Skip if no controller support or not deck playable/verified\n"
			"  [ \"$ctrl\" -lt 1 ] 2>/dev/null && continue\n"
			"  [ \"$deck\" -lt 2 ] 2>/dev/null && continue\n"
			"  icon=\"$steam_root/appcache/librarycache/${appid}/library_600x900.jpg\"\n"
			"  launch=\"steam steam://rungameid/$appid\"\n"
			"  installed=0; grep -qx \"$appid\" \"$tmp.installed\" 2>/dev/null && installed=1\n"
			"  playtime=0; pt=$(grep \"^$appid|\" \"$tmp.playtime\" 2>/dev/null | cut -d'|' -f2); [ -n \"$pt\" ] && playtime=$pt\n"
			"  acquired=0; lp=$(grep \"^$appid|\" \"$tmp.lastplayed\" 2>/dev/null | cut -d'|' -f2)\n"
			"  [ -n \"$lp\" ] && [ \"$lp\" -gt 86400 ] 2>/dev/null && acquired=$lp\n"
			"  is_game=1\n"
			"  case \"$type\" in dlc|tool|demo|mod|video|music|advertising|series|episode|hardware) is_game=0;; esac\n"
			"  case \"$name\" in *Proton*|*'Dedicated Server'*|*SDK*|*Runtime*|*Redistributable*|*Steamworks*|*Soundtrack*) is_game=0;; esac\n"
			"  [ $is_game -eq 0 ] && continue\n"
			"  echo \"$appid|$name|$icon|$launch|0|$installed|$playtime|$is_game|$acquired|$ctrl|$deck\" >> \"$output\"\n"
			"  games=$((games+1))\n"
			"done < \"$tmp\"\n"
			"\n"
			"{ echo 'NIXLYTILE_GAMES_CACHE_V7'; echo \"$games\"; sort -t'|' -k9 -rn \"$output\"; } > \"$cache.tmp\" && mv \"$cache.tmp\" \"$cache\"\n"
			"rm -f \"$output\"\n",
			(char *)NULL);
		_exit(127);
	} else if (pid > 0) {
		wlr_log(WLR_INFO, "pc gaming cache update started: pid=%d", pid);
	}
}

static int
cache_update_timer_cb(void *data)
{
	(void)data;
	if (!game_mode_active && !htpc_mode_active) {
		/* Run only one cache update at a time, cycling through phases */
		switch (cache_update_phase) {
		case 0:
			git_cache_update_start();
			break;
		case 1:
			file_cache_update_start();
			break;
		case 2:
			pc_gaming_cache_update_start();
			break;
		}
		cache_update_phase = (cache_update_phase + 1) % 3;
	}
	schedule_cache_update_timer();
	return 0;
}

static void
schedule_cache_update_timer(void)
{
	if (!cache_update_timer || game_mode_active || htpc_mode_active)
		return;
	/* 5 minutes between each cache type = 15 min full cycle
	 * 5 minutes = 5 * 60 * 1000 ms = 300000 ms */
	wl_event_source_timer_update(cache_update_timer, 300000);
}

static void
nixpkgs_cache_update_start(void)
{
	pid_t pid;
	char *home;
	char cache_path[PATH_MAX];

	if (game_mode_active || htpc_mode_active)
		return;

	home = getenv("HOME");
	if (!home)
		home = "/tmp";
	snprintf(cache_path, sizeof(cache_path), "%s/.cache/nixlytile-nixpkgs-stable.txt", home);

	pid = fork();
	if (pid == 0) {
		setsid();
		/* Update nixpkgs cache from nixpkgs-stable flake input with low priority */
		char cmd[2048];
		snprintf(cmd, sizeof(cmd),
			"nice -n 19 ionice -c 3 sh -c \""
			"nix eval --raw ~/.nixlyos#nixpkgs-stable.outPath 2>/dev/null | "
			"xargs -I{} nix-env -qaP -f {} 2>/dev/null | "
			"awk 'index(\\$1, \\\".\\\") == 0 {print \\$1\\\"\\\\t\\\"\\$2}' | "
			"sed 's/\\\\t.*-\\([0-9]\\)/\\\\t\\1/' > '%s'\"",
			cache_path);
		execl("/bin/sh", "sh", "-c", cmd, NULL);
		_exit(127);
	} else if (pid > 0) {
		wlr_log(WLR_INFO, "nixpkgs cache update started: pid=%d", pid);
	}
}

static int
nixpkgs_cache_timer_cb(void *data)
{
	(void)data;
	if (!game_mode_active && !htpc_mode_active) {
		nixpkgs_cache_update_start();
	}
	schedule_nixpkgs_cache_timer();
	return 0;
}

static void
schedule_nixpkgs_cache_timer(void)
{
	if (!nixpkgs_cache_timer)
		return;
	/* 1 week = 7 * 24 * 60 * 60 * 1000 ms = 604800000 ms */
	wl_event_source_timer_update(nixpkgs_cache_timer, 604800000);
}

/* Check if any client is currently fullscreen AND visible, return the client if found */
static Client *
get_fullscreen_client(void)
{
	Client *c;
	wl_list_for_each(c, &clients, link) {
		if (c->isfullscreen && client_surface(c)->mapped && VISIBLEON(c, c->mon))
			return c;
	}
	return NULL;
}

/* Check if any client is currently fullscreen */
static int
any_client_fullscreen(void)
{
	return get_fullscreen_client() != NULL;
}

/*
 * Get the PID of a Wayland client.
 * Returns 0 if the PID cannot be determined.
 */
static pid_t
client_get_pid(Client *c)
{
	struct wlr_surface *surface;
	struct wl_client *wl_client;
	pid_t pid = 0;
	uid_t uid;
	gid_t gid;

	if (!c)
		return 0;

	surface = client_surface(c);
	if (!surface || !surface->resource)
		return 0;

	wl_client = wl_resource_get_client(surface->resource);
	if (!wl_client)
		return 0;

	wl_client_get_credentials(wl_client, &pid, &uid, &gid);
	return pid;
}

/*
 * Apply high-priority scheduling to a game process for optimal performance.
 *
 * This sets:
 * 1. Nice value to -5 (higher CPU priority than normal processes)
 * 2. I/O priority to real-time class (faster disk access)
 * 3. SCHED_RR for compositor thread (optional, requires CAP_SYS_NICE)
 *
 * These optimizations reduce latency and ensure the game gets CPU time
 * when it needs it, similar to what gamemode daemon does.
 */
static void
apply_game_priority(pid_t pid)
{
	char cmd[256];

	if (pid <= 1)
		return;

	/*
	 * Set nice value to -5 (requires CAP_SYS_NICE or root).
	 * This gives the game higher CPU scheduling priority.
	 * -5 is aggressive but not extreme (-20 is max).
	 */
	snprintf(cmd, sizeof(cmd), "renice -n -5 -p %d 2>/dev/null", pid);
	if (system(cmd) == 0) {
		game_mode_nice_applied = 1;
		wlr_log(WLR_INFO, "Game priority: set nice=-5 for PID %d", pid);
	}

	/*
	 * Set I/O scheduling to best-effort class with high priority (0).
	 * This ensures the game gets fast disk access for asset loading.
	 * Class 2 = best-effort, priority 0 = highest within class.
	 */
	snprintf(cmd, sizeof(cmd), "ionice -c 2 -n 0 -p %d 2>/dev/null", pid);
	if (system(cmd) == 0) {
		game_mode_ioclass_applied = 1;
		wlr_log(WLR_INFO, "Game priority: set ionice class=2 prio=0 for PID %d", pid);
	}

	/*
	 * Disable CPU frequency scaling governor to prevent throttling.
	 * This keeps the CPU at high frequency for consistent performance.
	 * Note: Only works if user has permission to write to sysfs.
	 */
	(void)system("for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do "
	             "echo performance > \"$cpu\" 2>/dev/null; done");
}

/*
 * Restore normal priority for a process after game mode ends.
 */
static void
restore_game_priority(pid_t pid)
{
	char cmd[256];

	if (pid <= 1)
		return;

	/* Restore nice value to 0 (normal) */
	if (game_mode_nice_applied) {
		snprintf(cmd, sizeof(cmd), "renice -n 0 -p %d 2>/dev/null", pid);
		(void)system(cmd);
		game_mode_nice_applied = 0;
		wlr_log(WLR_INFO, "Game priority: restored nice=0 for PID %d", pid);
	}

	/* Restore I/O priority to normal (class 2, priority 4) */
	if (game_mode_ioclass_applied) {
		snprintf(cmd, sizeof(cmd), "ionice -c 2 -n 4 -p %d 2>/dev/null", pid);
		(void)system(cmd);
		game_mode_ioclass_applied = 0;
	}

	/*
	 * Restore CPU governor to powersave/schedutil (common defaults).
	 * This allows the CPU to scale down when not gaming.
	 */
	(void)system("for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do "
	             "echo schedutil > \"$cpu\" 2>/dev/null || echo powersave > \"$cpu\" 2>/dev/null; done");
}

/*
 * Check system memory pressure for performance monitoring.
 * Returns a value 0-100 indicating memory pressure (0=no pressure, 100=critical).
 */
static int
get_memory_pressure(void)
{
	FILE *f;
	char line[256];
	unsigned long mem_total = 0, mem_available = 0;
	int pressure = 0;

	f = fopen("/proc/meminfo", "r");
	if (!f)
		return 0;

	while (fgets(line, sizeof(line), f)) {
		if (strncmp(line, "MemTotal:", 9) == 0) {
			sscanf(line + 9, "%lu", &mem_total);
		} else if (strncmp(line, "MemAvailable:", 13) == 0) {
			sscanf(line + 13, "%lu", &mem_available);
		}
	}
	fclose(f);

	if (mem_total > 0 && mem_available > 0) {
		/* Calculate percentage of memory in use */
		pressure = 100 - (int)(mem_available * 100 / mem_total);
	}

	return pressure;
}

/*
 * Ultra Game Mode - Maximum performance when fullscreen game detected.
 *
 * This is an aggressive optimization mode that minimizes ALL compositor
 * overhead when a game is running fullscreen:
 *
 * 1. Stops ALL background timers (cache updates, status polling, wifi scans, etc.)
 * 2. Hides the statusbar completely
 * 3. Hides all popups and menus
 * 4. Disables compositor animations
 * 5. Direct scanout is automatically activated by wlroots when conditions are met
 * 6. Tearing is enabled for games that request it (lowest latency)
 *
 * The goal is minimal latency path - the game's buffer goes directly to display
 * without any compositor processing or system interrupts from background tasks.
 */
static void
update_game_mode(void)
{
	int was_active = game_mode_active;
	int was_ultra = game_mode_ultra;
	Client *c = get_fullscreen_client();
	Monitor *m;
	int is_game = 0;

	game_mode_active = (c != NULL);
	game_mode_client = c;

	/* Determine if this is actually a game (vs video or other fullscreen content) */
	if (c) {
		is_game = client_wants_tearing(c) || is_game_content(c);
	}

	/* Ultra mode activates for games, regular game mode for other fullscreen content */
	game_mode_ultra = (game_mode_active && is_game);

	if (game_mode_ultra && !was_ultra) {
		/*
		 * ENTERING ULTRA GAME MODE
		 * Maximum performance - stop everything non-essential
		 */
		wlr_log(WLR_INFO, "ULTRA GAME MODE ACTIVATED - maximum performance, minimal latency");

		/* Show "Game detected" notification for 1 second */
		if (c && c->mon)
			toast_show(c->mon, "Game detected", 1000);

		/* Stop ALL background timers to eliminate compositor interrupts */
		if (cache_update_timer)
			wl_event_source_timer_update(cache_update_timer, 0);
		if (nixpkgs_cache_timer)
			wl_event_source_timer_update(nixpkgs_cache_timer, 0);
		if (status_cpu_timer)
			wl_event_source_timer_update(status_cpu_timer, 0);
		if (status_timer)
			wl_event_source_timer_update(status_timer, 0);
		if (status_hover_timer)
			wl_event_source_timer_update(status_hover_timer, 0);
		if (cpu_popup_refresh_timer)
			wl_event_source_timer_update(cpu_popup_refresh_timer, 0);
		if (ram_popup_refresh_timer)
			wl_event_source_timer_update(ram_popup_refresh_timer, 0);
		if (wifi_scan_timer)
			wl_event_source_timer_update(wifi_scan_timer, 0);
		if (video_check_timer)
			wl_event_source_timer_update(video_check_timer, 0);
		if (popup_delay_timer)
			wl_event_source_timer_update(popup_delay_timer, 0);
		if (config_rewatch_timer)
			wl_event_source_timer_update(config_rewatch_timer, 0);
		if (gamepad_inactivity_timer)
			wl_event_source_timer_update(gamepad_inactivity_timer, 0);
		if (gamepad_cursor_timer)
			wl_event_source_timer_update(gamepad_cursor_timer, 0);
		if (hz_osd_timer)
			wl_event_source_timer_update(hz_osd_timer, 0);
		if (pc_gaming_install_timer)
			wl_event_source_timer_update(pc_gaming_install_timer, 0);
		/* NOTE: Keep bt_scan_timer - needed for controller reconnection */
		/* NOTE: Keep gamepad_pending_timer - needed for controller input */

		/* Hide statusbar on the monitor with the game */
		if (c && c->mon) {
			c->mon->showbar = 0;
			if (c->mon->statusbar.tree)
				wlr_scene_node_set_enabled(&c->mon->statusbar.tree->node, 0);
		}

		/* Hide all popups and menus - they would just be occluded anyway */
		net_menu_hide_all();
		wifi_popup_hide_all();
		sudo_popup_hide_all();
		tray_menu_hide_all();
		/* Don't hide modal/nixpkgs - user might be searching while game loads */

		/*
		 * Apply high-priority scheduling to the game process.
		 * This gives the game more CPU time and faster I/O access.
		 */
		game_mode_pid = client_get_pid(c);
		if (game_mode_pid > 1) {
			apply_game_priority(game_mode_pid);
		}

		/*
		 * Ensure the game client has keyboard focus.
		 * This is critical for games to receive keyboard input immediately.
		 * Use lift=1 to raise to top and warp cursor for immediate input.
		 */
		exclusive_focus = NULL;  /* Clear any exclusive focus that might block */
		focusclient(c, 1);

		/*
		 * Enable game VRR for optimal frame pacing.
		 * This is also done in setfullscreen(), but we need it here too
		 * for when returning to a tag with a fullscreen game.
		 */
		if (c && c->mon && (is_game_content(c) || client_wants_tearing(c))) {
			enable_game_vrr(c->mon);
		}

	} else if (game_mode_ultra && was_ultra && c) {
		/*
		 * RETURNING TO ULTRA GAME MODE (e.g., switching back to tag with fullscreen game)
		 * Focus is now handled automatically by arrange() for all fullscreen clients.
		 * Re-enable VRR in case it was disabled when switching away.
		 */
		if (c->mon && !c->mon->game_vrr_active) {
			enable_game_vrr(c->mon);
		}

	} else if (game_mode_active && !was_active && !game_mode_ultra) {
		/*
		 * ENTERING REGULAR GAME MODE (non-game fullscreen like video)
		 * Less aggressive - just pause some background tasks
		 */
		wlr_log(WLR_INFO, "Game mode activated (non-game fullscreen) - pausing background tasks");

		if (cache_update_timer)
			wl_event_source_timer_update(cache_update_timer, 0);
		if (nixpkgs_cache_timer)
			wl_event_source_timer_update(nixpkgs_cache_timer, 0);
		if (status_cpu_timer)
			wl_event_source_timer_update(status_cpu_timer, 0);

	} else if (!game_mode_active && was_active) {
		/*
		 * EXITING GAME MODE - restore everything
		 */
		wlr_log(WLR_INFO, "Game mode deactivated - restoring normal operation");

		/* Resume all background timers */
		schedule_cache_update_timer();
		schedule_nixpkgs_cache_timer();
		schedule_status_timer();
		schedule_next_status_refresh();

		/* Restore additional timers if we were in ultra mode */
		if (was_ultra) {
			/* Re-enable statusbar on all monitors */
			wl_list_for_each(m, &mons, link) {
				m->showbar = 1;
				if (m->statusbar.tree)
					wlr_scene_node_set_enabled(&m->statusbar.tree->node, 1);
				/* Disable game VRR on all monitors when leaving game mode */
				if (m->game_vrr_active)
					disable_game_vrr(m);
			}

			/* Schedule deferred timer restarts for non-critical tasks */
			if (wifi_scan_timer)
				wl_event_source_timer_update(wifi_scan_timer, 5000);  /* 5s delay */
			if (config_rewatch_timer)
				wl_event_source_timer_update(config_rewatch_timer, 2000);

			/* Restore normal priority for the game process */
			if (game_mode_pid > 1) {
				restore_game_priority(game_mode_pid);
			}

			wlr_log(WLR_INFO, "Ultra game mode deactivated - full system restored");
		}

		game_mode_ultra = 0;
		game_mode_client = NULL;
		game_mode_pid = 0;
	}
}

/* Set GE-Proton as the default compatibility tool in Steam */
static void
steam_set_ge_proton_default(void)
{
	char compat_dir[PATH_MAX];
	char config_path[PATH_MAX];
	char ge_proton_name[128] = {0};
	int best_major = 0, best_minor = 0;
	const char *home = getenv("HOME");
	DIR *dir;
	struct dirent *entry;
	FILE *fp;
	char *config_content = NULL;
	size_t config_size = 0;

	if (!home)
		return;

	/* Find newest GE-Proton in compatibilitytools.d */
	snprintf(compat_dir, sizeof(compat_dir), "%s/.steam/root/compatibilitytools.d", home);
	dir = opendir(compat_dir);
	if (!dir) {
		snprintf(compat_dir, sizeof(compat_dir), "%s/.local/share/Steam/compatibilitytools.d", home);
		dir = opendir(compat_dir);
	}

	if (dir) {
		while ((entry = readdir(dir)) != NULL) {
			if (strncmp(entry->d_name, "GE-Proton", 9) == 0) {
				int major = 0, minor = 0;
				/* Parse GE-ProtonX-Y format */
				if (sscanf(entry->d_name, "GE-Proton%d-%d", &major, &minor) >= 1) {
					if (major > best_major || (major == best_major && minor > best_minor)) {
						best_major = major;
						best_minor = minor;
						snprintf(ge_proton_name, sizeof(ge_proton_name), "%s", entry->d_name);
					}
				}
			}
		}
		closedir(dir);
	}

	if (!ge_proton_name[0]) {
		wlr_log(WLR_INFO, "No GE-Proton found in compatibilitytools.d");
		return;
	}

	wlr_log(WLR_INFO, "Setting %s as default Steam compatibility tool", ge_proton_name);

	/* Read current config.vdf */
	snprintf(config_path, sizeof(config_path), "%s/.steam/steam/config/config.vdf", home);
	fp = fopen(config_path, "r");
	if (!fp) {
		snprintf(config_path, sizeof(config_path), "%s/.local/share/Steam/config/config.vdf", home);
		fp = fopen(config_path, "r");
	}

	if (!fp) {
		wlr_log(WLR_ERROR, "Could not open Steam config.vdf");
		return;
	}

	/* Read entire file */
	fseek(fp, 0, SEEK_END);
	config_size = ftell(fp);
	fseek(fp, 0, SEEK_SET);
	config_content = malloc(config_size + 4096); /* Extra space for modifications */
	if (!config_content) {
		fclose(fp);
		return;
	}
	fread(config_content, 1, config_size, fp);
	config_content[config_size] = '\0';
	fclose(fp);

	/* Check if CompatToolMapping already exists with our GE-Proton */
	if (strstr(config_content, ge_proton_name)) {
		wlr_log(WLR_INFO, "%s already configured in Steam", ge_proton_name);
		free(config_content);
		return;
	}

	/* Find CompatToolMapping section or create it */
	char *compat_section = strstr(config_content, "\"CompatToolMapping\"");
	if (compat_section) {
		/* Find the "0" entry (global default) within CompatToolMapping */
		char *zero_entry = strstr(compat_section, "\"0\"");
		if (zero_entry && zero_entry < compat_section + 500) {
			/* Replace existing "0" entry - find its closing brace */
			char *entry_start = zero_entry;
			char *brace_open = strchr(entry_start, '{');
			if (brace_open) {
				int depth = 1;
				char *brace_close = brace_open + 1;
				while (*brace_close && depth > 0) {
					if (*brace_close == '{') depth++;
					else if (*brace_close == '}') depth--;
					brace_close++;
				}
				/* Replace content between braces */
				char new_entry[512];
				snprintf(new_entry, sizeof(new_entry),
					"{\n\t\t\t\t\t\t\"name\"\t\t\"%s\"\n"
					"\t\t\t\t\t\t\"config\"\t\t\"\"\n"
					"\t\t\t\t\t\t\"priority\"\t\t\"75\"\n"
					"\t\t\t\t\t}",
					ge_proton_name);

				/* Build new config */
				size_t prefix_len = brace_open - config_content + 1;
				size_t suffix_start = brace_close - config_content;
				char *new_config = malloc(config_size + 4096);
				if (new_config) {
					memcpy(new_config, config_content, prefix_len);
					strcpy(new_config + prefix_len, new_entry + 1); /* Skip first { */
					strcat(new_config, config_content + suffix_start);

					fp = fopen(config_path, "w");
					if (fp) {
						fputs(new_config, fp);
						fclose(fp);
						wlr_log(WLR_INFO, "Updated Steam config with %s as default", ge_proton_name);
					}
					free(new_config);
				}
			}
		}
	}

	free(config_content);
}

/* HTPC mode - optimized for controller/TV usage */
static void
htpc_mode_enter(void)
{
	Monitor *m;
	Client *c, *tmp;

	if (htpc_mode == 0 || htpc_mode_active)
		return;

	htpc_mode_active = 1;
	wlr_log(WLR_INFO, "HTPC mode activated - killing all clients, minimizing system load");

	/* Close all client windows gracefully */
	wl_list_for_each_safe(c, tmp, &clients, link) {
		client_send_close(c);
	}

	/* Hide statusbar on all monitors */
	wl_list_for_each(m, &mons, link) {
		m->showbar = 0;
		if (m->statusbar.tree)
			wlr_scene_node_set_enabled(&m->statusbar.tree->node, 0);
	}

	/* Hide all status menus and popups */
	net_menu_hide_all();
	wifi_popup_hide_all();
	sudo_popup_hide_all();
	tray_menu_hide_all();
	modal_hide_all();
	nixpkgs_hide_all();
	gamepad_menu_hide_all();
	pc_gaming_hide_all();

	/* Stop ALL background timers to minimize CPU/IO/RAM */
	if (cache_update_timer)
		wl_event_source_timer_update(cache_update_timer, 0);
	if (nixpkgs_cache_timer)
		wl_event_source_timer_update(nixpkgs_cache_timer, 0);
	if (status_cpu_timer)
		wl_event_source_timer_update(status_cpu_timer, 0);
	if (status_timer)
		wl_event_source_timer_update(status_timer, 0);
	if (status_hover_timer)
		wl_event_source_timer_update(status_hover_timer, 0);
	if (cpu_popup_refresh_timer)
		wl_event_source_timer_update(cpu_popup_refresh_timer, 0);
	if (ram_popup_refresh_timer)
		wl_event_source_timer_update(ram_popup_refresh_timer, 0);
	if (wifi_scan_timer)
		wl_event_source_timer_update(wifi_scan_timer, 0);
	/* NOTE: Keep bt_scan_timer running - needed for controller reconnection */
	if (video_check_timer)
		wl_event_source_timer_update(video_check_timer, 0);
	if (popup_delay_timer)
		wl_event_source_timer_update(popup_delay_timer, 0);
	if (config_rewatch_timer)
		wl_event_source_timer_update(config_rewatch_timer, 0);

	/* Start media view poll timer (3 second refresh) */
	if (!media_view_poll_timer)
		media_view_poll_timer = wl_event_loop_add_timer(event_loop, media_view_poll_timer_cb, NULL);
	if (media_view_poll_timer)
		wl_event_source_timer_update(media_view_poll_timer, 3000);

	/* Kill non-essential processes */
	if (fork() == 0) {
		setsid();
		execl("/bin/sh", "sh", "-c",
			"pkill -9 -f 'thunar|nautilus|dolphin' 2>/dev/null; "
			"pkill -9 -f 'code|codium|sublime' 2>/dev/null; "
			"pkill -9 -f 'firefox|chromium|brave|chrome' 2>/dev/null; "
			"pkill -9 -f 'discord|slack|telegram|signal' 2>/dev/null; "
			"pkill -9 -f 'spotify|rhythmbox|vlc|mpv' 2>/dev/null; "
			"pkill -9 -f 'gimp|inkscape|blender|kdenlive' 2>/dev/null; "
			"pkill -9 -f 'libreoffice|evince|zathura' 2>/dev/null; "
			"pkill -9 -f 'alacritty|foot|kitty|wezterm|konsole|gnome-terminal' 2>/dev/null; "
			"sync; echo 3 > /proc/sys/vm/drop_caches 2>/dev/null; "
			"echo 10 > /proc/sys/vm/swappiness 2>/dev/null",
			(char *)NULL);
		_exit(0);
	}

	/* Set HTPC wallpaper */
	{
		char expanded_htpc_wp[PATH_MAX];
		config_expand_path(htpc_wallpaper_path, expanded_htpc_wp, sizeof(expanded_htpc_wp));
		wlr_log(WLR_INFO, "HTPC mode: setting wallpaper to %s", expanded_htpc_wp);

		pid_t pid = fork();
		if (pid == 0) {
			setsid();
			/* Kill swaybg, wait, then exec new swaybg directly */
			system("pkill -9 swaybg 2>/dev/null; sleep 0.5");
			execlp("swaybg", "swaybg", "-i", expanded_htpc_wp, "-m", "fill", (char *)NULL);
			_exit(127);
		}
	}

	/* Ensure we start on tag 1 (TV-shows) */
	if (selmon) {
		selmon->seltags ^= 1;
		selmon->tagset[selmon->seltags] = 1 << 0; /* Tag 1 = bit 0 */
		/* Show TV-shows view as default */
		media_view_show(selmon, MEDIA_VIEW_TVSHOWS);
	}

	/* NOTE: Steam is NOT started here - it will be launched on-demand
	 * when the user selects PC-gaming or switches to tag 4 */

	/* Re-arrange all monitors */
	wl_list_for_each(m, &mons, link) {
		arrange(m);
	}

	/* Clear focus since all clients are being closed */
	focusclient(NULL, 0);

	/* Grab gamepads for HTPC UI navigation (unless on Steam tag) */
	gamepad_update_grab_state();
}

static void
htpc_mode_exit(void)
{
	Monitor *m;
	Client *c, *tmp;

	if (!htpc_mode_active)
		return;

	htpc_mode_active = 0;
	wlr_log(WLR_INFO, "HTPC mode deactivated - cleaning up, showing statusbar, resuming background tasks");

	/* Stop media view poll timer */
	if (media_view_poll_timer)
		wl_event_source_timer_update(media_view_poll_timer, 0);

	/* Kill Steam and close all clients to get clean tags */
	if (fork() == 0) {
		setsid();
		execl("/bin/sh", "sh", "-c", "pkill -9 steam 2>/dev/null", (char *)NULL);
		_exit(0);
	}

	/* Close all remaining client windows */
	wl_list_for_each_safe(c, tmp, &clients, link) {
		client_send_close(c);
	}

	/* Switch to tag 1 on all monitors */
	wl_list_for_each(m, &mons, link) {
		m->seltags ^= 1;
		m->tagset[m->seltags] = 1 << 0; /* Tag 1 = bit 0 */
	}

	/* Restore normal wallpaper */
	{
		char expanded_wp[PATH_MAX];
		config_expand_path(wallpaper_path, expanded_wp, sizeof(expanded_wp));
		wlr_log(WLR_INFO, "Restoring wallpaper: %s", expanded_wp);

		pid_t pid = fork();
		if (pid == 0) {
			setsid();
			system("pkill -9 swaybg 2>/dev/null; sleep 0.5");
			execlp("swaybg", "swaybg", "-i", expanded_wp, "-m", "fill", (char *)NULL);
			_exit(127);
		}
	}

	/* Show statusbar on all monitors */
	wl_list_for_each(m, &mons, link) {
		m->showbar = 1;
		if (m->statusbar.tree)
			wlr_scene_node_set_enabled(&m->statusbar.tree->node, 1);
	}

	/* Resume background timers (unless game mode is active) */
	if (!game_mode_active) {
		schedule_cache_update_timer();
		schedule_nixpkgs_cache_timer();
		schedule_status_timer();
		schedule_next_status_refresh();
	}

	/* Re-arrange all monitors to allocate statusbar space */
	wl_list_for_each(m, &mons, link) {
		arrange(m);
	}

	/* Release gamepad grab when leaving HTPC mode */
	gamepad_update_grab_state();
}

static void
htpc_mode_toggle(const Arg *arg)
{
	(void)arg;

	if (htpc_mode == 0)
		return;

	if (htpc_mode_active)
		htpc_mode_exit();
	else
		htpc_mode_enter();
}

static void
modal_truncate_to_width(const char *src, char *dst, size_t len, int max_px)
{
	size_t n;

	if (!dst || len == 0) {
		return;
	}
	dst[0] = '\0';
	if (!src || !*src || max_px <= 0) {
		return;
	}

	snprintf(dst, len, "%s", src);
	if (status_text_width(dst) <= max_px)
		return;

	n = strlen(dst);
	if (len < 4) {
		dst[0] = '\0';
		return;
	}

	while (n > 0 && status_text_width(dst) > max_px) {
		n--;
		if (n < 3) {
			dst[0] = '\0';
			return;
		}
		dst[n] = '\0';
	}

	if (strlen(dst) + 3 < len) {
		strncat(dst, "...", len - strlen(dst) - 1);
	}
}

static int
desktop_entry_cmp_used(const void *a, const void *b)
{
	int ia = *(const int *)a;
	int ib = *(const int *)b;
	int ua = desktop_entries[ia].used;
	int ub = desktop_entries[ib].used;
	int namecmp;

	if (ua != ub)
		return (ua < ub) ? 1 : -1; /* more used first */

	namecmp = strcasecmp(desktop_entries[ia].name, desktop_entries[ib].name);
	if (namecmp != 0)
		return namecmp;

	return ia - ib;
}

static int
modal_match_name(const char *haystack, const char *needle)
{
	if (!needle || !*needle)
		return 1;
	if (!haystack || !*haystack)
		return 0;

	return strstr(haystack, needle) != NULL;
}

static void
strip_trailing_space(char *s)
{
	size_t len;

	if (!s)
		return;
	len = strlen(s);
	while (len > 0 && (s[len - 1] == '\n' || s[len - 1] == '\r' ||
				s[len - 1] == ' ' || s[len - 1] == '\t')) {
		s[len - 1] = '\0';
		len--;
	}
}

static int
desktop_entry_exists(const char *name)
{
	if (!name || !*name)
		return 0;
	for (int i = 0; i < desktop_entry_count; i++) {
		if (!strcasecmp(desktop_entries[i].name, name))
			return 1;
	}
	return 0;
}

static int
appdir_exists(char appdirs[][PATH_MAX], int count, const char *path)
{
	for (int i = 0; i < count; i++) {
		if (!strcmp(appdirs[i], path))
			return 1;
	}
	return 0;
}

static void
load_desktop_dir_rec(const char *dir, int depth)
{
	struct dirent *ent;
	DIR *d;

	if (!dir || !*dir || depth > 5 || desktop_entry_count >= (int)LENGTH(desktop_entries))
		return;

	d = opendir(dir);
	if (!d)
		return;

	while ((ent = readdir(d))) {
		char path[PATH_MAX];
		FILE *fp;
		char line[512];
		char name[256] = {0};
		char exec[512] = {0};
		int nodisplay = 0;
		int hidden = 0;
		int isdir = 0;
		int in_main_section = 0;
		int prefers_dgpu = 0;

		if (desktop_entry_count >= (int)LENGTH(desktop_entries))
			break;

		if (ent->d_type == DT_DIR) {
			isdir = 1;
		} else if (ent->d_type == DT_UNKNOWN || ent->d_type == DT_LNK) {
			struct stat st = {0};
			if (snprintf(path, sizeof(path), "%s/%s", dir, ent->d_name) >= (int)sizeof(path))
				continue;
			if (stat(path, &st) == 0 && S_ISDIR(st.st_mode))
				isdir = 1;
		}

		if (isdir) {
			if (ent->d_name[0] == '.' || depth >= 5)
				continue;
			if (snprintf(path, sizeof(path), "%s/%s", dir, ent->d_name) >= (int)sizeof(path))
				continue;
			load_desktop_dir_rec(path, depth + 1);
			continue;
		}

		if (!strstr(ent->d_name, ".desktop"))
			continue;
		if (snprintf(path, sizeof(path), "%s/%s", dir, ent->d_name) >= (int)sizeof(path))
			continue;
		fp = fopen(path, "r");
		if (!fp)
			continue;

		while (fgets(line, sizeof(line), fp)) {
			if (line[0] == '[') {
				if (!strncmp(line, "[Desktop Entry]", 15)) {
					in_main_section = 1;
					continue;
				}
				if (in_main_section)
					break; /* stop at first other section */
				continue;
			}

			if (!in_main_section)
				continue;

			if (!strncmp(line, "Name=", 5)) {
				snprintf(name, sizeof(name), "%s", line + 5);
			} else if (!strncmp(line, "Name[", 5) && !name[0]) {
				char *eq = strchr(line, '=');
				if (eq && eq[1])
					snprintf(name, sizeof(name), "%s", eq + 1);
			} else if (!strncmp(line, "Exec=", 5)) {
				snprintf(exec, sizeof(exec), "%s", line + 5);
			} else if (!strncmp(line, "NoDisplay=", 10)) {
				const char *val = line + 10;
				if (!strncasecmp(val, "true", 4))
					nodisplay = 1;
			} else if (!strncmp(line, "Hidden=", 7)) {
				const char *val = line + 7;
				if (!strncasecmp(val, "true", 4))
					hidden = 1;
			} else if (!strncmp(line, "PrefersNonDefaultGPU=", 21)) {
				const char *val = line + 21;
				if (!strncasecmp(val, "true", 4))
					prefers_dgpu = 1;
			} else if (!strncmp(line, "X-KDE-RunOnDiscreteGpu=", 23)) {
				const char *val = line + 23;
				if (!strncasecmp(val, "true", 4))
					prefers_dgpu = 1;
			}
		}
		fclose(fp);

		strip_trailing_space(name);
		strip_trailing_space(exec);

		for (size_t k = 0; exec[k]; k++) {
			if (exec[k] == '%') {
				exec[k] = '\0';
				break;
			}
		}
		strip_trailing_space(exec);

		if (nodisplay || hidden || !name[0] || !exec[0])
			continue;
		if (desktop_entry_exists(name))
			continue;

		snprintf(desktop_entries[desktop_entry_count].name,
				sizeof(desktop_entries[desktop_entry_count].name),
				"%s", name);
		snprintf(desktop_entries[desktop_entry_count].exec,
				sizeof(desktop_entries[desktop_entry_count].exec),
				"%s", exec);
		memset(desktop_entries[desktop_entry_count].name_lower, 0,
				sizeof(desktop_entries[desktop_entry_count].name_lower));
		for (size_t j = 0; j < strlen(desktop_entries[desktop_entry_count].name) &&
				j < sizeof(desktop_entries[desktop_entry_count].name_lower) - 1; j++) {
			desktop_entries[desktop_entry_count].name_lower[j] =
				(char)tolower((unsigned char)desktop_entries[desktop_entry_count].name[j]);
		}
		desktop_entries[desktop_entry_count].prefers_dgpu = prefers_dgpu;
		desktop_entry_count++;
	}
	closedir(d);
}

static void
load_desktop_dir(const char *dir)
{
	load_desktop_dir_rec(dir, 0);
}

static void
ensure_desktop_entries_loaded(void)
{
	char appdirs[128][PATH_MAX];
	int appdir_count = 0;
	const char *home = getenv("HOME");
	const char *user = getenv("USER");
	const char *xdg_data_home = getenv("XDG_DATA_HOME");
	const char *defaults[] = {
		"/usr/share/applications",
		"/usr/local/share/applications",
		"/var/lib/flatpak/exports/share/applications",
		"/opt/share/applications",
		"/run/current-system/sw/share/applications",
		"/nix/var/nix/profiles/system/sw/share/applications",
		"/nix/profile/share/applications",
		"/nix/var/nix/profiles/default/share/applications",
		NULL
	};
	char buf[PATH_MAX];
	char xdg_buf[4096] = {0};
	char *saveptr = NULL;
	const char *xdg_data_dirs;

	if (desktop_entries_loaded)
		return;

	memset(appdirs, 0, sizeof(appdirs));

	for (size_t i = 0; defaults[i]; i++) {
		if (appdir_count >= (int)LENGTH(appdirs))
			break;
		if (appdir_exists(appdirs, appdir_count, defaults[i]))
			continue;
		snprintf(appdirs[appdir_count++], sizeof(appdirs[0]), "%s", defaults[i]);
	}

	if (xdg_data_home && *xdg_data_home) {
		if (appdir_count < (int)LENGTH(appdirs) &&
				snprintf(buf, sizeof(buf), "%s/applications", xdg_data_home) < (int)sizeof(buf) &&
				!appdir_exists(appdirs, appdir_count, buf))
			snprintf(appdirs[appdir_count++], sizeof(appdirs[0]), "%s", buf);
	}

	if (home) {
		if (appdir_count < (int)LENGTH(appdirs) &&
				snprintf(buf, sizeof(buf), "%s/.local/share/applications", home) < (int)sizeof(buf) &&
				!appdir_exists(appdirs, appdir_count, buf))
			snprintf(appdirs[appdir_count++], sizeof(appdirs[0]), "%s", buf);
		if (appdir_count < (int)LENGTH(appdirs) &&
				snprintf(buf, sizeof(buf), "%s/.local/share/flatpak/exports/share/applications", home) < (int)sizeof(buf) &&
				!appdir_exists(appdirs, appdir_count, buf))
			snprintf(appdirs[appdir_count++], sizeof(appdirs[0]), "%s", buf);
		if (appdir_count < (int)LENGTH(appdirs) &&
				snprintf(buf, sizeof(buf), "%s/.nix-profile/share/applications", home) < (int)sizeof(buf) &&
				!appdir_exists(appdirs, appdir_count, buf))
			snprintf(appdirs[appdir_count++], sizeof(appdirs[0]), "%s", buf);
		if (appdir_count < (int)LENGTH(appdirs) &&
				snprintf(buf, sizeof(buf), "%s/.local/state/nix/profiles/profile/share/applications", home) < (int)sizeof(buf) &&
				!appdir_exists(appdirs, appdir_count, buf))
			snprintf(appdirs[appdir_count++], sizeof(appdirs[0]), "%s", buf);
		if (appdir_count < (int)LENGTH(appdirs) &&
				snprintf(buf, sizeof(buf), "%s/.local/state/nix/profiles/default/share/applications", home) < (int)sizeof(buf) &&
				!appdir_exists(appdirs, appdir_count, buf))
			snprintf(appdirs[appdir_count++], sizeof(appdirs[0]), "%s", buf);
		if (appdir_count < (int)LENGTH(appdirs) &&
				snprintf(buf, sizeof(buf), "%s/.local/state/nix/profiles/home-manager/share/applications", home) < (int)sizeof(buf) &&
				!appdir_exists(appdirs, appdir_count, buf))
			snprintf(appdirs[appdir_count++], sizeof(appdirs[0]), "%s", buf);
	}

	if (user && appdir_count < (int)LENGTH(appdirs)) {
		if (snprintf(buf, sizeof(buf), "/etc/profiles/per-user/%s/share/applications", user) < (int)sizeof(buf) &&
				!appdir_exists(appdirs, appdir_count, buf))
			snprintf(appdirs[appdir_count++], sizeof(appdirs[0]), "%s", buf);
		if (appdir_count < (int)LENGTH(appdirs) &&
				snprintf(buf, sizeof(buf), "/nix/var/nix/profiles/per-user/%s/profile/share/applications", user) < (int)sizeof(buf) &&
				!appdir_exists(appdirs, appdir_count, buf))
			snprintf(appdirs[appdir_count++], sizeof(appdirs[0]), "%s", buf);
		if (appdir_count < (int)LENGTH(appdirs) &&
				snprintf(buf, sizeof(buf), "/nix/var/nix/profiles/per-user/%s/home-manager/share/applications", user) < (int)sizeof(buf) &&
				!appdir_exists(appdirs, appdir_count, buf))
			snprintf(appdirs[appdir_count++], sizeof(appdirs[0]), "%s", buf);
		if (appdir_count < (int)LENGTH(appdirs) &&
				snprintf(buf, sizeof(buf), "/nix/var/nix/profiles/per-user/%s/sw/share/applications", user) < (int)sizeof(buf) &&
				!appdir_exists(appdirs, appdir_count, buf))
			snprintf(appdirs[appdir_count++], sizeof(appdirs[0]), "%s", buf);
	}

	xdg_data_dirs = getenv("XDG_DATA_DIRS");
	if (!xdg_data_dirs || !*xdg_data_dirs)
		xdg_data_dirs = "/usr/local/share:/usr/share";
	snprintf(xdg_buf, sizeof(xdg_buf), "%s", xdg_data_dirs);
	for (char *tok = strtok_r(xdg_buf, ":", &saveptr); tok; tok = strtok_r(NULL, ":", &saveptr)) {
		if (!*tok || appdir_count >= (int)LENGTH(appdirs))
			continue;
		if (snprintf(buf, sizeof(buf), "%s/applications", tok) >= (int)sizeof(buf))
			continue;
		if (appdir_exists(appdirs, appdir_count, buf))
			continue;
		snprintf(appdirs[appdir_count++], sizeof(appdirs[0]), "%s", buf);
		if (appdir_count >= (int)LENGTH(appdirs))
			break;
	}

	for (int i = 0; i < appdir_count && desktop_entry_count < (int)LENGTH(desktop_entries); i++)
		load_desktop_dir(appdirs[i]);

	desktop_entries_loaded = 1;
}

static void
modal_update_results(Monitor *m)
{
	ModalOverlay *mo;
	int active;

	if (!m)
		return;
	mo = &m->modal;
	if (mo->active_idx < 0 || mo->active_idx > 2)
		mo->active_idx = 0;
	active = mo->active_idx;

	if (active != 1 && mo->file_search_pid > 0)
		modal_file_search_stop(m);
	if (active != 2 && mo->git_search_pid > 0)
		modal_git_search_stop(m);

	if (active == 1) {
		if (mo->search_len[1] < modal_file_search_minlen) {
			modal_file_search_stop(m);
			modal_file_search_clear_results(m);
			mo->file_search_last[0] = '\0';
			/* Cancel any pending debounce timer */
			if (mo->file_search_timer)
				wl_event_source_timer_update(mo->file_search_timer, 0);
			return;
		}
		/* Search is started by render_timer_cb, not here */
		if (mo->file_search_pid <= 0 && mo->result_count[1] == 0 &&
		    mo->search_len[1] >= modal_file_search_minlen &&
		    strncmp(mo->search[1], mo->file_search_last, sizeof(mo->file_search_last)) != 0) {
			/* Start search if not running and query changed */
			modal_file_search_stop(m);
			modal_file_search_start(m);
		}
		if (mo->result_count[1] > 0) {
			if (mo->selected[1] < 0)
				mo->selected[1] = 0;
			modal_ensure_selection_visible(m);
		} else {
			mo->selected[1] = -1;
			mo->scroll[1] = 0;
		}
		return;
	}

	if (active == 2) {
		/* Git-projects: Check if search query changed */
		char current_query[256] = {0};
		int qlen = mo->search_len[2];
		if (qlen > (int)sizeof(current_query) - 1)
			qlen = (int)sizeof(current_query) - 1;
		if (qlen > 0)
			memcpy(current_query, mo->search[2], (size_t)qlen);
		current_query[qlen] = '\0';

		/* Restart search if query changed or not started yet */
		if (mo->git_search_pid <= 0 &&
		    (!mo->git_search_done || strcmp(current_query, mo->git_search_last) != 0)) {
			mo->git_search_done = 0;
			modal_git_search_start(m);
		}
		if (mo->result_count[2] > 0) {
			if (mo->selected[2] < 0)
				mo->selected[2] = 0;
			modal_ensure_selection_visible(m);
		} else {
			mo->selected[2] = -1;
			mo->scroll[2] = 0;
		}
		return;
	}

	if (active != 0) {
		mo->selected[active] = -1;
		mo->scroll[active] = 0;
		return;
	}

	{
		int prev_entry = -1;
		int order[LENGTH(desktop_entries)];
		int order_count;

		if (mo->selected[0] >= 0 && mo->selected[0] < mo->result_count[0])
			prev_entry = mo->result_entry_idx[0][mo->selected[0]];

		mo->result_count[0] = 0;
		for (int i = 0; i < (int)LENGTH(mo->results[0]); i++)
			mo->results[0][i][0] = '\0';
		for (int i = 0; i < (int)LENGTH(mo->result_entry_idx[0]); i++)
			mo->result_entry_idx[0][i] = -1;

		ensure_desktop_entries_loaded();
		order_count = desktop_entry_count;
		if (order_count > (int)LENGTH(order))
			order_count = (int)LENGTH(order);
		for (int i = 0; i < order_count; i++)
			order[i] = i;
		qsort(order, order_count, sizeof(order[0]), desktop_entry_cmp_used);

		if (mo->search_len[0] <= 0) {
			for (int i = 0; i < order_count && mo->result_count[0] < (int)LENGTH(mo->results[0]); i++) {
				int idx = order[i];
				snprintf(mo->results[0][mo->result_count[0]],
						sizeof(mo->results[0][mo->result_count[0]]),
						"%s", desktop_entries[idx].name);
				mo->result_entry_idx[0][mo->result_count[0]] = idx;
				mo->result_count[0]++;
			}
		} else {
			char needle[256] = {0};
			int nlen = mo->search_len[0];
			if (nlen >= (int)sizeof(needle))
				nlen = (int)sizeof(needle) - 1;
			for (int i = 0; i < nlen; i++)
				needle[i] = (char)tolower((unsigned char)mo->search[0][i]);
			needle[nlen] = '\0';

			/* exact matches first */
			for (int i = 0; i < order_count && mo->result_count[0] < (int)LENGTH(mo->results[0]); i++) {
				int idx = order[i];
				if (strcmp(desktop_entries[idx].name_lower, needle) == 0) {
					snprintf(mo->results[0][mo->result_count[0]],
							sizeof(mo->results[0][mo->result_count[0]]),
							"%s", desktop_entries[idx].name);
					mo->result_entry_idx[0][mo->result_count[0]] = idx;
					mo->result_count[0]++;
				}
			}
			/* then prefix matches */
			for (int i = 0; i < order_count && mo->result_count[0] < (int)LENGTH(mo->results[0]); i++) {
				int idx = order[i];
				if (strncmp(desktop_entries[idx].name_lower, needle, (size_t)nlen) == 0 &&
						strcmp(desktop_entries[idx].name_lower, needle) != 0) {
					snprintf(mo->results[0][mo->result_count[0]],
							sizeof(mo->results[0][mo->result_count[0]]),
							"%s", desktop_entries[idx].name);
					mo->result_entry_idx[0][mo->result_count[0]] = idx;
					mo->result_count[0]++;
				}
			}
			/* finally substring matches */
			for (int i = 0; i < order_count && mo->result_count[0] < (int)LENGTH(mo->results[0]); i++) {
				int idx = order[i];
				if (strstr(desktop_entries[idx].name_lower, needle) &&
						strncmp(desktop_entries[idx].name_lower, needle, (size_t)nlen) != 0) {
					snprintf(mo->results[0][mo->result_count[0]],
							sizeof(mo->results[0][mo->result_count[0]]),
							"%s", desktop_entries[idx].name);
					mo->result_entry_idx[0][mo->result_count[0]] = idx;
					mo->result_count[0]++;
				}
			}
		}

		mo->selected[0] = -1;
		if (mo->result_count[0] > 0) {
			int found_prev = 0;
			if (prev_entry >= 0) {
				for (int i = 0; i < mo->result_count[0]; i++) {
					if (mo->result_entry_idx[0][i] == prev_entry) {
						mo->selected[0] = i;
						found_prev = 1;
						break;
					}
				}
			}
			if (!found_prev) {
				mo->selected[0] = 0;
				mo->scroll[0] = 0;
			}
		}
	}

	if (mo->result_count[0] > 0)
		modal_ensure_selection_visible(m);
	else {
		mo->selected[0] = -1;
		mo->scroll[0] = 0;
	}
}

static void
modal_prewarm(Monitor *m)
{
	int prev_idx;

	if (!m || !m->modal.tree || m->modal.visible)
		return;

	ensure_desktop_entries_loaded();

	prev_idx = m->modal.active_idx;
	m->modal.active_idx = 0;
	m->modal.search[0][0] = '\0';
	m->modal.search_len[0] = 0;
	modal_update_results(m);
	m->modal.active_idx = prev_idx;
	m->modal.selected[0] = -1;
	m->modal.scroll[0] = 0;
}

/* Fast update of just the search field text (avoids full re-render) */
static void
modal_render_search_field(Monitor *m)
{
	ModalOverlay *mo;
	int btn_h, field_h, line_h, pad;
	struct wlr_scene_node *node, *tmp;
	const char *text;
	const char *to_draw;

	if (!m || !m->modal.tree)
		return;
	mo = &m->modal;
	if (!mo->visible || mo->width <= 0 || mo->height <= 0)
		return;

	/* Check if search text actually changed */
	if (strcmp(mo->search[mo->active_idx], mo->search_rendered[mo->active_idx]) == 0)
		return;

	/* Destroy and recreate only the search field tree */
	if (mo->search_field_tree) {
		wl_list_for_each_safe(node, tmp, &mo->search_field_tree->children, link)
			wlr_scene_node_destroy(node);
	} else {
		mo->search_field_tree = wlr_scene_tree_create(mo->tree);
		if (!mo->search_field_tree)
			return;
	}

	modal_layout_metrics(&btn_h, &field_h, &line_h, &pad);

	text = mo->search[mo->active_idx];
	to_draw = (text && *text) ? text : "Type to search...";

	{
		int field_x = pad;
		int field_y = btn_h + pad;
		int field_w = mo->width - pad * 2;
		int field_h_use = field_h > 20 ? field_h : 20;
		StatusModule mod = {0};
		int text_w, text_x;

		if (field_w < 20) field_w = 20;
		wlr_scene_node_set_position(&mo->search_field_tree->node, 0, field_y);
		mod.tree = mo->search_field_tree;
		/* Center text */
		text_w = status_text_width(to_draw);
		text_x = field_x + (field_w - text_w) / 2;
		if (text_x < field_x + 6)
			text_x = field_x + 6;
		tray_render_label(&mod, to_draw, text_x, field_h_use, statusbar_fg);
	}

	snprintf(mo->search_rendered[mo->active_idx], sizeof(mo->search_rendered[0]),
			"%s", mo->search[mo->active_idx]);
}

/* Timer callback - updates and renders after typing stops (300ms) */
static int
modal_render_timer_cb(void *data)
{
	Monitor *m = data;
	ModalOverlay *mo;
	if (!m || !m->modal.visible)
		return 0;
	mo = &m->modal;

	if (mo->render_pending) {
		mo->render_pending = 0;
		/* For file search: start search directly with current text */
		if (mo->active_idx == 1 && mo->search_len[1] >= modal_file_search_minlen) {
			modal_file_search_stop(m);
			modal_file_search_start(m);
			/* Results will trigger render via modal_file_search_event */
		} else {
			/* Non-file-search: render immediately */
			modal_update_results(m);
			modal_render(m);
		}
	}
	return 0;
}

/* Schedule delayed full render (resets on each keystroke) */
static void
modal_schedule_render(Monitor *m)
{
	ModalOverlay *mo;

	if (!m)
		return;
	mo = &m->modal;

	mo->render_pending = 1;

	/* Create timer if needed */
	if (!mo->render_timer) {
		mo->render_timer = wl_event_loop_add_timer(event_loop, modal_render_timer_cb, m);
	}

	/* Reset timer to 300ms - only fires after typing stops */
	if (mo->render_timer)
		wl_event_source_timer_update(mo->render_timer, 300);
}

static void
modal_render(Monitor *m)
{
	static const char *labels[] = {
		"App Launcher", "File Search", "Git-projects"
	};
	ModalOverlay *mo;
	int btn_h, btn_w, last_w, field_h, line_h, pad;
	struct wlr_scene_node *node, *tmp;

	if (!m || !m->modal.tree)
		return;

	mo = &m->modal;
	if (!mo->visible || mo->width <= 0 || mo->height <= 0)
		return;

	modal_layout_metrics(&btn_h, &field_h, &line_h, &pad);
	btn_w = mo->width / 3;
	if (btn_w <= 0)
		btn_w = mo->width;
	last_w = mo->width - btn_w * 2;
	if (last_w < btn_w)
		last_w = btn_w;
	if (mo->active_idx < 0 || mo->active_idx > 2)
		mo->active_idx = 0;
	/* NOTE: modal_update_results is called by keypress, not here */

	/* clear existing non-bg nodes */
	wl_list_for_each_safe(node, tmp, &mo->tree->children, link) {
		if (mo->bg && node == &mo->bg->node)
			continue;
		wlr_scene_node_destroy(node);
	}
	/* Reset cached trees since they were destroyed above */
	mo->search_field_tree = NULL;
	mo->results_tree = NULL;
	mo->row_highlight_count = 0;
	for (int i = 0; i < 3; i++)
		mo->search_rendered[i][0] = '\0';

	/* redraw background */
	if (mo->bg) {
		wl_list_for_each_safe(node, tmp, &mo->bg->children, link)
			wlr_scene_node_destroy(node);
		drawrect(mo->bg, 0, 0, mo->width, mo->height, statusbar_popup_bg);
		/* 1px black border */
		if (mo->width > 0 && mo->height > 0) {
			const float border[4] = {0.0f, 0.0f, 0.0f, 1.0f};
			drawrect(mo->bg, 0, 0, mo->width, 1, border); /* top */
			drawrect(mo->bg, 0, mo->height - 1, mo->width, 1, border); /* bottom */
			drawrect(mo->bg, 0, 0, 1, mo->height, border); /* left */
			if (mo->width > 1)
				drawrect(mo->bg, mo->width - 1, 0, 1, mo->height, border); /* right */
		}
	}

	for (int i = 0; i < 3; i++) {
		int x = i * btn_w;
		int w = (i == 2) ? last_w : btn_w;
		const float *col = (mo->active_idx == i) ? statusbar_tag_active_bg : statusbar_tag_bg;
		struct wlr_scene_tree *btn = wlr_scene_tree_create(mo->tree);
		StatusModule mod = {0};
		int text_w;
		int text_x;

		if (btn) {
			wlr_scene_node_set_position(&btn->node, x, 0);
			drawrect(btn, 0, 0, w, btn_h, col);
			mod.tree = btn;
			text_w = status_text_width(labels[i]);
			text_x = (w - text_w) / 2;
			if (text_x < 4)
				text_x = 4;
			tray_render_label(&mod, labels[i], text_x, btn_h, statusbar_fg);
		}
	}

	/* search field */
	{
		int field_x = pad;
		int field_y = btn_h + pad;
		int field_w = mo->width - pad * 2;
		const float field_bg[4] = {0.1f, 0.1f, 0.1f, 0.5f};
		const float border[4] = {0.0f, 0.0f, 0.0f, 1.0f};
		const char *text = mo->search[mo->active_idx];
		const char *to_draw = (text && *text) ? text : "Type to search...";
		struct wlr_scene_tree *row;
		StatusModule mod = {0};
		int text_x;

		if (field_w < 20)
			field_w = 20;
		if (field_h < 20)
			field_h = 20;

		if (mo->bg) {
			drawrect(mo->bg, field_x, field_y, field_w, field_h, field_bg);
			drawrect(mo->bg, field_x, field_y, field_w, 1, border);
			drawrect(mo->bg, field_x, field_y + field_h - 1, field_w, 1, border);
			drawrect(mo->bg, field_x, field_y, 1, field_h, border);
			drawrect(mo->bg, field_x + field_w - 1, field_y, 1, field_h, border);
		}

		/* Use search_field_tree so it's consistent with modal_render_search_field */
		if (!mo->search_field_tree)
			mo->search_field_tree = wlr_scene_tree_create(mo->tree);
		if (mo->search_field_tree) {
			int text_w = status_text_width(to_draw);
			wlr_scene_node_set_position(&mo->search_field_tree->node, 0, field_y);
			mod.tree = mo->search_field_tree;
			/* Center text */
			text_x = field_x + (field_w - text_w) / 2;
			if (text_x < field_x + 6)
				text_x = field_x + 6;
			tray_render_label(&mod, to_draw, text_x, field_h, statusbar_fg);
			/* Mark as rendered */
			snprintf(mo->search_rendered[mo->active_idx], sizeof(mo->search_rendered[0]),
					"%s", mo->search[mo->active_idx]);
		}
	}

	/* results list - use the dedicated function */
	modal_render_results(m);

	/* Hint text at bottom for file search */
	if (mo->active_idx == 1) {
		struct wlr_scene_tree *hint = wlr_scene_tree_create(mo->tree);
		if (hint) {
			StatusModule mod = {0};
			const char *hint_text = "Super + E to open all in Thunar";
			int hint_h = 20;
			int hint_y = mo->height - hint_h - 4;
			int text_w = status_text_width(hint_text);
			int text_x = (mo->width - text_w) / 2;
			const float hint_fg[4] = {0.6f, 0.6f, 0.6f, 1.0f};

			wlr_scene_node_set_position(&hint->node, 0, hint_y);
			mod.tree = hint;
			/* Small background bar */
			drawrect(hint, 0, 0, mo->width, hint_h, statusbar_popup_bg);
			tray_render_label(&mod, hint_text, text_x, hint_h, hint_fg);
		}
	}
}

/* Fast results-only render for navigation - just updates the results area */
static void
modal_render_results(Monitor *m)
{
	ModalOverlay *mo;
	int btn_h, field_h, line_h, pad;
	int max_lines, start, max_start;
	int col_name_w = 0, col_path_w = 0, col_gap = 12;
	int line_y;
	int rendered_count = 0;

	if (!m || !m->modal.tree)
		return;
	mo = &m->modal;
	if (!mo->visible || mo->width <= 0 || mo->height <= 0)
		return;
	if (mo->active_idx < 0 || mo->active_idx > 2)
		return;
	if (mo->result_count[mo->active_idx] <= 0)
		return;

	modal_layout_metrics(&btn_h, &field_h, &line_h, &pad);
	line_y = btn_h + pad + field_h + pad;

	/* Destroy old results tree if it exists */
	if (mo->results_tree) {
		wlr_scene_node_destroy(&mo->results_tree->node);
		mo->results_tree = NULL;
	}
	/* Clear cached highlights */
	mo->row_highlight_count = 0;
	for (int i = 0; i < MODAL_MAX_RESULTS; i++)
		mo->row_highlights[i] = NULL;

	/* Create new results tree */
	mo->results_tree = wlr_scene_tree_create(mo->tree);
	if (!mo->results_tree)
		return;
	wlr_scene_node_set_position(&mo->results_tree->node, 0, line_y);

	max_lines = modal_max_visible_lines(m);
	if (max_lines <= 0)
		return;

	start = mo->scroll[mo->active_idx];
	max_start = mo->result_count[mo->active_idx] - max_lines;
	if (max_start < 0)
		max_start = 0;
	if (start < 0)
		start = 0;
	if (start > max_start)
		start = max_start;
	mo->scroll[mo->active_idx] = start;
	mo->last_scroll = start;
	mo->last_selected = mo->selected[mo->active_idx];

	if (mo->active_idx == 1) {
		int total_w = mo->width - pad * 2 - 4;
		int name_min = 80;
		int path_min = 120;
		col_name_w = total_w / 2;
		if (col_name_w < name_min)
			col_name_w = name_min;
		col_path_w = total_w - col_name_w - col_gap;
		if (col_path_w < path_min) {
			col_path_w = path_min;
			col_name_w = total_w - col_gap - col_path_w;
		}
		if (col_name_w < name_min)
			col_name_w = name_min;
	}

	for (int i = 0; i < max_lines && (start + i) < mo->result_count[mo->active_idx]; i++) {
		int idx = start + i;
		struct wlr_scene_tree *row = wlr_scene_tree_create(mo->results_tree);
		struct wlr_scene_rect *highlight;
		StatusModule mod = {0};
		char text_buf[MODAL_RESULT_LEN];
		int max_px = mo->width - pad * 2 - 8;
		char name_buf[128];
		char path_buf[128];
		char short_path[128];
		const char *name = mo->file_results_name[idx];
		const char *path = mo->file_results_path[idx];
		char path_dir[PATH_MAX];
		int path_w = 0;
		int path_x = 0;
		char *slash = NULL;
		int is_selected = (mo->selected[mo->active_idx] == idx);

		if (!row)
			continue;
		wlr_scene_node_set_position(&row->node, 0, i * line_h);
		mod.tree = row;

		/* Create highlight rect for this row - always create, toggle visibility */
		highlight = wlr_scene_rect_create(row, mo->width - pad * 2 + 4, line_h, statusbar_tag_active_bg);
		if (highlight) {
			wlr_scene_node_set_position(&highlight->node, pad - 2, 0);
			wlr_scene_node_set_enabled(&highlight->node, is_selected);
			if (rendered_count < MODAL_MAX_RESULTS)
				mo->row_highlights[rendered_count] = highlight;
		}

		if (mo->active_idx == 1) {
			if (path) {
				snprintf(path_dir, sizeof(path_dir), "%s", path);
				slash = strrchr(path_dir, '/');
				if (slash && slash != path_dir)
					*slash = '\0';
				else if (slash)
					*(slash + 1) = '\0';
			} else {
				snprintf(path_dir, sizeof(path_dir), ".");
			}
			shorten_path_display(path_dir, short_path, sizeof(short_path));
			modal_truncate_to_width(name ? name : "", name_buf, sizeof(name_buf), col_name_w);
			modal_truncate_to_width(short_path, path_buf, sizeof(path_buf), col_path_w);
			path_w = status_text_width(path_buf);
			path_x = mo->width - pad - path_w;
			if (path_x < pad + 10)
				path_x = pad + 10;
			tray_render_label(&mod, name_buf[0] ? name_buf : "--", pad, line_h, statusbar_fg);
			tray_render_label(&mod, path_buf[0] ? path_buf : "--", path_x, line_h, statusbar_fg);
		} else {
			if (max_px < 40)
				max_px = 40;
			modal_truncate_to_width(mo->results[mo->active_idx][idx],
					text_buf, sizeof(text_buf), max_px);
			if (!text_buf[0])
				snprintf(text_buf, sizeof(text_buf), "%s", mo->results[mo->active_idx][idx]);
			tray_render_label(&mod, text_buf, pad, line_h, statusbar_fg);
		}
		rendered_count++;
	}
	mo->row_highlight_count = rendered_count;
}

/* Ultra-fast selection update - just toggles highlight visibility */
static void
modal_update_selection(Monitor *m)
{
	ModalOverlay *mo;
	int start, sel, old_row, new_row;

	if (!m)
		return;
	mo = &m->modal;
	if (!mo->visible || !mo->results_tree)
		return;
	if (mo->active_idx < 0 || mo->active_idx > 2)
		return;
	if (mo->row_highlight_count <= 0)
		return;

	start = mo->scroll[mo->active_idx];
	sel = mo->selected[mo->active_idx];

	/* If scroll changed, we need full re-render */
	if (start != mo->last_scroll) {
		modal_render_results(m);
		return;
	}

	/* Calculate old and new row indices within visible area */
	old_row = mo->last_selected - start;
	new_row = sel - start;

	/* Hide old highlight */
	if (old_row >= 0 && old_row < mo->row_highlight_count && mo->row_highlights[old_row])
		wlr_scene_node_set_enabled(&mo->row_highlights[old_row]->node, 0);

	/* Show new highlight */
	if (new_row >= 0 && new_row < mo->row_highlight_count && mo->row_highlights[new_row])
		wlr_scene_node_set_enabled(&mo->row_highlights[new_row]->node, 1);

	mo->last_selected = sel;
}

/* ===== Nixpkgs Install Popup ===== */

static void
add_nixpkg_entry(const char *name, const char *version)
{
	int i;
	if (nixpkg_entry_count >= NIXPKGS_MAX_ENTRIES)
		return;

	snprintf(nixpkg_entries[nixpkg_entry_count].name, sizeof(nixpkg_entries[0].name),
		"%s", name);
	snprintf(nixpkg_entries[nixpkg_entry_count].version, sizeof(nixpkg_entries[0].version),
		"%s", version ? version : "");
	nixpkg_entries[nixpkg_entry_count].installed = 0; /* Will be set by load_installed_packages */

	/* Create lowercase version for case-insensitive search */
	for (i = 0; nixpkg_entries[nixpkg_entry_count].name[i] && i < (int)sizeof(nixpkg_entries[0].name_lower) - 1; i++)
		nixpkg_entries[nixpkg_entry_count].name_lower[i] = tolower((unsigned char)nixpkg_entries[nixpkg_entry_count].name[i]);
	nixpkg_entries[nixpkg_entry_count].name_lower[i] = '\0';
	nixpkg_entry_count++;
}

static void
load_nixlypkgs_cache(void)
{
	/* Load nixlypkgs packages from ~/dev_nixly/nixlypkgs/pkgs/ */
	char pkgs_dir[PATH_MAX];
	char *home;
	DIR *dir;
	struct dirent *entry;

	home = getenv("HOME");
	if (!home)
		return;

	snprintf(pkgs_dir, sizeof(pkgs_dir), "%s/dev_nixly/nixlypkgs/pkgs", home);
	dir = opendir(pkgs_dir);
	if (!dir)
		return;

	while ((entry = readdir(dir)) != NULL) {
		if (entry->d_name[0] == '.')
			continue;
		if (entry->d_type == DT_DIR) {
			char name[140];
			snprintf(name, sizeof(name), "nixlypkgs.%s", entry->d_name);
			add_nixpkg_entry(name, "local");
		}
	}
	closedir(dir);
	wlr_log(WLR_INFO, "Added nixlypkgs entries, total now %d", nixpkg_entry_count);
}

static void
load_nixpkgs_cache(void)
{
	FILE *f;
	char line[512];
	char *home;
	char *tab;

	if (nixpkg_entries_loaded)
		return;

	/* Build cache path from flake.nix nixpkgs-stable input */
	home = getenv("HOME");
	if (!home)
		home = "/tmp";
	snprintf(nixpkgs_cache_path, sizeof(nixpkgs_cache_path),
		"%s/.cache/nixlytile-nixpkgs-stable.txt", home);

	f = fopen(nixpkgs_cache_path, "r");
	if (!f) {
		wlr_log(WLR_INFO, "Nixpkgs cache not found at %s, generating...", nixpkgs_cache_path);
		/* Generate cache in background using nix-env -qa with version */
		pid_t pid = fork();
		if (pid == 0) {
			/* Child: generate cache with versions (format: name<TAB>version)
			 * Use nixpkgs-stable from ~/.nixlyos flake
			 * Filter to only show top-level packages (first column has no dots)
			 * This filters out internal packages like pythonPackages.*, haskellPackages.*, etc. */
			char cmd[2048];
			snprintf(cmd, sizeof(cmd),
				"nix eval --raw ~/.nixlyos#nixpkgs-stable.outPath 2>/dev/null | "
				"xargs -I{} nix-env -qaP -f {} 2>/dev/null | "
				"awk 'index($1, \".\") == 0 {print $1\"\\t\"$2}' | "
				"sed 's/\\t.*-\\([0-9]\\)/\\t\\1/' > '%s'",
				nixpkgs_cache_path);
			execl("/bin/sh", "sh", "-c", cmd, NULL);
			_exit(1);
		}
		nixpkg_entries_loaded = 1; /* Mark as loaded (empty) to avoid re-triggering */
		/* Still load nixlypkgs even if nixpkgs cache doesn't exist */
		load_nixlypkgs_cache();
		return;
	}

	nixpkg_entry_count = 0;
	while (fgets(line, sizeof(line), f) && nixpkg_entry_count < NIXPKGS_MAX_ENTRIES) {
		/* Remove newline */
		size_t len = strlen(line);
		if (len > 0 && line[len - 1] == '\n')
			line[len - 1] = '\0';
		if (line[0] == '\0')
			continue;

		/* Parse tab-separated format: name<TAB>version */
		tab = strchr(line, '\t');
		if (tab) {
			*tab = '\0';
			add_nixpkg_entry(line, tab + 1);
		} else {
			/* Old format without version */
			add_nixpkg_entry(line, NULL);
		}
	}
	fclose(f);

	/* Also load nixlypkgs packages */
	load_nixlypkgs_cache();

	nixpkg_entries_loaded = 1;
	wlr_log(WLR_INFO, "Loaded %d nixpkgs entries from cache", nixpkg_entry_count);

	/* Load installed packages status */
	load_installed_packages();
}

static void
load_installed_packages(void)
{
	char packages_path[PATH_MAX];
	char *home;
	FILE *f;
	char *content = NULL;
	long file_size;
	int i, count = 0;

	home = getenv("HOME");
	if (!home)
		return;

	snprintf(packages_path, sizeof(packages_path),
		"%s/.nixlyos/modules/core/packages.nix", home);

	f = fopen(packages_path, "r");
	if (!f)
		return;

	fseek(f, 0, SEEK_END);
	file_size = ftell(f);
	fseek(f, 0, SEEK_SET);

	content = malloc(file_size + 1);
	if (!content) {
		fclose(f);
		return;
	}

	if (fread(content, 1, file_size, f) != (size_t)file_size) {
		fclose(f);
		free(content);
		return;
	}
	content[file_size] = '\0';
	fclose(f);

	/* Mark packages as installed if they appear in packages.nix */
	for (i = 0; i < nixpkg_entry_count; i++) {
		const char *name = nixpkg_entries[i].name;
		/* For nixlypkgs.foo entries, check for "foo" */
		if (strncmp(name, "nixlypkgs.", 10) == 0)
			name = name + 10;

		/* Simple check: look for the package name in the file */
		if (strstr(content, name)) {
			nixpkg_entries[i].installed = 1;
			count++;
		} else {
			nixpkg_entries[i].installed = 0;
		}
	}

	free(content);
	wlr_log(WLR_INFO, "Marked %d packages as installed", count);
}

static int
ensure_nixpkg_ok_icon(int height)
{
	GdkPixbuf *pixbuf = NULL;
	char icon_path[PATH_MAX];

	if (nixpkg_ok_icon_buf && nixpkg_ok_icon_height == height)
		return 0;

	/* Drop old buffer */
	if (nixpkg_ok_icon_buf) {
		wlr_buffer_drop(nixpkg_ok_icon_buf);
		nixpkg_ok_icon_buf = NULL;
		nixpkg_ok_icon_height = 0;
	}

	if (resolve_asset_path("images/svg/ok.svg", icon_path, sizeof(icon_path)) != 0)
		return -1;

	if (tray_load_svg_pixbuf(icon_path, height, &pixbuf) != 0)
		return -1;

	{
		int w = gdk_pixbuf_get_width(pixbuf);
		int h = gdk_pixbuf_get_height(pixbuf);
		int stride = gdk_pixbuf_get_rowstride(pixbuf);
		int n_chan = gdk_pixbuf_get_n_channels(pixbuf);
		guchar *pix = gdk_pixbuf_get_pixels(pixbuf);
		uint32_t *argb = malloc(w * h * 4);

		if (!argb) {
			g_object_unref(pixbuf);
			return -1;
		}

		for (int y = 0; y < h; y++) {
			guchar *row = pix + y * stride;
			for (int x = 0; x < w; x++) {
				guchar r = row[x * n_chan + 0];
				guchar g = row[x * n_chan + 1];
				guchar b = row[x * n_chan + 2];
				guchar a = (n_chan == 4) ? row[x * n_chan + 3] : 255;
				argb[y * w + x] = ((uint32_t)a << 24) | ((uint32_t)r << 16) |
				                  ((uint32_t)g << 8) | (uint32_t)b;
			}
		}

		nixpkg_ok_icon_buf = statusbar_buffer_from_argb32_raw(argb, w, h);
		free(argb);
		g_object_unref(pixbuf);

		if (!nixpkg_ok_icon_buf)
			return -1;

		nixpkg_ok_icon_height = height;
	}

	return 0;
}

static void
ensure_nixpkgs_cache_loaded(void)
{
	if (!nixpkg_entries_loaded)
		load_nixpkgs_cache();
}

static Monitor *
nixpkgs_visible_monitor(void)
{
	Monitor *m;
	wl_list_for_each(m, &mons, link) {
		if (m->nixpkgs.visible)
			return m;
	}
	return NULL;
}

static void
nixpkgs_hide(Monitor *m)
{
	if (!m || !m->nixpkgs.tree)
		return;
	m->nixpkgs.visible = 0;
	wlr_scene_node_set_enabled(&m->nixpkgs.tree->node, 0);
}

static void
nixpkgs_hide_all(void)
{
	Monitor *m;
	wl_list_for_each(m, &mons, link)
		nixpkgs_hide(m);
}

static void
nixpkgs_update_results(Monitor *m)
{
	NixpkgsOverlay *no;
	char needle[256];
	int i, k, count;

	if (!m)
		return;
	no = &m->nixpkgs;

	ensure_nixpkgs_cache_loaded();

	/* Convert search to lowercase */
	for (i = 0; i < no->search_len && i < (int)sizeof(needle) - 1; i++)
		needle[i] = tolower((unsigned char)no->search[i]);
	needle[i] = '\0';

	count = 0;
	if (needle[0] == '\0') {
		/* Empty search: show first N packages */
		for (i = 0; i < nixpkg_entry_count && count < MODAL_MAX_RESULTS; i++)
			no->result_indices[count++] = i;
	} else {
		/* Search: prefix match first, then substring */
		/* Pass 1: prefix matches */
		for (i = 0; i < nixpkg_entry_count && count < MODAL_MAX_RESULTS; i++) {
			if (strncmp(nixpkg_entries[i].name_lower, needle, strlen(needle)) == 0)
				no->result_indices[count++] = i;
		}
		/* Pass 2: substring matches (not prefix) */
		for (i = 0; i < nixpkg_entry_count && count < MODAL_MAX_RESULTS; i++) {
			if (strncmp(nixpkg_entries[i].name_lower, needle, strlen(needle)) != 0 &&
			    strstr(nixpkg_entries[i].name_lower, needle))
				no->result_indices[count++] = i;
		}
	}
	no->result_count = count;

	/* Reset selection if out of range */
	if (no->selected >= count)
		no->selected = count > 0 ? count - 1 : -1;
	if (no->selected < 0 && count > 0)
		no->selected = 0;
}

/* Get layout metrics for nixpkgs popup (simplified - no tabs) */
static void
nixpkgs_layout_metrics(int *field_h, int *line_h, int *pad)
{
	*field_h = 36;
	*line_h = 24;
	*pad = 10;
}

static int
nixpkgs_max_visible_lines(Monitor *m)
{
	NixpkgsOverlay *no;
	int field_h, line_h, pad;
	int usable;
	int hint_h = 20 + 4; /* hint height + margin */
	int title_h = 32;

	if (!m)
		return 0;
	no = &m->nixpkgs;

	nixpkgs_layout_metrics(&field_h, &line_h, &pad);
	/* title + pad + field + pad + results + hint area */
	usable = no->height - title_h - pad - field_h - pad - hint_h - pad;
	if (usable <= 0)
		return 0;
	return usable / line_h;
}

static void
nixpkgs_ensure_selection_visible(Monitor *m)
{
	NixpkgsOverlay *no;
	int max_lines, sel;

	if (!m)
		return;
	no = &m->nixpkgs;
	sel = no->selected;
	if (sel < 0)
		return;

	max_lines = nixpkgs_max_visible_lines(m);
	if (max_lines <= 0)
		return;

	if (sel < no->scroll)
		no->scroll = sel;
	else if (sel >= no->scroll + max_lines)
		no->scroll = sel - max_lines + 1;
}

static void
nixpkgs_render(Monitor *m)
{
	NixpkgsOverlay *no;
	int field_h, line_h, pad;
	struct wlr_scene_node *node, *tmp;

	if (!m || !m->nixpkgs.tree)
		return;

	no = &m->nixpkgs;
	if (!no->visible || no->width <= 0 || no->height <= 0)
		return;

	nixpkgs_layout_metrics(&field_h, &line_h, &pad);

	/* Clear existing non-bg nodes */
	wl_list_for_each_safe(node, tmp, &no->tree->children, link) {
		if (no->bg && node == &no->bg->node)
			continue;
		wlr_scene_node_destroy(node);
	}
	/* Reset cached trees */
	no->search_field_tree = NULL;
	no->results_tree = NULL;
	no->row_highlight_count = 0;
	no->search_rendered[0] = '\0';

	/* Redraw background */
	if (no->bg) {
		wl_list_for_each_safe(node, tmp, &no->bg->children, link)
			wlr_scene_node_destroy(node);
		drawrect(no->bg, 0, 0, no->width, no->height, statusbar_popup_bg);
		/* 1px black border */
		if (no->width > 0 && no->height > 0) {
			const float border[4] = {0.0f, 0.0f, 0.0f, 1.0f};
			drawrect(no->bg, 0, 0, no->width, 1, border); /* top */
			drawrect(no->bg, 0, no->height - 1, no->width, 1, border); /* bottom */
			drawrect(no->bg, 0, 0, 1, no->height, border); /* left */
			if (no->width > 1)
				drawrect(no->bg, no->width - 1, 0, 1, no->height, border); /* right */
		}
	}

	/* Title */
	{
		struct wlr_scene_tree *title = wlr_scene_tree_create(no->tree);
		if (title) {
			StatusModule mod = {0};
			const char *title_text = "Nixpkgs Install";
			int title_h = 32;
			int text_w = status_text_width(title_text);
			int text_x = (no->width - text_w) / 2;

			wlr_scene_node_set_position(&title->node, 0, 4);
			mod.tree = title;
			drawrect(title, 0, 0, no->width, title_h, statusbar_tag_active_bg);
			tray_render_label(&mod, title_text, text_x, title_h, statusbar_fg);
		}
	}

	/* Search field */
	{
		int field_x = pad;
		int field_y = 32 + pad;
		int field_w = no->width - pad * 2;
		const float field_bg[4] = {0.1f, 0.1f, 0.1f, 0.5f};
		const float border[4] = {0.0f, 0.0f, 0.0f, 1.0f};
		const char *text = no->search;
		const char *to_draw = (text && *text) ? text : "Type to search packages...";
		StatusModule mod = {0};
		int text_w, text_x;

		if (field_w < 20)
			field_w = 20;
		if (field_h < 20)
			field_h = 20;

		if (no->bg) {
			drawrect(no->bg, field_x, field_y, field_w, field_h, field_bg);
			drawrect(no->bg, field_x, field_y, field_w, 1, border);
			drawrect(no->bg, field_x, field_y + field_h - 1, field_w, 1, border);
			drawrect(no->bg, field_x, field_y, 1, field_h, border);
			drawrect(no->bg, field_x + field_w - 1, field_y, 1, field_h, border);
		}

		if (!no->search_field_tree)
			no->search_field_tree = wlr_scene_tree_create(no->tree);
		if (no->search_field_tree) {
			wlr_scene_node_set_position(&no->search_field_tree->node, 0, field_y);
			mod.tree = no->search_field_tree;
			text_w = status_text_width(to_draw);
			text_x = field_x + (field_w - text_w) / 2;
			if (text_x < field_x + 6)
				text_x = field_x + 6;
			tray_render_label(&mod, to_draw, text_x, field_h, statusbar_fg);
			snprintf(no->search_rendered, sizeof(no->search_rendered), "%s", no->search);
		}
	}

	/* Results list */
	nixpkgs_render_results(m);

	/* Hint at bottom */
	{
		struct wlr_scene_tree *hint = wlr_scene_tree_create(no->tree);
		if (hint) {
			StatusModule mod = {0};
			const char *hint_text = "Hit enter to install package";
			int hint_h = 20;
			int hint_y = no->height - hint_h - 4;
			int text_w = status_text_width(hint_text);
			int text_x = (no->width - text_w) / 2;
			const float hint_fg[4] = {0.6f, 0.6f, 0.6f, 1.0f};

			wlr_scene_node_set_position(&hint->node, 0, hint_y);
			mod.tree = hint;
			drawrect(hint, 0, 0, no->width, hint_h, statusbar_popup_bg);
			tray_render_label(&mod, hint_text, text_x, hint_h, hint_fg);
		}
	}
}

static void
nixpkgs_render_results(Monitor *m)
{
	NixpkgsOverlay *no;
	int field_h, line_h, pad;
	int max_lines, start, max_start;
	int line_y;
	int rendered_count = 0;
	int i;

	if (!m || !m->nixpkgs.tree)
		return;
	no = &m->nixpkgs;
	if (!no->visible || no->width <= 0 || no->height <= 0)
		return;
	if (no->result_count <= 0)
		return;

	nixpkgs_layout_metrics(&field_h, &line_h, &pad);
	line_y = 32 + pad + field_h + pad; /* title + pad + field + pad */

	/* Destroy old results tree */
	if (no->results_tree) {
		wlr_scene_node_destroy(&no->results_tree->node);
		no->results_tree = NULL;
	}
	/* Clear cached highlights */
	no->row_highlight_count = 0;
	for (i = 0; i < MODAL_MAX_RESULTS; i++)
		no->row_highlights[i] = NULL;

	/* Create new results tree */
	no->results_tree = wlr_scene_tree_create(no->tree);
	if (!no->results_tree)
		return;
	wlr_scene_node_set_position(&no->results_tree->node, 0, line_y);

	max_lines = nixpkgs_max_visible_lines(m);
	if (max_lines <= 0)
		return;

	start = no->scroll;
	max_start = no->result_count - max_lines;
	if (max_start < 0)
		max_start = 0;
	if (start < 0)
		start = 0;
	if (start > max_start)
		start = max_start;
	no->scroll = start;

	for (i = start; i < no->result_count && rendered_count < max_lines; i++) {
		int idx = no->result_indices[i];
		const char *name = nixpkg_entries[idx].name;
		const char *version = nixpkg_entries[idx].version;
		int y = rendered_count * line_h;
		struct wlr_scene_tree *row;
		struct wlr_scene_rect *highlight;
		StatusModule mod = {0};
		int sel = (i == no->selected);
		const float sel_bg[4] = {0.2f, 0.4f, 0.6f, 0.8f};
		const float version_fg[4] = {0.5f, 0.5f, 0.5f, 1.0f}; /* grey for version */
		int name_w;

		row = wlr_scene_tree_create(no->results_tree);
		if (!row)
			continue;
		wlr_scene_node_set_position(&row->node, pad, y);

		/* Create highlight rect (hidden by default unless selected) */
		highlight = wlr_scene_rect_create(row, no->width - pad * 2, line_h, sel_bg);
		if (highlight) {
			wlr_scene_node_set_position(&highlight->node, 0, 0);
			wlr_scene_node_set_enabled(&highlight->node, sel);
			no->row_highlights[rendered_count] = highlight;
		}

		/* Render package name */
		mod.tree = row;
		tray_render_label(&mod, name, 4, line_h, statusbar_fg);

		/* Render version in grey parentheses if available */
		name_w = status_text_width(name);
		if (version && version[0]) {
			char ver_str[80];
			snprintf(ver_str, sizeof(ver_str), "(%s)", version);
			tray_render_label(&mod, ver_str, 4 + name_w + 8, line_h, version_fg);

			/* Show ok.svg icon if package is installed */
			if (nixpkg_entries[idx].installed) {
				int icon_h = line_h - 4;
				if (ensure_nixpkg_ok_icon(icon_h) == 0 && nixpkg_ok_icon_buf) {
					int ver_w = status_text_width(ver_str);
					int icon_x = 4 + name_w + 8 + ver_w + 6;
					int icon_y = (line_h - icon_h) / 2;
					struct wlr_scene_buffer *icon_node =
						wlr_scene_buffer_create(row, nixpkg_ok_icon_buf);
					if (icon_node)
						wlr_scene_node_set_position(&icon_node->node, icon_x, icon_y);
				}
			}
		} else if (nixpkg_entries[idx].installed) {
			/* No version but installed - show icon after name */
			int icon_h = line_h - 4;
			if (ensure_nixpkg_ok_icon(icon_h) == 0 && nixpkg_ok_icon_buf) {
				int icon_x = 4 + name_w + 8;
				int icon_y = (line_h - icon_h) / 2;
				struct wlr_scene_buffer *icon_node =
					wlr_scene_buffer_create(row, nixpkg_ok_icon_buf);
				if (icon_node)
					wlr_scene_node_set_position(&icon_node->node, icon_x, icon_y);
			}
		}

		/* Render "Source (Mod+w)" on the right side */
		{
			const char *source_text = "Source (Mod+w)";
			int source_w = status_text_width(source_text);
			int source_x = no->width - pad * 2 - source_w - 8;
			tray_render_label(&mod, source_text, source_x, line_h, version_fg);
		}

		rendered_count++;
	}
	no->row_highlight_count = rendered_count;
	no->last_scroll = start;
	no->last_selected = no->selected;
}

static void
nixpkgs_update_selection(Monitor *m)
{
	NixpkgsOverlay *no;
	int start, sel, old_row, new_row;

	if (!m)
		return;
	no = &m->nixpkgs;
	if (!no->visible || !no->results_tree)
		return;
	if (no->row_highlight_count <= 0)
		return;

	start = no->scroll;
	sel = no->selected;

	/* If scroll changed, need full re-render */
	if (start != no->last_scroll) {
		nixpkgs_render_results(m);
		return;
	}

	/* Calculate old and new row indices */
	old_row = no->last_selected - start;
	new_row = sel - start;

	/* Hide old highlight */
	if (old_row >= 0 && old_row < no->row_highlight_count && no->row_highlights[old_row])
		wlr_scene_node_set_enabled(&no->row_highlights[old_row]->node, 0);

	/* Show new highlight */
	if (new_row >= 0 && new_row < no->row_highlight_count && no->row_highlights[new_row])
		wlr_scene_node_set_enabled(&no->row_highlights[new_row]->node, 1);

	no->last_selected = sel;
}

/* Toast notification functions */
static int
toast_hide_timer(void *data)
{
	Monitor *m = data;
	if (m && m->toast_tree) {
		wlr_scene_node_set_enabled(&m->toast_tree->node, 0);
		m->toast_visible = 0;
	}
	return 0;
}

static void
toast_show(Monitor *m, const char *message, int duration_ms)
{
	struct wlr_scene_node *node, *tmp;
	int text_w, pad = 12, h = 28;
	int x, y, w;
	const float bg[4] = {0.15f, 0.15f, 0.15f, 0.95f};
	const float border[4] = {0.3f, 0.3f, 0.3f, 1.0f};
	StatusModule mod = {0};

	if (!m)
		m = selmon;
	if (!m)
		return;

	/* Create toast tree if needed */
	if (!m->toast_tree) {
		m->toast_tree = wlr_scene_tree_create(layers[LyrTop]);
		if (!m->toast_tree)
			return;
	}

	/* Clear existing content */
	wl_list_for_each_safe(node, tmp, &m->toast_tree->children, link)
		wlr_scene_node_destroy(node);

	/* Calculate size and position (top right corner) */
	text_w = status_text_width(message);
	w = text_w + pad * 2;
	x = m->m.x + m->m.width - w - 20;
	y = m->m.y + 50; /* Below status bar */

	wlr_scene_node_set_position(&m->toast_tree->node, x, y);

	/* Draw background */
	drawrect(m->toast_tree, 0, 0, w, h, bg);
	/* Draw border */
	drawrect(m->toast_tree, 0, 0, w, 1, border);
	drawrect(m->toast_tree, 0, h - 1, w, 1, border);
	drawrect(m->toast_tree, 0, 0, 1, h, border);
	drawrect(m->toast_tree, w - 1, 0, 1, h, border);

	/* Draw text */
	mod.tree = m->toast_tree;
	tray_render_label(&mod, message, pad, h, statusbar_fg);

	/* Show toast */
	wlr_scene_node_set_enabled(&m->toast_tree->node, 1);
	m->toast_visible = 1;

	/* Set up timer to hide */
	if (!m->toast_timer)
		m->toast_timer = wl_event_loop_add_timer(event_loop, toast_hide_timer, m);
	wl_event_source_timer_update(m->toast_timer, duration_ms);
}

static void
nixpkgs_open_source(Monitor *m)
{
	NixpkgsOverlay *no;
	int idx;
	const char *name;
	char url[512];
	char cmd_str[600];
	char *cmd[4] = { "sh", "-c", cmd_str, NULL };
	Arg arg;

	if (!m)
		return;
	no = &m->nixpkgs;
	if (no->selected < 0 || no->selected >= no->result_count)
		return;

	idx = no->result_indices[no->selected];
	name = nixpkg_entries[idx].name;

	/* Check if it's a nixlypkgs package */
	if (strncmp(name, "nixlypkgs.", 10) == 0) {
		/* Open local nixlypkgs package in file manager or editor */
		const char *pkg = name + 10; /* skip "nixlypkgs." prefix */
		snprintf(url, sizeof(url),
			"https://github.com/totalygeek/nixlypkgs/tree/main/pkgs/%s", pkg);
	} else {
		/* Open on GitHub nixpkgs (nixos-25.11 stable branch) */
		snprintf(url, sizeof(url),
			"https://github.com/NixOS/nixpkgs/blob/nixos-25.11/pkgs/by-name/%c%c/%s/package.nix",
			name[0], name[1] && name[1] != '\0' ? name[1] : name[0], name);
	}

	snprintf(cmd_str, sizeof(cmd_str), "xdg-open '%s'", url);
	arg.v = cmd;
	spawn(&arg);
}

static void
nixpkgs_install_selected(Monitor *m)
{
	NixpkgsOverlay *no;
	int idx;
	const char *name;
	char packages_path[PATH_MAX];
	char *home;
	FILE *f;
	char *content = NULL;
	long file_size;
	char *insert_pos;
	char *new_content;
	size_t new_size;
	const char *marker = "];"; /* End of hmPackages list */
	char pkg_name[140];

	if (!m)
		return;
	no = &m->nixpkgs;
	if (no->selected < 0 || no->selected >= no->result_count)
		return;

	idx = no->result_indices[no->selected];
	name = nixpkg_entries[idx].name;

	/* Get package name without nixlypkgs. prefix for insertion */
	if (strncmp(name, "nixlypkgs.", 10) == 0) {
		snprintf(pkg_name, sizeof(pkg_name), "%s", name + 10);
	} else {
		snprintf(pkg_name, sizeof(pkg_name), "%s", name);
	}

	/* Build path to packages.nix */
	home = getenv("HOME");
	if (!home)
		return;
	snprintf(packages_path, sizeof(packages_path),
		"%s/.nixlyos/modules/core/packages.nix", home);

	/* Read the file */
	f = fopen(packages_path, "r");
	if (!f) {
		wlr_log(WLR_ERROR, "Failed to open %s for reading", packages_path);
		return;
	}

	fseek(f, 0, SEEK_END);
	file_size = ftell(f);
	fseek(f, 0, SEEK_SET);

	content = malloc(file_size + 1);
	if (!content) {
		fclose(f);
		return;
	}

	if (fread(content, 1, file_size, f) != (size_t)file_size) {
		fclose(f);
		free(content);
		return;
	}
	content[file_size] = '\0';
	fclose(f);

	/* Check if package already exists */
	if (strstr(content, pkg_name)) {
		wlr_log(WLR_INFO, "Package %s already in packages.nix", pkg_name);
		free(content);
		nixpkgs_hide_all();
		return;
	}

	/* Find the first "];" which marks the end of hmPackages */
	insert_pos = strstr(content, marker);
	if (!insert_pos) {
		wlr_log(WLR_ERROR, "Could not find hmPackages end marker in packages.nix");
		free(content);
		return;
	}

	/* Create new content with package inserted before "];" */
	/* "    pkg_name\n  " = 4 spaces + name + newline + 2 spaces = 7 + strlen */
	new_size = file_size + strlen(pkg_name) + 10;
	new_content = malloc(new_size + 1);
	if (!new_content) {
		free(content);
		return;
	}

	/* Copy content before marker, add new package, add marker and rest */
	{
		size_t prefix_len = insert_pos - content;
		char *p = new_content;

		memcpy(p, content, prefix_len);
		p += prefix_len;

		p += sprintf(p, "    %s\n  ", pkg_name);

		strcpy(p, insert_pos);
	}

	/* Write the file back */
	f = fopen(packages_path, "w");
	if (!f) {
		wlr_log(WLR_ERROR, "Failed to open %s for writing", packages_path);
		free(content);
		free(new_content);
		return;
	}

	fputs(new_content, f);
	fclose(f);

	wlr_log(WLR_INFO, "Added %s to packages.nix", pkg_name);

	/* Mark package as installed in our cache */
	nixpkg_entries[idx].installed = 1;

	free(content);
	free(new_content);
	nixpkgs_hide_all();

	/* Show sudo popup to run nixos-rebuild boot */
	{
		char rebuild_cmd[512];
		snprintf(rebuild_cmd, sizeof(rebuild_cmd),
			"cd %s/.nixlyos && nixos-rebuild boot --flake .#nixlyos", home);
		sudo_popup_show(m, "sudo:", rebuild_cmd, pkg_name);
	}
}

static int
nixpkgs_handle_key(Monitor *m, uint32_t mods, xkb_keysym_t sym)
{
	NixpkgsOverlay *no;

	if (!m)
		return 0;
	no = &m->nixpkgs;

	if (sym == XKB_KEY_Escape) {
		nixpkgs_hide_all();
		return 1;
	}

	if (sym == XKB_KEY_BackSpace && no->search_len > 0 && mods == 0) {
		no->search_len--;
		no->search[no->search_len] = '\0';
		return 1;
	}

	if (sym == XKB_KEY_Down && no->result_count > 0) {
		int sel = no->selected;
		if (sel < 0)
			sel = 0;
		else if (sel + 1 < no->result_count)
			sel++;
		else
			sel = 0; /* wrap */
		no->selected = sel;
		nixpkgs_ensure_selection_visible(m);
		return 1;
	}

	if (sym == XKB_KEY_Up && no->result_count > 0) {
		int sel = no->selected;
		if (sel < 0)
			sel = no->result_count - 1;
		else if (sel > 0)
			sel--;
		else
			sel = no->result_count - 1; /* wrap */
		no->selected = sel;
		nixpkgs_ensure_selection_visible(m);
		return 1;
	}

	if (sym == XKB_KEY_Return || sym == XKB_KEY_KP_Enter) {
		nixpkgs_install_selected(m);
		return 1;
	}

	/* Mod+w: Open source in browser */
	if ((sym == XKB_KEY_w || sym == XKB_KEY_W) && (mods & WLR_MODIFIER_LOGO)) {
		nixpkgs_open_source(m);
		return 1;
	}

	/* Text input */
	{
		int is_altgr = (mods & WLR_MODIFIER_CTRL) && (mods & WLR_MODIFIER_ALT);
		int is_ctrl_only = (mods & WLR_MODIFIER_CTRL) && !is_altgr;
		if (sym >= 0x20 && sym <= 0x7e && !is_ctrl_only && !(mods & WLR_MODIFIER_LOGO)) {
			int len = no->search_len;
			if (len + 1 < (int)sizeof(no->search)) {
				no->search[len] = (char)sym;
				no->search[len + 1] = '\0';
				no->search_len = len + 1;
			}
			return 1;
		}
	}

	return 0;
}

static void
nixpkgs_show(const Arg *arg)
{
	Monitor *m = selmon ? selmon : xytomon(cursor->x, cursor->y);
	Monitor *vm = nixpkgs_visible_monitor();
	NixpkgsOverlay *no;
	int mw, mh, w, h, x, y;
	int min_w = 300, min_h = 200;
	int max_w = 800, max_h = 600;

	(void)arg;

	if (!m || !m->nixpkgs.tree)
		return;

	/* Hide modal if visible */
	modal_hide_all();

	if (vm && vm != m)
		nixpkgs_hide_all();

	/* Load cache on first show */
	ensure_nixpkgs_cache_loaded();

	mw = m->w.width > 0 ? m->w.width : m->m.width;
	mh = m->w.height > 0 ? m->w.height : m->m.height;
	w = mw > 0 ? (int)(mw * 0.5) : 600;
	h = mh > 0 ? (int)(mh * 0.6) : 500;
	if (w < min_w) w = min_w;
	if (h < min_h) h = min_h;
	if (w > max_w) w = max_w;
	if (h > max_h) h = max_h;

	x = m->m.x + (m->m.width - w) / 2;
	y = m->m.y + (m->m.height - h) / 2;
	if (x < m->m.x) x = m->m.x;
	if (y < m->m.y) y = m->m.y;

	no = &m->nixpkgs;
	no->width = w;
	no->height = h;
	no->x = x;
	no->y = y;

	if (!no->bg)
		no->bg = wlr_scene_tree_create(no->tree);
	if (no->bg) {
		struct wlr_scene_node *node, *tmp;
		wl_list_for_each_safe(node, tmp, &no->bg->children, link)
			wlr_scene_node_destroy(node);
		drawrect(no->bg, 0, 0, w, h, statusbar_popup_bg);
	}

	wlr_scene_node_set_position(&no->tree->node, x, y);
	wlr_scene_node_set_enabled(&no->tree->node, 1);

	/* Reset state */
	no->search[0] = '\0';
	no->search_len = 0;
	no->search_rendered[0] = '\0';
	no->selected = 0;
	no->scroll = 0;
	no->search_field_tree = NULL;
	no->results_tree = NULL;
	no->row_highlight_count = 0;

	no->visible = 1;
	nixpkgs_update_results(m);
	nixpkgs_render(m);
}

/* ============================================================================
 * Gamepad Controller Menu Implementation
 * ============================================================================ */

static void
gamepad_menu_show(Monitor *m)
{
	GamepadMenu *gm;
	int w, h, x, y;
	/* Near-opaque dark overlay to obscure background (simulates heavy blur) */
	float dim_color[4] = {0.08f, 0.08f, 0.10f, 0.97f};

	if (!m)
		return;

	gamepad_menu_hide_all();

	gm = &m->gamepad_menu;
	gm->selected = 0;
	htpc_menu_build();  /* Build menu based on enabled pages */
	gm->item_count = htpc_menu_item_count;

	/* Calculate popup size - just buttons, no title/hints */
	w = 300;
	/* Add extra separator space between gaming and streaming sections */
	int separator_gap = 20;
	h = 20 + htpc_menu_item_count * 55 + separator_gap + 20;

	/* Center on monitor */
	x = m->m.x + (m->m.width - w) / 2;
	y = m->m.y + (m->m.height - h) / 2;

	gm->x = x;
	gm->y = y;
	gm->width = w;
	gm->height = h;
	gm->visible = 1;

	/* Create dim overlay to obscure background */
	if (!gm->dim)
		gm->dim = wlr_scene_tree_create(layers[LyrBlock]);
	if (gm->dim) {
		struct wlr_scene_node *node, *tmp;
		wl_list_for_each_safe(node, tmp, &gm->dim->children, link)
			wlr_scene_node_destroy(node);
		wlr_scene_node_set_position(&gm->dim->node, m->m.x, m->m.y);
		drawrect(gm->dim, 0, 0, m->m.width, m->m.height, dim_color);
		wlr_scene_node_set_enabled(&gm->dim->node, 1);
		wlr_scene_node_raise_to_top(&gm->dim->node);
	}

	if (!gm->tree)
		gm->tree = wlr_scene_tree_create(layers[LyrBlock]);
	if (!gm->tree)
		return;

	wlr_scene_node_set_position(&gm->tree->node, x, y);
	wlr_scene_node_set_enabled(&gm->tree->node, 1);
	wlr_scene_node_raise_to_top(&gm->tree->node);

	gamepad_menu_render(m);
}

static void
gamepad_menu_hide(Monitor *m)
{
	GamepadMenu *gm;

	if (!m)
		return;

	gm = &m->gamepad_menu;
	if (!gm->visible)
		return;

	gm->visible = 0;
	if (gm->tree)
		wlr_scene_node_set_enabled(&gm->tree->node, 0);
	if (gm->dim)
		wlr_scene_node_set_enabled(&gm->dim->node, 0);
}

static void
gamepad_menu_hide_all(void)
{
	Monitor *m;

	wl_list_for_each(m, &mons, link) {
		gamepad_menu_hide(m);
	}
}

static Monitor *
gamepad_menu_visible_monitor(void)
{
	Monitor *m;

	wl_list_for_each(m, &mons, link) {
		if (m->gamepad_menu.visible)
			return m;
	}
	return NULL;
}

static void
gamepad_menu_render(Monitor *m)
{
	GamepadMenu *gm;
	struct wlr_scene_node *node, *tmp;
	int padding = 15;
	int item_height = 55;
	int button_margin = 10;
	int y_offset;
	float bg_color[4] = {0.12f, 0.12f, 0.14f, 0.95f};
	float button_color[4] = {0.18f, 0.18f, 0.22f, 1.0f};
	float selected_color[4] = {0.25f, 0.5f, 0.9f, 1.0f};
	float border_color[4] = {0.35f, 0.35f, 0.4f, 1.0f};

	if (!m || !statusfont.font)
		return;

	gm = &m->gamepad_menu;
	if (!gm->visible || !gm->tree)
		return;

	/* Clear previous content */
	wl_list_for_each_safe(node, tmp, &gm->tree->children, link) {
		if (gm->bg && node == &gm->bg->node)
			continue;
		wlr_scene_node_destroy(node);
	}

	/* Create/update background */
	if (!gm->bg)
		gm->bg = wlr_scene_tree_create(gm->tree);
	if (gm->bg) {
		wl_list_for_each_safe(node, tmp, &gm->bg->children, link)
			wlr_scene_node_destroy(node);
		wlr_scene_node_set_position(&gm->bg->node, 0, 0);
		drawrect(gm->bg, 0, 0, gm->width, gm->height, bg_color);
		/* Outer border */
		drawrect(gm->bg, 0, 0, gm->width, 2, border_color);
		drawrect(gm->bg, 0, gm->height - 2, gm->width, 2, border_color);
		drawrect(gm->bg, 0, 0, 2, gm->height, border_color);
		drawrect(gm->bg, gm->width - 2, 0, 2, gm->height, border_color);
	}

	/* Draw menu items as buttons with equal spacing */
	int current_y = padding;
	for (int i = 0; i < gm->item_count; i++) {
		const char *label = htpc_menu_items[i].label;
		int button_x = padding;
		int button_w = gm->width - 2 * padding;
		int button_h = item_height - button_margin;
		int label_w = status_text_width(label);
		/* Center label horizontally within button */
		int label_x = (button_w - label_w) / 2;
		int button_y = current_y;

		/* Draw button background */
		if (i == gm->selected) {
			drawrect(gm->tree, button_x, button_y, button_w, button_h, selected_color);
		} else {
			drawrect(gm->tree, button_x, button_y, button_w, button_h, button_color);
		}

		/* Button border */
		float btn_border[4] = {0.4f, 0.4f, 0.45f, 1.0f};
		drawrect(gm->tree, button_x, button_y, button_w, 1, btn_border);
		drawrect(gm->tree, button_x, button_y + button_h - 1, button_w, 1, btn_border);
		drawrect(gm->tree, button_x, button_y, 1, button_h, btn_border);
		drawrect(gm->tree, button_x + button_w - 1, button_y, 1, button_h, btn_border);

		/* Button label - create subtree positioned at button location */
		struct wlr_scene_tree *label_tree = wlr_scene_tree_create(gm->tree);
		if (label_tree) {
			wlr_scene_node_set_position(&label_tree->node, button_x, button_y);
			StatusModule mod = {0};
			mod.tree = label_tree;
			/* tray_render_label centers text vertically within bar_height */
			tray_render_label(&mod, label, label_x, button_h, statusbar_fg);
		}

		current_y += item_height;

		/* Add extra separator gap after PC-gaming (before streaming services) */
		if (strcmp(label, "PC-gaming") == 0)
			current_y += 20;
	}
}

/* Handle mouse click on gamepad menu - returns 1 if click was inside menu */
static int
gamepad_menu_handle_click(Monitor *m, int cx, int cy, uint32_t button)
{
	GamepadMenu *gm;
	int padding = 15;
	int item_height = 55;
	int relx, rely;
	int clicked_item;

	if (!m)
		return 0;

	gm = &m->gamepad_menu;
	if (!gm->visible)
		return 0;

	/* Check if click is inside menu bounds */
	relx = cx - gm->x;
	rely = cy - gm->y;

	if (relx < 0 || rely < 0 || relx >= gm->width || rely >= gm->height) {
		/* Click outside menu - close it */
		gamepad_menu_hide(m);
		return 1;
	}

	/* Only handle left click for selection */
	if (button != BTN_LEFT)
		return 1;

	/* Calculate which item was clicked - account for separator gap */
	clicked_item = -1;
	int current_y = padding;
	for (int i = 0; i < gm->item_count; i++) {
		int button_h = item_height - 10; /* button_margin */
		if (rely >= current_y && rely < current_y + button_h) {
			clicked_item = i;
			break;
		}
		current_y += item_height;
		/* Account for separator after PC-gaming */
		if (strcmp(htpc_menu_items[i].label, "PC-gaming") == 0)
			current_y += 20;
	}

	if (clicked_item >= 0 && clicked_item < gm->item_count) {
		gm->selected = clicked_item;
		gamepad_menu_select(m);
	}

	return 1;
}

static void
gamepad_menu_select(Monitor *m)
{
	GamepadMenu *gm;
	const char *cmd;
	const char *label;

	if (!m)
		return;

	gm = &m->gamepad_menu;
	if (!gm->visible || gm->selected < 0 || gm->selected >= gm->item_count)
		return;

	label = htpc_menu_items[gm->selected].label;
	cmd = htpc_menu_items[gm->selected].command;

	/* Handle PC-gaming - launch Steam Big Picture only */
	if (strcmp(label, "PC-gaming") == 0) {
		gamepad_menu_hide_all();
		wlr_log(WLR_INFO, "Launching Steam Big Picture");

		/* Launch Steam Big Picture if not already running */
		steam_launch_bigpicture();
		return;
	}

	/* Handle Retro-gaming - switch to tag 3 and show retro console selection */
	if (strcmp(label, "Retro-gaming") == 0) {
		gamepad_menu_hide_all();
		steam_kill();
		wlr_log(WLR_INFO, "Switching to Retro Gaming (tag 3)");

		/* Switch to tag 3 */
		if (selmon) {
			selmon->seltags ^= 1;
			selmon->tagset[selmon->seltags] = 1 << 2; /* Tag 3 = bit 2 */
			focusclient(focustop(selmon), 1);
			arrange(selmon);
			printstatus();
		}

		retro_gaming_show(m);
		return;
	}

	/* Handle Movies - switch to tag 2 and show movies grid view */
	if (strcmp(label, "Movies") == 0) {
		gamepad_menu_hide_all();
		steam_kill();
		live_tv_kill();
		wlr_log(WLR_INFO, "Switching to Movies (tag 2)");

		/* Switch to tag 2 - use m consistently (same monitor as menu) */
		m->seltags ^= 1;
		m->tagset[m->seltags] = 1 << 1; /* Tag 2 = bit 1 */

		/* Show view BEFORE arrange so htpc_views_update_visibility sees correct state */
		media_view_show(m, MEDIA_VIEW_MOVIES);

		focusclient(focustop(m), 1);
		arrange(m);
		printstatus();
		return;
	}

	/* Handle TV-shows - switch to tag 1 and show tvshows grid view */
	if (strcmp(label, "TV-shows") == 0) {
		gamepad_menu_hide_all();
		steam_kill();
		live_tv_kill();
		wlr_log(WLR_INFO, "Switching to TV-shows (tag 1)");

		/* Switch to tag 1 - use m consistently (same monitor as menu) */
		m->seltags ^= 1;
		m->tagset[m->seltags] = 1 << 0; /* Tag 1 = bit 0 */

		/* Show view BEFORE arrange so htpc_views_update_visibility sees correct state */
		media_view_show(m, MEDIA_VIEW_TVSHOWS);

		focusclient(focustop(m), 1);
		arrange(m);
		printstatus();
		return;
	}

	/* Handle NRK - launch Chromium kiosk with nrk.no */
	if (strcmp(label, "NRK") == 0) {
		gamepad_menu_hide_all();
		steam_kill();
		live_tv_kill();
		media_view_hide_all();
		retro_gaming_hide_all();
		pc_gaming_hide_all();
		wlr_log(WLR_INFO, "Launching NRK stream in Chromium kiosk");
		pid_t pid = fork();
		if (pid == 0) {
			setsid();
			execlp("chromium", "chromium",
				"--ozone-platform=wayland",
				"--kiosk", "--start-fullscreen",
				"--autoplay-policy=no-user-gesture-required",
				"--enable-features=VaapiVideoDecoder,PlatformHEVCDecoderSupport",
				"--disable-gpu-vsync",
				"--disable-frame-rate-limit",
				"--force-device-scale-factor=1",
				"--disable-translate",
				NRK_URL, (char *)NULL);
			_exit(127);
		}
		return;
	}

	/* Handle Netflix - launch Chromium kiosk */
	if (strcmp(label, "Netflix") == 0) {
		gamepad_menu_hide_all();
		steam_kill();
		live_tv_kill();
		media_view_hide_all();
		retro_gaming_hide_all();
		pc_gaming_hide_all();
		wlr_log(WLR_INFO, "Launching Netflix in Chromium kiosk");
		pid_t pid = fork();
		if (pid == 0) {
			setsid();
			execlp("chromium", "chromium",
				"--ozone-platform=wayland",
				"--kiosk", "--start-fullscreen",
				"--autoplay-policy=no-user-gesture-required",
				"--enable-features=VaapiVideoDecoder,PlatformHEVCDecoderSupport",
				"--disable-gpu-vsync",
				"--disable-frame-rate-limit",
				"--force-device-scale-factor=1",
				"--disable-translate",
				NETFLIX_URL, (char *)NULL);
			_exit(127);
		}
		return;
	}

	/* Handle Viaplay - launch Chromium kiosk */
	if (strcmp(label, "Viaplay") == 0) {
		gamepad_menu_hide_all();
		steam_kill();
		live_tv_kill();
		media_view_hide_all();
		retro_gaming_hide_all();
		pc_gaming_hide_all();
		wlr_log(WLR_INFO, "Launching Viaplay in Chromium kiosk");
		pid_t pid = fork();
		if (pid == 0) {
			setsid();
			execlp("chromium", "chromium",
				"--ozone-platform=wayland",
				"--kiosk", "--start-fullscreen",
				"--autoplay-policy=no-user-gesture-required",
				"--enable-features=VaapiVideoDecoder,PlatformHEVCDecoderSupport",
				"--disable-gpu-vsync",
				"--disable-frame-rate-limit",
				"--force-device-scale-factor=1",
				"--disable-translate",
				VIAPLAY_URL, (char *)NULL);
			_exit(127);
		}
		return;
	}

	/* Handle TV2 Play - launch Chromium kiosk */
	if (strcmp(label, "TV2 Play") == 0) {
		gamepad_menu_hide_all();
		steam_kill();
		live_tv_kill();
		media_view_hide_all();
		retro_gaming_hide_all();
		pc_gaming_hide_all();
		wlr_log(WLR_INFO, "Launching TV2 Play in Chromium kiosk");
		pid_t pid = fork();
		if (pid == 0) {
			setsid();
			execlp("chromium", "chromium",
				"--ozone-platform=wayland",
				"--kiosk", "--start-fullscreen",
				"--autoplay-policy=no-user-gesture-required",
				"--enable-features=VaapiVideoDecoder,PlatformHEVCDecoderSupport",
				"--disable-gpu-vsync",
				"--disable-frame-rate-limit",
				"--force-device-scale-factor=1",
				"--disable-translate",
				TV2PLAY_URL, (char *)NULL);
			_exit(127);
		}
		return;
	}

	/* Handle F1TV - launch browser with F1TV 4K live stream */
	if (strcmp(label, "F1TV") == 0) {
		gamepad_menu_hide_all();
		steam_kill();
		live_tv_kill();
		media_view_hide_all();
		retro_gaming_hide_all();
		pc_gaming_hide_all();
		wlr_log(WLR_INFO, "Launching F1TV stream in Chromium kiosk");
		pid_t pid = fork();
		if (pid == 0) {
			setsid();
			execlp("chromium", "chromium",
				"--ozone-platform=wayland",
				"--kiosk", "--start-fullscreen",
				"--autoplay-policy=no-user-gesture-required",
				"--enable-features=VaapiVideoDecoder,PlatformHEVCDecoderSupport",
				"--disable-gpu-vsync",
				"--disable-frame-rate-limit",
				"--force-device-scale-factor=1",
				"--disable-translate",
				F1TV_URL, (char *)NULL);
			_exit(127);
		}
		return;
	}

	/* Handle Quit HTPC - exit HTPC mode and return to normal desktop */
	if (strcmp(label, "Quit HTPC") == 0) {
		gamepad_menu_hide_all();
		steam_kill();
		wlr_log(WLR_INFO, "Exiting HTPC mode");
		htpc_mode_exit();
		return;
	}

	/* Execute command if set, otherwise just log the selection */
	if (cmd && cmd[0]) {
		Arg arg = {.v = cmd};
		spawn(&arg);
	} else {
		wlr_log(WLR_INFO, "Gamepad menu selected: %s", label);
	}

	gamepad_menu_hide_all();
}

/* Handle gamepad button press - returns 1 if handled */
static int
gamepad_menu_handle_button(Monitor *m, int button, int value)
{
	GamepadMenu *gm;

	if (!m)
		return 0;

	/* Handle on-screen keyboard FIRST - it has highest priority when visible
	 * Check all monitors since OSK might be on a different monitor */
	{
		Monitor *osk_mon = osk_visible_monitor();
		if (osk_mon) {
			if (osk_handle_button(osk_mon, button, value))
				return 1;
		}
	}

	/* Handle wifi popup with gamepad (A = connect, B = cancel) */
	if (m->wifi_popup.visible && value == 1) {
		switch (button) {
		case BTN_SOUTH:  /* A button - connect */
			if (!m->wifi_popup.connecting && m->wifi_popup.password_len > 0)
				wifi_popup_connect(m);
			return 1;
		case BTN_EAST:   /* B button - cancel */
			wifi_popup_hide_all();
			return 1;
		}
		return 1;  /* Consume other buttons when popup is open */
	}

	/* Handle sudo popup with gamepad (A = submit, B = cancel) */
	if (m->sudo_popup.visible && value == 1) {
		switch (button) {
		case BTN_SOUTH:  /* A button - submit */
			if (!m->sudo_popup.running && m->sudo_popup.password_len > 0)
				sudo_popup_execute(m);
			return 1;
		case BTN_EAST:   /* B button - cancel */
			sudo_popup_hide_all();
			return 1;
		}
		return 1;  /* Consume other buttons when popup is open */
	}

	gm = &m->gamepad_menu;

	/* BTN_MODE (guide button) - instant press to toggle menu */
	if (button == BTN_MODE && value == 1) {
		if (gm->visible)
			gamepad_menu_hide(m);
		else
			gamepad_menu_show(m);
		return 1;  /* Consume the event */
	}

	/* Menu navigation takes priority when menu is visible (on button press only) */
	if (gm->visible && value == 1) {
		switch (button) {
		case BTN_SOUTH:  /* A button - select */
			gamepad_menu_select(m);
			return 1;
		case BTN_EAST:   /* B button - close */
			gamepad_menu_hide(m);
			return 1;
		case BTN_DPAD_UP:
			if (gm->selected > 0) {
				gm->selected--;
				gamepad_menu_render(m);
			}
			return 1;
		case BTN_DPAD_DOWN:
			if (gm->selected < gm->item_count - 1) {
				gm->selected++;
				gamepad_menu_render(m);
			}
			return 1;
		}
	}

	/* Check if PC gaming view is active on ANY monitor
	 * Use pc_gaming_visible_monitor() to find the correct monitor since
	 * selmon may have changed due to mouse movement */
	{
		Monitor *pg_mon = pc_gaming_visible_monitor();
		if (pg_mon && htpc_view_is_active(pg_mon, pg_mon->pc_gaming.view_tag, pg_mon->pc_gaming.visible)) {
			if (pc_gaming_handle_button(pg_mon, button, value))
				return 1;
			/* Block guide button when install popup is visible */
			if (pg_mon->pc_gaming.install_popup_visible && button == BTN_MODE)
				return 0;  /* Let Steam handle it */
			/* Fall through to mouse click emulation if a popup client has focus */
		}
	}

	/* Check if Retro gaming view is active on ANY monitor */
	{
		Monitor *rg_mon = retro_gaming_visible_monitor();
		if (rg_mon && htpc_view_is_active(rg_mon, rg_mon->retro_gaming.view_tag, rg_mon->retro_gaming.visible)) {
			if (retro_gaming_handle_button(rg_mon, button, value))
				return 1;
		}
	}

	/* Check if Movies or TV-shows view is active on ANY monitor
	 * Use media_view_visible_monitor() to find the correct monitor since
	 * selmon may have changed due to mouse movement */
	{
		Monitor *media_mon = media_view_visible_monitor();
		if (media_mon) {
			if (htpc_view_is_active(media_mon, media_mon->movies_view.view_tag, media_mon->movies_view.visible)) {
				if (media_view_handle_button(media_mon, MEDIA_VIEW_MOVIES, button, value))
					return 1;
			}
			if (htpc_view_is_active(media_mon, media_mon->tvshows_view.view_tag, media_mon->tvshows_view.visible)) {
				if (media_view_handle_button(media_mon, MEDIA_VIEW_TVSHOWS, button, value))
					return 1;
			}
		}
	}

	/* Mouse click emulation with shoulder buttons (when menu is not visible) */
	if (!gm->visible) {
		/* Skip click emulation if a fullscreen client has focus (let game handle it)
		 * Exception: In HTPC mode, allow click emulation for browsers */
		Client *focused = focustop(selmon);
		if (focused && focused->isfullscreen &&
		    !(htpc_mode_active && is_browser_client(focused)))
			return 0;

		/* Y button (BTN_NORTH) - toggle on-screen keyboard in HTPC mode */
		if (button == BTN_NORTH && value == 1 && htpc_mode_active) {
			Monitor *osk_mon = osk_visible_monitor();
			if (osk_mon) {
				osk_hide(osk_mon);
			} else if (selmon) {
				osk_show(selmon, NULL);
			}
			return 1;
		}

		/* X button (BTN_WEST) - show OSK when in browser (for text input) */
		if (button == BTN_WEST && value == 1 && htpc_mode_active) {
			if (focused && is_browser_client(focused)) {
				Monitor *osk_mon = osk_visible_monitor();
				if (!osk_mon && selmon) {
					osk_show(selmon, NULL);
				}
				return 1;
			}
		}

		uint32_t time_msec = (uint32_t)(monotonic_msec() & 0xFFFFFFFF);
		uint32_t mapped_button = 0;
		uint32_t state = value ? WL_POINTER_BUTTON_STATE_PRESSED : WL_POINTER_BUTTON_STATE_RELEASED;

		switch (button) {
		case BTN_TR:  /* Right bumper = left click */
		case BTN_SOUTH:  /* A button = left click */
			mapped_button = BTN_LEFT;
			break;
		case BTN_TL:  /* Left bumper = right click */
		case BTN_EAST:  /* B button = right click */
			mapped_button = BTN_RIGHT;
			break;
		case BTN_THUMBL:  /* Left stick click = middle click */
			mapped_button = BTN_MIDDLE;
			break;
		}

		if (mapped_button) {
			/* Use internal handler for full statusbar/tile support */
			handle_pointer_button_internal(mapped_button, state, time_msec);
			return 1;
		}
		return 0;
	}

	return 0;
}

/* ==================== PC GAMING VIEW ==================== */

static void
pc_gaming_free_games(Monitor *m)
{
	GameEntry *g, *next;

	if (!m)
		return;

	g = m->pc_gaming.games;
	while (g) {
		next = g->next;
		if (g->icon_buf)
			wlr_buffer_drop(g->icon_buf);
		free(g);
		g = next;
	}
	m->pc_gaming.games = NULL;
	m->pc_gaming.game_count = 0;
}

static void
pc_gaming_add_game(Monitor *m, const char *id, const char *name, const char *launch_cmd,
                   const char *icon_path, GamingServiceType service, int installed)
{
	GameEntry *g;

	if (!m || !id || !name)
		return;

	g = calloc(1, sizeof(*g));
	if (!g)
		return;

	snprintf(g->id, sizeof(g->id), "%s", id);
	snprintf(g->name, sizeof(g->name), "%s", name);
	snprintf(g->launch_cmd, sizeof(g->launch_cmd), "%s", launch_cmd ? launch_cmd : "");
	if (icon_path && icon_path[0])
		snprintf(g->icon_path, sizeof(g->icon_path), "%s", icon_path);
	g->service = service;
	g->installed = installed;
	g->is_game = 1;  /* Games added via this function are actual games */
	g->icon_buf = NULL;
	g->icon_loaded = 0;

	/* Add to front of list */
	g->next = m->pc_gaming.games;
	m->pc_gaming.games = g;
	m->pc_gaming.game_count++;
}

/* Save games cache to file for fast loading */
static void
pc_gaming_save_cache(Monitor *m)
{
	FILE *fp;
	char path[512];
	char *home;
	GameEntry *g;

	if (!m)
		return;

	home = getenv("HOME");
	if (!home)
		return;

	/* Create cache directory */
	snprintf(path, sizeof(path), "%s/.cache/nixlytile", home);
	mkdir(path, 0755);

	snprintf(path, sizeof(path), "%s" PC_GAMING_CACHE_FILE, home);
	fp = fopen(path, "w");
	if (!fp)
		return;

	/* Write header with version */
	fprintf(fp, "NIXLYTILE_GAMES_CACHE_V7\n");
	fprintf(fp, "%d\n", m->pc_gaming.game_count);

	/* Write each game: id|name|icon_path|launch_cmd|service|installed|playtime|is_game|acquired|controller|deck */
	g = m->pc_gaming.games;
	while (g) {
		fprintf(fp, "%s|%s|%s|%s|%d|%d|%d|%d|%ld|%d|%d\n",
			g->id, g->name, g->icon_path, g->launch_cmd,
			(int)g->service, g->installed, g->playtime_minutes, g->is_game,
			(long)g->acquired_time, g->controller_support, g->deck_verified);
		g = g->next;
	}

	fclose(fp);
	wlr_log(WLR_INFO, "Saved %d games to cache", m->pc_gaming.game_count);
}

/* Load games from cache file */
static int
pc_gaming_load_cache(Monitor *m)
{
	FILE *fp;
	char path[512];
	char line[2048];
	char *home;
	int count = 0;
	struct stat st;

	if (!m)
		return 0;

	home = getenv("HOME");
	if (!home)
		return 0;

	snprintf(path, sizeof(path), "%s" PC_GAMING_CACHE_FILE, home);

	/* Check if cache exists and is recent (less than 24 hours old) */
	if (stat(path, &st) != 0)
		return 0;

	time_t now = time(NULL);
	if (now - st.st_mtime > 86400) {
		wlr_log(WLR_INFO, "Games cache is stale, will refresh");
		return 0;
	}

	fp = fopen(path, "r");
	if (!fp)
		return 0;

	/* Check header */
	if (!fgets(line, sizeof(line), fp) ||
	    strncmp(line, "NIXLYTILE_GAMES_CACHE_V7", 24) != 0) {
		fclose(fp);
		return 0;
	}

	/* Read count */
	if (!fgets(line, sizeof(line), fp)) {
		fclose(fp);
		return 0;
	}
	count = atoi(line);
	if (count <= 0 || count > 10000) {
		fclose(fp);
		return 0;
	}

	/* Read games */
	while (fgets(line, sizeof(line), fp)) {
		char *id, *name, *icon, *launch, *svc_str, *inst_str, *playtime_str, *is_game_str, *acquired_str;
		char *saveptr;

		/* Remove newline */
		line[strcspn(line, "\n")] = '\0';

		id = strtok_r(line, "|", &saveptr);
		name = strtok_r(NULL, "|", &saveptr);
		icon = strtok_r(NULL, "|", &saveptr);
		launch = strtok_r(NULL, "|", &saveptr);
		svc_str = strtok_r(NULL, "|", &saveptr);
		inst_str = strtok_r(NULL, "|", &saveptr);
		playtime_str = strtok_r(NULL, "|", &saveptr);
		is_game_str = strtok_r(NULL, "|", &saveptr);
		acquired_str = strtok_r(NULL, "|", &saveptr);
		char *controller_str = strtok_r(NULL, "|", &saveptr);
		char *deck_str = strtok_r(NULL, "|", &saveptr);

		if (!id || !name || !svc_str)
			continue;

		GameEntry *g = calloc(1, sizeof(*g));
		if (!g)
			continue;

		snprintf(g->id, sizeof(g->id), "%s", id);
		snprintf(g->name, sizeof(g->name), "%s", name);
		if (icon)
			snprintf(g->icon_path, sizeof(g->icon_path), "%s", icon);
		if (launch)
			snprintf(g->launch_cmd, sizeof(g->launch_cmd), "%s", launch);
		g->service = (GamingServiceType)atoi(svc_str);
		g->installed = inst_str ? atoi(inst_str) : 0;
		g->playtime_minutes = playtime_str ? atoi(playtime_str) : 0;
		g->is_game = is_game_str ? atoi(is_game_str) : 1;  /* Default to game if not specified */
		g->acquired_time = acquired_str ? atol(acquired_str) : 0;
		g->controller_support = controller_str ? atoi(controller_str) : 0;
		g->deck_verified = deck_str ? atoi(deck_str) : 0;
		g->icon_buf = NULL;
		g->icon_loaded = 0;

		g->next = m->pc_gaming.games;
		m->pc_gaming.games = g;
		m->pc_gaming.game_count++;
	}

	fclose(fp);
	wlr_log(WLR_INFO, "Loaded %d games from cache", m->pc_gaming.game_count);
	return m->pc_gaming.game_count > 0;
}

/* Fetch Steam game names using parallel API requests */
static void
pc_gaming_fetch_steam_names_batch(Monitor *m)
{
	FILE *script_fp, *result_fp;
	char script_path[128];
	char result_path[128];
	char *buf = NULL;
	size_t buf_size = 0;
	int need_fetch = 0;
	GameEntry *g;

	if (!m)
		return;

	/* Create temp files */
	snprintf(script_path, sizeof(script_path), "/tmp/nixlytile_steam_%d.sh", getpid());
	snprintf(result_path, sizeof(result_path), "/tmp/nixlytile_steam_%d.txt", getpid());

	script_fp = fopen(script_path, "w");
	if (!script_fp)
		return;

	/* Write script header */
	fprintf(script_fp, "#!/bin/sh\n");

	/* Write parallel fetch commands for each game needing a name */
	g = m->pc_gaming.games;
	while (g) {
		if (g->service == GAMING_SERVICE_STEAM &&
		    strncmp(g->name, "Steam Game ", 11) == 0) {
			fprintf(script_fp,
				"(resp=$(curl -s --max-time 3 -A 'Mozilla/5.0' 'https://store.steampowered.com/api/appdetails?appids=%s' 2>/dev/null)\n"
				" name=$(echo \"$resp\" | grep -o '\"name\":\"[^\"]*\"' | head -1 | sed 's/\"name\":\"//;s/\"$//')\n"
				" type=$(echo \"$resp\" | grep -o '\"type\":\"[^\"]*\"' | head -1 | sed 's/\"type\":\"//;s/\"$//')\n"
				" if [ -n \"$name\" ]; then echo '%s|'\"$name\"'|'\"$type\"; fi) &\n",
				g->id, g->id);
			need_fetch++;
		}
		g = g->next;
	}

	if (need_fetch == 0) {
		fclose(script_fp);
		unlink(script_path);
		return;
	}

	fprintf(script_fp, "wait\n");
	fclose(script_fp);

	wlr_log(WLR_INFO, "Fetching names for %d Steam games in parallel...", need_fetch);

	/* Execute script */
	char cmd[256];
	snprintf(cmd, sizeof(cmd), "sh %s > %s 2>/dev/null", script_path, result_path);
	int ret = system(cmd);
	unlink(script_path);

	if (ret != 0) {
		unlink(result_path);
		return;
	}

	/* Read results */
	result_fp = fopen(result_path, "r");
	if (!result_fp) {
		unlink(result_path);
		return;
	}

	fseek(result_fp, 0, SEEK_END);
	long fsize = ftell(result_fp);
	fseek(result_fp, 0, SEEK_SET);

	if (fsize > 0) {
		buf = malloc(fsize + 1);
		if (buf) {
			buf_size = fread(buf, 1, fsize, result_fp);
			buf[buf_size] = '\0';
		}
	}
	fclose(result_fp);
	unlink(result_path);

	if (!buf || buf_size == 0) {
		free(buf);
		return;
	}

	/* Parse results: "appid|Game Name|type\n" */
	int updated = 0;
	char *line = buf;
	while (line && *line) {
		char *newline = strchr(line, '\n');
		if (newline)
			*newline = '\0';

		char *sep1 = strchr(line, '|');
		if (sep1) {
			*sep1 = '\0';
			char *appid_str = line;
			char *name = sep1 + 1;
			char *type = NULL;

			char *sep2 = strchr(name, '|');
			if (sep2) {
				*sep2 = '\0';
				type = sep2 + 1;
			}

			/* Find and update game entry */
			g = m->pc_gaming.games;
			while (g) {
				if (g->service == GAMING_SERVICE_STEAM &&
				    strcmp(g->id, appid_str) == 0) {
					snprintf(g->name, sizeof(g->name), "%s", name);
					/* Mark as NOT a game only for specific non-game types */
					if (type && (strcmp(type, "dlc") == 0 ||
					             strcmp(type, "tool") == 0 ||
					             strcmp(type, "demo") == 0 ||
					             strcmp(type, "advertising") == 0 ||
					             strcmp(type, "mod") == 0 ||
					             strcmp(type, "video") == 0 ||
					             strcmp(type, "hardware") == 0 ||
					             strcmp(type, "series") == 0 ||
					             strcmp(type, "episode") == 0)) {
						g->is_game = 0;
					}
					updated++;
					break;
				}
				g = g->next;
			}
		}

		line = newline ? newline + 1 : NULL;
	}

	free(buf);
	wlr_log(WLR_INFO, "Updated %d game names from Steam API", updated);
}

/* Load Steam playtime from localconfig.vdf */
static void
pc_gaming_load_steam_playtime(Monitor *m)
{
	FILE *fp;
	char path[512];
	char line[1024];
	char *home;
	DIR *dir;
	struct dirent *ent;
	char current_appid[32] = "";
	int in_apps_section = 0;

	if (!m)
		return;

	home = getenv("HOME");
	if (!home)
		return;

	/* Find Steam user directory */
	snprintf(path, sizeof(path), "%s/.local/share/Steam/userdata", home);
	dir = opendir(path);
	if (!dir)
		return;

	/* Find first user ID directory */
	char userid[32] = "";
	while ((ent = readdir(dir)) != NULL) {
		if (ent->d_name[0] != '.' && ent->d_type == DT_DIR) {
			snprintf(userid, sizeof(userid), "%s", ent->d_name);
			break;
		}
	}
	closedir(dir);

	if (!userid[0])
		return;

	snprintf(path, sizeof(path), "%s/.local/share/Steam/userdata/%s/config/localconfig.vdf", home, userid);
	fp = fopen(path, "r");
	if (!fp)
		return;

	/* Parse VDF format for playtime */
	while (fgets(line, sizeof(line), fp)) {
		/* Look for "apps" section */
		if (strstr(line, "\"apps\""))
			in_apps_section = 1;

		if (!in_apps_section)
			continue;

		/* Check for app ID (numeric key) */
		char *quote1 = strchr(line, '"');
		if (quote1) {
			char *quote2 = strchr(quote1 + 1, '"');
			if (quote2) {
				size_t len = quote2 - quote1 - 1;
				if (len > 0 && len < sizeof(current_appid)) {
					/* Check if it's a number (appid) */
					int is_num = 1;
					for (size_t i = 0; i < len; i++) {
						if (quote1[1 + i] < '0' || quote1[1 + i] > '9') {
							is_num = 0;
							break;
						}
					}
					if (is_num) {
						memcpy(current_appid, quote1 + 1, len);
						current_appid[len] = '\0';
					}
				}
			}
		}

		/* Look for Playtime in current app context */
		if (current_appid[0] && strstr(line, "\"Playtime\"")) {
			char *val_start = strstr(line, "\"Playtime\"");
			val_start = strchr(val_start + 10, '"');
			if (val_start) {
				val_start++;
				int playtime = atoi(val_start);

				/* Find and update game entry */
				GameEntry *g = m->pc_gaming.games;
				while (g) {
					if (g->service == GAMING_SERVICE_STEAM &&
					    strcmp(g->id, current_appid) == 0) {
						g->playtime_minutes = playtime;
						break;
					}
					g = g->next;
				}
			}
		}

		/* Look for LastPlayed in current app context - use as acquired_time */
		if (current_appid[0] && strstr(line, "\"LastPlayed\"")) {
			char *val_start = strstr(line, "\"LastPlayed\"");
			val_start = strchr(val_start + 12, '"');
			if (val_start) {
				val_start++;
				long lastplayed = atol(val_start);

				/* Only use if > 86400 (skip placeholder values) */
				if (lastplayed > 86400) {
					GameEntry *g = m->pc_gaming.games;
					while (g) {
						if (g->service == GAMING_SERVICE_STEAM &&
						    strcmp(g->id, current_appid) == 0) {
							g->acquired_time = (time_t)lastplayed;
							break;
						}
						g = g->next;
					}
				}
			}
		}
	}

	fclose(fp);
}

/* Sort games by acquisition date (newest first) using merge sort */
static GameEntry *
pc_gaming_merge_sorted(GameEntry *a, GameEntry *b)
{
	if (!a) return b;
	if (!b) return a;

	GameEntry *result = NULL;
	int a_played = (a->acquired_time > 0);
	int b_played = (b->acquired_time > 0);

	/* Played games come first */
	if (a_played && !b_played) {
		result = a;
		result->next = pc_gaming_merge_sorted(a->next, b);
	} else if (!a_played && b_played) {
		result = b;
		result->next = pc_gaming_merge_sorted(a, b->next);
	} else if (a_played && b_played) {
		/* Both played - sort by most recently played first */
		if (a->acquired_time >= b->acquired_time) {
			result = a;
			result->next = pc_gaming_merge_sorted(a->next, b);
		} else {
			result = b;
			result->next = pc_gaming_merge_sorted(a, b->next);
		}
	} else {
		/* Neither played - sort by app ID (lower ID = older game, comes first) */
		if (atoi(a->id) <= atoi(b->id)) {
			result = a;
			result->next = pc_gaming_merge_sorted(a->next, b);
		} else {
			result = b;
			result->next = pc_gaming_merge_sorted(a, b->next);
		}
	}
	return result;
}

static void
pc_gaming_split_list(GameEntry *source, GameEntry **front, GameEntry **back)
{
	GameEntry *fast, *slow;
	slow = source;
	fast = source->next;

	while (fast) {
		fast = fast->next;
		if (fast) {
			slow = slow->next;
			fast = fast->next;
		}
	}

	*front = source;
	*back = slow->next;
	slow->next = NULL;
}

static void
pc_gaming_merge_sort(GameEntry **head)
{
	GameEntry *h = *head;
	GameEntry *a, *b;

	if (!h || !h->next)
		return;

	pc_gaming_split_list(h, &a, &b);
	pc_gaming_merge_sort(&a);
	pc_gaming_merge_sort(&b);

	*head = pc_gaming_merge_sorted(a, b);
}

static void
pc_gaming_sort_by_acquired(Monitor *m)
{
	if (!m || !m->pc_gaming.games)
		return;

	pc_gaming_merge_sort(&m->pc_gaming.games);
	wlr_log(WLR_INFO, "Sorted games: played first (by recency), then unplayed (by age)");
}

/* Known Proton, runtime, and tool app IDs to always filter */
static int pc_gaming_is_known_tool(const char *appid)
{
	/* Proton versions */
	static const char *proton_ids[] = {
		"1887720", "2180100", "1493710", "1580130", "2348590", "1245040",
		"961940", "1054830", "1113280", "1420170", "858280", "930400",
		"996510", "2805730", "2230260", NULL
	};
	/* Steam Linux Runtime */
	static const char *runtime_ids[] = {
		"1070560", "1391110", "1628350", NULL
	};
	/* Steamworks and redistributables */
	static const char *redist_ids[] = {
		"228980", "228981", "1007", NULL
	};
	for (int i = 0; proton_ids[i]; i++)
		if (strcmp(appid, proton_ids[i]) == 0) return 1;
	for (int i = 0; runtime_ids[i]; i++)
		if (strcmp(appid, runtime_ids[i]) == 0) return 1;
	for (int i = 0; redist_ids[i]; i++)
		if (strcmp(appid, redist_ids[i]) == 0) return 1;
	return 0;
}

/* Filter out non-games (DLC, tools, servers, etc.) */
static void
pc_gaming_filter_non_games(Monitor *m)
{
	GameEntry **pp, *g;
	int removed = 0;

	if (!m)
		return;

	pp = &m->pc_gaming.games;
	while (*pp) {
		g = *pp;
		int should_filter = !g->is_game;

		/* Don't filter games without proper names - show with app ID instead */
		/* API may fail due to network issues, but game is still valid */

		/* Filter known Proton/runtime/tool app IDs */
		if (!should_filter && pc_gaming_is_known_tool(g->id))
			should_filter = 1;

		/* Also filter by name patterns for tools/servers/SDKs */
		if (!should_filter && g->name[0]) {
			if (strstr(g->name, "Proton") ||
			    strstr(g->name, "Dedicated Server") ||
			    strstr(g->name, "SDK") ||
			    strstr(g->name, "Mod Tools") ||
			    strstr(g->name, "Content Editor") ||
			    strstr(g->name, "Runtime") ||
			    strstr(g->name, "Redistributable") ||
			    strstr(g->name, "Steamworks") ||
			    strstr(g->name, "Soundtrack") ||
			    strstr(g->name, "Wallpaper") ||
			    strstr(g->name, "Artbook"))
				should_filter = 1;
		}
		if (should_filter) {
			*pp = g->next;
			if (g->icon_buf)
				wlr_buffer_drop(g->icon_buf);
			free(g);
			m->pc_gaming.game_count--;
			removed++;
		} else {
			pp = &g->next;
		}
	}

	wlr_log(WLR_INFO, "Filtered out %d non-game entries", removed);
}

/* Update installation status for games (check download progress) */
static void
pc_gaming_update_install_status(Monitor *m)
{
	GameEntry *g;
	char *home;
	const char *steam_paths[] = {
		"%s/.local/share/Steam/steamapps",
		"%s/.steam/steam/steamapps",
		NULL
	};

	if (!m)
		return;

	home = getenv("HOME");
	if (!home)
		return;

	g = m->pc_gaming.games;
	while (g) {
		if (g->service == GAMING_SERVICE_STEAM) {
			/* Check appmanifest for download status */
			for (int i = 0; steam_paths[i]; i++) {
				char manifest_path[512];
				FILE *fp;

				snprintf(manifest_path, sizeof(manifest_path),
					steam_paths[i], home);
				snprintf(manifest_path + strlen(manifest_path),
					sizeof(manifest_path) - strlen(manifest_path),
					"/appmanifest_%s.acf", g->id);

				fp = fopen(manifest_path, "r");
				if (fp) {
					char line[512];
					int64_t bytes_to_download = 0;
					int64_t bytes_downloaded = 0;
					int state_flags = 0;

					while (fgets(line, sizeof(line), fp)) {
						char *key, *val;
						key = strstr(line, "\"StateFlags\"");
						if (key) {
							val = strchr(key + 12, '\"');
							if (val) {
								val++;
								state_flags = atoi(val);
							}
						}
						key = strstr(line, "\"BytesToDownload\"");
						if (key) {
							val = strchr(key + 17, '\"');
							if (val) {
								val++;
								bytes_to_download = atoll(val);
							}
						}
						key = strstr(line, "\"BytesDownloaded\"");
						if (key) {
							val = strchr(key + 17, '\"');
							if (val) {
								val++;
								bytes_downloaded = atoll(val);
							}
						}
					}
					fclose(fp);

					/* StateFlags: 1026 = downloading, 1042 = updating, 4 = installed */
					if ((state_flags & 1024) && bytes_to_download > 0) {
						g->is_installing = 1;
						g->install_progress = (int)((bytes_downloaded * 100) / bytes_to_download);
						if (g->install_progress > 100)
							g->install_progress = 100;
					} else if (state_flags == 4) {
						/* Fully installed */
						g->is_installing = 0;
						g->install_progress = 0;
						g->installed = 1;
					}
					/* Don't reset is_installing for other states - Steam might be
					 * preparing the download. Only clear when confirmed installed. */
					break;
				}
			}
		}
		/* TODO: Add Heroic/Epic installation progress support */
		g = g->next;
	}
}

/* Load and scale game icon to tile dimensions */
static void
pc_gaming_load_game_icon(GameEntry *g, int target_w, int target_h)
{
	GdkPixbuf *pixbuf = NULL, *scaled = NULL;
	GError *gerr = NULL;
	int w, h, nchan, stride;
	guchar *pixels;
	uint8_t *argb = NULL;
	size_t bufsize;

	if (!g || g->icon_loaded)
		return;

	g->icon_loaded = 1;  /* Mark as attempted */

	if (!g->icon_path[0] || access(g->icon_path, F_OK) != 0)
		return;

	pixbuf = gdk_pixbuf_new_from_file(g->icon_path, &gerr);
	if (!pixbuf) {
		if (gerr) {
			g_error_free(gerr);
		}
		return;
	}

	w = gdk_pixbuf_get_width(pixbuf);
	h = gdk_pixbuf_get_height(pixbuf);
	if (w <= 0 || h <= 0) {
		g_object_unref(pixbuf);
		return;
	}

	/* Scale to exact target dimensions (fill/crop) */
	if (w != target_w || h != target_h) {
		scaled = gdk_pixbuf_scale_simple(pixbuf, target_w, target_h, GDK_INTERP_BILINEAR);
		g_object_unref(pixbuf);
		if (!scaled)
			return;
		pixbuf = scaled;
		w = target_w;
		h = target_h;
	}

	nchan = gdk_pixbuf_get_n_channels(pixbuf);
	if (nchan < 3) {
		g_object_unref(pixbuf);
		return;
	}
	stride = gdk_pixbuf_get_rowstride(pixbuf);
	pixels = gdk_pixbuf_get_pixels(pixbuf);
	if (!pixels) {
		g_object_unref(pixbuf);
		return;
	}

	bufsize = (size_t)w * (size_t)h * 4;
	argb = calloc(1, bufsize);
	if (!argb) {
		g_object_unref(pixbuf);
		return;
	}

	/* Convert RGB/RGBA to ARGB32 for wlroots */
	for (int y = 0; y < h; y++) {
		const guchar *row = pixels + y * stride;
		uint32_t *dst = (uint32_t *)(argb + y * w * 4);
		for (int x = 0; x < w; x++) {
			uint8_t r = row[x * nchan + 0];
			uint8_t gg = row[x * nchan + 1];
			uint8_t b = row[x * nchan + 2];
			uint8_t a = (nchan >= 4) ? row[x * nchan + 3] : 255;
			dst[x] = ((uint32_t)a << 24) | ((uint32_t)r << 16) |
			         ((uint32_t)gg << 8) | (uint32_t)b;
		}
	}

	g_object_unref(pixbuf);

	g->icon_buf = statusbar_buffer_from_argb32_raw((uint32_t *)argb, w, h);
	free(argb);

	if (g->icon_buf) {
		g->icon_w = w;
		g->icon_h = h;
	}
}

static void
pc_gaming_scan_steam(Monitor *m)
{
	char path[512];
	char icon_path[768];
	char *home;
	DIR *dir;
	struct dirent *ent;

	if (!m)
		return;

	home = getenv("HOME");
	if (!home)
		return;

	/* Scan Steam library cache for owned games */
	snprintf(path, sizeof(path), "%s/.local/share/Steam/appcache/librarycache", home);
	dir = opendir(path);
	if (!dir) {
		/* Try alternate path */
		snprintf(path, sizeof(path), "%s/.steam/steam/appcache/librarycache", home);
		dir = opendir(path);
	}
	if (!dir)
		return;

	while ((ent = readdir(dir)) != NULL) {
		/* Each directory is an app ID */
		if (ent->d_name[0] == '.')
			continue;

		/* Check if it's a valid number (app ID) */
		int valid = 1;
		for (int i = 0; ent->d_name[i]; i++) {
			if (ent->d_name[i] < '0' || ent->d_name[i] > '9') {
				valid = 0;
				break;
			}
		}
		if (!valid)
			continue;

		/* Only include games with library_600x900.jpg (portrait, 2:3 ratio) */
		snprintf(icon_path, sizeof(icon_path), "%s/%s/library_600x900.jpg", path, ent->d_name);
		if (access(icon_path, F_OK) != 0)
			continue;

		char launch[512];
		snprintf(launch, sizeof(launch), "steam steam://rungameid/%s", ent->d_name);

		/* Use app ID as name for now - Steam API can provide real names later */
		char name[256];
		snprintf(name, sizeof(name), "Steam Game %s", ent->d_name);

		/* acquired_time will be set from LastPlayed later, default to 0 */
		time_t acquired = 0;

		/* Store icon path in the game entry */
		GameEntry *g = calloc(1, sizeof(*g));
		if (!g)
			continue;

		snprintf(g->id, sizeof(g->id), "%s", ent->d_name);
		snprintf(g->name, sizeof(g->name), "%s", name);
		snprintf(g->icon_path, sizeof(g->icon_path), "%s", icon_path);
		snprintf(g->launch_cmd, sizeof(g->launch_cmd), "%s", launch);
		g->service = GAMING_SERVICE_STEAM;
		g->installed = 0;  /* In library but may not be installed */
		g->is_game = 1;    /* Assume game by default, API may set to 0 if DLC/tool */
		g->acquired_time = acquired;
		g->icon_buf = NULL;
		g->icon_loaded = 0;

		g->next = m->pc_gaming.games;
		m->pc_gaming.games = g;
		m->pc_gaming.game_count++;
	}
	closedir(dir);

	/* Also scan installed games from appmanifest files for names */
	const char *steam_paths[] = {
		"%s/.local/share/Steam/steamapps",
		"%s/.steam/steam/steamapps",
		NULL
	};

	for (int p = 0; steam_paths[p]; p++) {
		snprintf(path, sizeof(path), steam_paths[p], home);
		dir = opendir(path);
		if (!dir)
			continue;

		while ((ent = readdir(dir)) != NULL) {
			if (strncmp(ent->d_name, "appmanifest_", 12) != 0)
				continue;
			if (!strstr(ent->d_name, ".acf"))
				continue;

			char manifest_path[768];
			snprintf(manifest_path, sizeof(manifest_path), "%s/%s", path, ent->d_name);

			FILE *fp = fopen(manifest_path, "r");
			if (!fp)
				continue;

			char appid[32] = "";
			char name[256] = "";
			char line[1024];

			while (fgets(line, sizeof(line), fp)) {
				char *key, *val;

				key = strstr(line, "\"appid\"");
				if (key) {
					val = strchr(key + 7, '"');
					if (val) {
						val++;
						char *end = strchr(val, '"');
						if (end) {
							*end = '\0';
							snprintf(appid, sizeof(appid), "%s", val);
						}
					}
				}

				key = strstr(line, "\"name\"");
				if (key) {
					val = strchr(key + 6, '"');
					if (val) {
						val++;
						char *end = strchr(val, '"');
						if (end) {
							*end = '\0';
							snprintf(name, sizeof(name), "%s", val);
						}
					}
				}
			}
			fclose(fp);

			/* Update existing entry with real name and mark as installed */
			if (appid[0] && name[0]) {
				GameEntry *g = m->pc_gaming.games;
				while (g) {
					if (strcmp(g->id, appid) == 0) {
						snprintf(g->name, sizeof(g->name), "%s", name);
						g->installed = 1;
						break;
					}
					g = g->next;
				}
			}
		}
		closedir(dir);
	}

	/* Fetch names and types from Steam API (single batch request) */
	pc_gaming_fetch_steam_names_batch(m);

	/* Mark installed games as actual games (appmanifest = real game, not DLC/tool) */
	GameEntry *ge = m->pc_gaming.games;
	while (ge) {
		if (ge->service == GAMING_SERVICE_STEAM && ge->installed)
			ge->is_game = 1;
		ge = ge->next;
	}

	/* Load playtime data */
	pc_gaming_load_steam_playtime(m);

	/* Filter out non-games */
	pc_gaming_filter_non_games(m);

	/* Sort by acquisition date */
	pc_gaming_sort_by_acquired(m);
}

static void
pc_gaming_scan_heroic(Monitor *m)
{
	FILE *fp;
	char path[512];
	char *home;
	char *content = NULL;
	long fsize;
	char *p, *end;

	if (!m)
		return;

	home = getenv("HOME");
	if (!home)
		return;

	/* Check Heroic legendary library cache */
	snprintf(path, sizeof(path), "%s/.config/heroic/store_cache/legendary_library.json", home);
	fp = fopen(path, "r");
	if (fp) {
		fseek(fp, 0, SEEK_END);
		fsize = ftell(fp);
		fseek(fp, 0, SEEK_SET);

		if (fsize > 2 && fsize < 10 * 1024 * 1024) {
			content = malloc(fsize + 1);
			if (content) {
				if (fread(content, 1, fsize, fp) == (size_t)fsize) {
					content[fsize] = '\0';

					/* Simple JSON parsing for Epic games */
					p = content;
					while ((p = strstr(p, "\"app_name\"")) != NULL) {
						char app_name[128] = "";
						char title[256] = "";

						/* Extract app_name */
						char *val = strchr(p + 10, '"');
						if (val) {
							val++;
							end = strchr(val, '"');
							if (end) {
								size_t len = end - val;
								if (len < sizeof(app_name)) {
									memcpy(app_name, val, len);
									app_name[len] = '\0';
								}
							}
						}

						/* Find title nearby */
						char *title_key = strstr(p, "\"title\"");
						if (title_key && title_key - p < 500) {
							val = strchr(title_key + 7, '"');
							if (val) {
								val++;
								end = strchr(val, '"');
								if (end) {
									size_t len = end - val;
									if (len < sizeof(title)) {
										memcpy(title, val, len);
										title[len] = '\0';
									}
								}
							}
						}

						if (app_name[0] && title[0]) {
							char launch[512];
							char icon[512] = "";
							snprintf(launch, sizeof(launch), "heroic --no-gui --launch %s", app_name);
							/* Find icon from Heroic image cache */
							snprintf(icon, sizeof(icon), "%s/.config/heroic/images-cache/%s/art_square.jpg", home, app_name);
							if (access(icon, F_OK) != 0) {
								snprintf(icon, sizeof(icon), "%s/.config/heroic/images-cache/%s/logo.png", home, app_name);
								if (access(icon, F_OK) != 0)
									icon[0] = '\0';
							}
							pc_gaming_add_game(m, app_name, title, launch, icon, GAMING_SERVICE_HEROIC, 0);
						}

						p++;
					}
				}
				free(content);
			}
		}
		fclose(fp);
	}

	/* Check GOG library cache */
	snprintf(path, sizeof(path), "%s/.config/heroic/store_cache/gog_library.json", home);
	fp = fopen(path, "r");
	if (fp) {
		fseek(fp, 0, SEEK_END);
		fsize = ftell(fp);
		fseek(fp, 0, SEEK_SET);

		if (fsize > 2 && fsize < 10 * 1024 * 1024) {
			content = malloc(fsize + 1);
			if (content) {
				if (fread(content, 1, fsize, fp) == (size_t)fsize) {
					content[fsize] = '\0';

					/* Simple JSON parsing for GOG games */
					p = content;
					while ((p = strstr(p, "\"app_name\"")) != NULL) {
						char app_name[128] = "";
						char title[256] = "";

						char *val = strchr(p + 10, '"');
						if (val) {
							val++;
							end = strchr(val, '"');
							if (end) {
								size_t len = end - val;
								if (len < sizeof(app_name)) {
									memcpy(app_name, val, len);
									app_name[len] = '\0';
								}
							}
						}

						char *title_key = strstr(p, "\"title\"");
						if (title_key && title_key - p < 500) {
							val = strchr(title_key + 7, '"');
							if (val) {
								val++;
								end = strchr(val, '"');
								if (end) {
									size_t len = end - val;
									if (len < sizeof(title)) {
										memcpy(title, val, len);
										title[len] = '\0';
									}
								}
							}
						}

						if (app_name[0] && title[0]) {
							char launch[512];
							char icon[512] = "";
							snprintf(launch, sizeof(launch), "heroic --no-gui --launch %s", app_name);
							/* Find icon from Heroic image cache */
							snprintf(icon, sizeof(icon), "%s/.config/heroic/images-cache/%s/art_square.jpg", home, app_name);
							if (access(icon, F_OK) != 0) {
								snprintf(icon, sizeof(icon), "%s/.config/heroic/images-cache/%s/logo.png", home, app_name);
								if (access(icon, F_OK) != 0)
									icon[0] = '\0';
							}
							pc_gaming_add_game(m, app_name, title, launch, icon, GAMING_SERVICE_HEROIC, 0);
						}

						p++;
					}
				}
				free(content);
			}
		}
		fclose(fp);
	}
}

static void
pc_gaming_refresh_games(Monitor *m)
{
	if (!m)
		return;

	pc_gaming_free_games(m);

	/* Try to load from cache first for fast startup */
	if (pc_gaming_load_cache(m)) {
		/* Always filter after loading - ensures name-based filtering works */
		pc_gaming_filter_non_games(m);
		pc_gaming_sort_by_acquired(m);
		m->pc_gaming.last_refresh_ms = monotonic_msec();
		m->pc_gaming.needs_refresh = 0;
		return;
	}

	/* Cache miss or stale - scan services */
	wlr_log(WLR_INFO, "Scanning game libraries...");

	/* Scan each enabled service */
	if (gaming_service_enabled[GAMING_SERVICE_STEAM])
		pc_gaming_scan_steam(m);
	if (gaming_service_enabled[GAMING_SERVICE_HEROIC])
		pc_gaming_scan_heroic(m);
	/* TODO: Add Lutris and Bottles scanning */

	/* Save to cache for next time */
	pc_gaming_save_cache(m);

	m->pc_gaming.last_refresh_ms = monotonic_msec();
	m->pc_gaming.needs_refresh = 0;
}

/* Callback when games cache file changes - triggers realtime UI update */
static int
pc_gaming_cache_inotify_cb(int fd, uint32_t mask, void *data)
{
	char buf[4096] __attribute__((aligned(__alignof__(struct inotify_event))));
	Monitor *m;
	int len;

	(void)mask;
	(void)data;

	/* Drain inotify events */
	while ((len = read(fd, buf, sizeof(buf))) > 0) {
		/* Just drain - we only care that something changed */
	}

	/* Mark all monitors as needing refresh */
	wl_list_for_each(m, &mons, link) {
		m->pc_gaming.needs_refresh = 1;
		/* If PC gaming view is visible, refresh immediately */
		if (m->pc_gaming.visible) {
			pc_gaming_refresh_games(m);
			pc_gaming_render(m);
		}
	}

	wlr_log(WLR_INFO, "Games cache updated, refreshing PC gaming view");
	return 0;
}

/* Set up inotify watch on games cache file */
static void
pc_gaming_cache_watch_setup(void)
{
	char cache_path[512];
	char cache_dir[512];
	char *home = getenv("HOME");

	if (!home)
		return;

	snprintf(cache_path, sizeof(cache_path), "%s" PC_GAMING_CACHE_FILE, home);
	snprintf(cache_dir, sizeof(cache_dir), "%s/.cache/nixlytile", home);

	/* Create directory if it doesn't exist */
	mkdir(cache_dir, 0755);

	pc_gaming_cache_inotify_fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC);
	if (pc_gaming_cache_inotify_fd < 0) {
		wlr_log(WLR_ERROR, "Failed to create inotify for games cache");
		return;
	}

	/* Watch the directory for new/modified files */
	pc_gaming_cache_inotify_wd = inotify_add_watch(pc_gaming_cache_inotify_fd,
		cache_dir, IN_CLOSE_WRITE | IN_MOVED_TO);
	if (pc_gaming_cache_inotify_wd < 0) {
		wlr_log(WLR_ERROR, "Failed to add inotify watch for games cache");
		close(pc_gaming_cache_inotify_fd);
		pc_gaming_cache_inotify_fd = -1;
		return;
	}

	pc_gaming_cache_event = wl_event_loop_add_fd(wl_display_get_event_loop(dpy),
		pc_gaming_cache_inotify_fd, WL_EVENT_READABLE,
		pc_gaming_cache_inotify_cb, NULL);

	wlr_log(WLR_INFO, "Games cache inotify watch set up");
}

/* Ensure selected tile is visible by adjusting scroll */
static void
pc_gaming_ensure_visible(Monitor *m)
{
	PcGamingView *pg;
	int padding = PC_GAMING_PADDING;
	int gap = PC_GAMING_TILE_GAP;

	if (!m)
		return;

	pg = &m->pc_gaming;
	if (!pg->visible || pg->cols < 1)
		return;

	/* Calculate tile dimensions (5 columns) */
	int grid_width = pg->width - 2 * padding;
	int grid_height = pg->height - 2 * padding;
	int tile_w = (grid_width - (4 * gap)) / 5;
	int tile_h = (tile_w * 3) / 2;  /* Steam library images are 600x900 (2:3 ratio) */

	int selected_row = pg->selected_idx / pg->cols;
	int tile_top = selected_row * (tile_h + gap);
	int tile_bottom = tile_top + tile_h;

	/* Smooth scroll - adjust if selected tile is outside visible area */
	if (tile_top < pg->scroll_offset) {
		/* Tile is above visible area - scroll up */
		pg->scroll_offset = tile_top;
	} else if (tile_bottom > pg->scroll_offset + grid_height) {
		/* Tile is below visible area - scroll down */
		pg->scroll_offset = tile_bottom - grid_height;
	}

	/* Clamp scroll offset */
	int total_rows = (pg->game_count + pg->cols - 1) / pg->cols;
	int max_scroll = total_rows * (tile_h + gap) - grid_height;
	if (max_scroll < 0)
		max_scroll = 0;
	if (pg->scroll_offset < 0)
		pg->scroll_offset = 0;
	if (pg->scroll_offset > max_scroll)
		pg->scroll_offset = max_scroll;
}

static void
pc_gaming_render(Monitor *m)
{
	PcGamingView *pg;
	struct wlr_scene_node *node, *tmp;
	int padding = PC_GAMING_PADDING;
	int gap = PC_GAMING_TILE_GAP;
	float tile_color[4] = {0.15f, 0.15f, 0.18f, 0.9f};
	float selected_border[4] = {0.3f, 0.6f, 1.0f, 1.0f};
	float text_color[4] = {1.0f, 1.0f, 1.0f, 1.0f};
	float name_bg[4] = {0.0f, 0.0f, 0.0f, 0.7f};

	if (!m || !statusfont.font)
		return;

	pg = &m->pc_gaming;
	if (!pg->visible || !pg->tree)
		return;

	/* Refresh games if needed */
	if (pg->needs_refresh || !pg->games) {
		pc_gaming_refresh_games(m);
	}

	/* Clear previous content */
	wl_list_for_each_safe(node, tmp, &pg->tree->children, link) {
		wlr_scene_node_destroy(node);
	}
	pg->bg = NULL;
	pg->grid = NULL;
	pg->sidebar = NULL;

	/* Calculate grid dimensions */
	int grid_width = pg->width - 2 * padding;
	int grid_height = pg->height - 2 * padding;

	/* Fixed 5 columns - calculate tile size based on width */
	pg->cols = 5;
	int tile_w = (grid_width - ((pg->cols - 1) * gap)) / pg->cols;
	int tile_h = (tile_w * 3) / 2;  /* Steam library images are 600x900 (2:3 ratio) */
	int name_bar_h = 28;

	/* Ensure selected tile is visible */
	pc_gaming_ensure_visible(m);

	/* Create grid */
	pg->grid = wlr_scene_tree_create(pg->tree);
	if (!pg->grid)
		return;

	wlr_scene_node_set_position(&pg->grid->node, padding, padding);

	/* Draw game tiles */
	GameEntry *g = pg->games;
	int idx = 0;
	int visible_start = pg->scroll_offset / (tile_h + gap);
	int visible_rows = (grid_height + gap) / (tile_h + gap) + 2;

	while (g) {
		int row = idx / pg->cols;
		int col = idx % pg->cols;

		/* Only render visible tiles */
		if (row >= visible_start && row < visible_start + visible_rows) {
			int tx = col * (tile_w + gap);
			int ty = row * (tile_h + gap) - pg->scroll_offset;

			/* Skip if outside visible area */
			if (ty + tile_h > 0 && ty < grid_height) {
				int is_selected = (idx == pg->selected_idx);
				int glow_size = 8;  /* Glow/hover effect size */

				struct wlr_scene_tree *tile_tree = wlr_scene_tree_create(pg->grid);
				if (!tile_tree) {
					g = g->next;
					idx++;
					continue;
				}

				/* Position with offset for glow when selected */
				if (is_selected) {
					wlr_scene_node_set_position(&tile_tree->node, tx - glow_size, ty - glow_size);

					/* Draw outer glow layers (gradient effect) */
					float glow1[4] = {0.2f, 0.5f, 1.0f, 0.15f};  /* Outer glow */
					float glow2[4] = {0.3f, 0.6f, 1.0f, 0.25f};  /* Middle glow */
					float glow3[4] = {0.4f, 0.7f, 1.0f, 0.4f};   /* Inner glow */

					/* Outer glow */
					drawrect(tile_tree, 0, 0, tile_w + glow_size * 2, tile_h + glow_size * 2, glow1);
					/* Middle glow */
					drawrect(tile_tree, 2, 2, tile_w + glow_size * 2 - 4, tile_h + glow_size * 2 - 4, glow2);
					/* Inner glow */
					drawrect(tile_tree, 4, 4, tile_w + glow_size * 2 - 8, tile_h + glow_size * 2 - 8, glow3);

					/* Draw tile background inside glow */
					drawrect(tile_tree, glow_size, glow_size, tile_w, tile_h, tile_color);
				} else {
					wlr_scene_node_set_position(&tile_tree->node, tx, ty);
					/* Draw tile background */
					drawrect(tile_tree, 0, 0, tile_w, tile_h, tile_color);
				}

				int img_offset = is_selected ? glow_size : 0;

				/* Load and display game icon */
				if (!g->icon_loaded) {
					pc_gaming_load_game_icon(g, tile_w, tile_h - name_bar_h);
				}
				if (g->icon_buf) {
					struct wlr_scene_buffer *img = wlr_scene_buffer_create(tile_tree, g->icon_buf);
					if (img) {
						wlr_scene_node_set_position(&img->node, img_offset, img_offset);
					}
				}

				/* Installation progress bar */
				if (g->is_installing) {
					int bar_h = 6;
					int bar_y = img_offset + tile_h - name_bar_h - bar_h;
					int bar_w = tile_w;
					int progress_w = (bar_w * g->install_progress) / 100;

					/* Background bar (dark) */
					float bar_bg[4] = {0.1f, 0.1f, 0.1f, 0.9f};
					drawrect(tile_tree, img_offset, bar_y, bar_w, bar_h, bar_bg);

					/* Progress bar (blue gradient) */
					if (progress_w > 0) {
						float bar_fg[4] = {0.2f, 0.6f, 1.0f, 1.0f};
						drawrect(tile_tree, img_offset, bar_y, progress_w, bar_h, bar_fg);
					}

					/* Progress text */
					char progress_text[16];
					snprintf(progress_text, sizeof(progress_text), "%d%%", g->install_progress);
					int text_w = status_text_width(progress_text);
					struct wlr_scene_tree *progress_tree = wlr_scene_tree_create(tile_tree);
					if (progress_tree) {
						wlr_scene_node_set_position(&progress_tree->node,
							img_offset + (bar_w - text_w) / 2, bar_y - 2);
						StatusModule mod = {0};
						mod.tree = progress_tree;
						float white[4] = {1.0f, 1.0f, 1.0f, 1.0f};
						tray_render_label(&mod, progress_text, 0, 14, white);
					}
				}

				/* Selection highlight border */
				if (is_selected) {
					int bw = 3;
					float bright_border[4] = {0.4f, 0.75f, 1.0f, 1.0f};
					drawrect(tile_tree, glow_size, glow_size, tile_w, bw, bright_border);
					drawrect(tile_tree, glow_size, glow_size + tile_h - bw, tile_w, bw, bright_border);
					drawrect(tile_tree, glow_size, glow_size, bw, tile_h, bright_border);
					drawrect(tile_tree, glow_size + tile_w - bw, glow_size, bw, tile_h, bright_border);
				}

				/* Name bar at bottom of tile */
				float active_name_bg[4] = {0.1f, 0.3f, 0.5f, 0.85f};  /* Highlighted name bar */
				drawrect(tile_tree, img_offset, img_offset + tile_h - name_bar_h, tile_w, name_bar_h,
				         is_selected ? active_name_bg : name_bg);

				/* Game name */
				struct wlr_scene_tree *name_tree = wlr_scene_tree_create(tile_tree);
				if (name_tree) {
					wlr_scene_node_set_position(&name_tree->node, img_offset, img_offset + tile_h - name_bar_h);
					StatusModule mod = {0};
					mod.tree = name_tree;

					/* Truncate name to fit */
					char short_name[64];
					int max_chars = (tile_w - 10) / 8;
					if (max_chars > (int)sizeof(short_name) - 1)
						max_chars = sizeof(short_name) - 1;
					if (max_chars < 1)
						max_chars = 1;
					strncpy(short_name, g->name, max_chars);
					short_name[max_chars] = '\0';
					if (strlen(g->name) > (size_t)max_chars && max_chars > 3) {
						short_name[max_chars - 1] = '.';
						short_name[max_chars - 2] = '.';
						short_name[max_chars - 3] = '.';
					}

					int label_w = status_text_width(short_name);
					int label_x = (tile_w - label_w) / 2;
					if (label_x < 4) label_x = 4;
					tray_render_label(&mod, short_name, label_x, name_bar_h,
					                  is_selected ? selected_border : text_color);
				}
			}
		}

		g = g->next;
		idx++;
	}

	/* Show "No games found" if empty */
	if (pg->game_count == 0) {
		struct wlr_scene_tree *empty_tree = wlr_scene_tree_create(pg->grid);
		if (empty_tree) {
			wlr_scene_node_set_position(&empty_tree->node, grid_width / 2 - 100, grid_height / 2);
			StatusModule mod = {0};
			mod.tree = empty_tree;
			tray_render_label(&mod, "No games found", 0, 30, text_color);
		}
	}
}

/* Timer callback for updating installation progress every 2 seconds */
static int
pc_gaming_install_timer_cb(void *data)
{
	Monitor *m;
	int any_installing = 0;

	(void)data;

	/* Find monitor with visible PC gaming view */
	m = pc_gaming_visible_monitor();
	if (!m || !m->pc_gaming.visible)
		return 0;

	/* Update installation status */
	pc_gaming_update_install_status(m);

	/* Check if any games are still installing */
	GameEntry *g = m->pc_gaming.games;
	while (g) {
		if (g->is_installing) {
			any_installing = 1;
			break;
		}
		g = g->next;
	}

	/* Re-render to show updated progress */
	pc_gaming_render(m);

	/* Reschedule timer if any games are installing */
	if (any_installing && pc_gaming_install_timer)
		wl_event_source_timer_update(pc_gaming_install_timer, 2000);

	return 0;
}

static void
pc_gaming_start_install_timer(void)
{
	if (!event_loop)
		return;
	if (!pc_gaming_install_timer)
		pc_gaming_install_timer = wl_event_loop_add_timer(event_loop,
			pc_gaming_install_timer_cb, NULL);
	if (pc_gaming_install_timer)
		wl_event_source_timer_update(pc_gaming_install_timer, 2000);
}

static void
pc_gaming_stop_install_timer(void)
{
	if (pc_gaming_install_timer)
		wl_event_source_timer_update(pc_gaming_install_timer, 0);
}

static void
pc_gaming_show(Monitor *m)
{
	PcGamingView *pg;

	if (!m)
		return;

	pc_gaming_hide_all();
	gamepad_menu_hide_all();

	pg = &m->pc_gaming;
	pg->selected_idx = 0;
	pg->hover_idx = -1;
	pg->scroll_offset = 0;
	pg->service_filter = -1;
	pg->needs_refresh = 1;
	pg->view_tag = 1 << 3;  /* Tag 4 = bit 3 */

	/* Fullscreen on monitor - directly on background */
	pg->width = m->m.width;
	pg->height = m->m.height;
	pg->visible = 1;

	/* Use LyrBg+1 to be just above wallpaper but below windows */
	if (!pg->tree)
		pg->tree = wlr_scene_tree_create(layers[LyrBg]);
	if (!pg->tree)
		return;

	/* Position at monitor origin */
	wlr_scene_node_set_position(&pg->tree->node, m->m.x, m->m.y);
	wlr_scene_node_set_enabled(&pg->tree->node, 1);
	wlr_scene_node_raise_to_top(&pg->tree->node);

	/* Hide mouse cursor in PC gaming view */
	wlr_cursor_set_surface(cursor, NULL, 0, 0);

	/* Update install status and start timer */
	pc_gaming_update_install_status(m);
	pc_gaming_start_install_timer();

	pc_gaming_render(m);
}

static void
pc_gaming_hide(Monitor *m)
{
	PcGamingView *pg;

	if (!m)
		return;

	pg = &m->pc_gaming;
	if (!pg->visible)
		return;

	pg->visible = 0;
	if (pg->tree)
		wlr_scene_node_set_enabled(&pg->tree->node, 0);

	/* Stop install progress timer */
	pc_gaming_stop_install_timer();
}

static void
pc_gaming_hide_all(void)
{
	Monitor *m;

	wl_list_for_each(m, &mons, link) {
		pc_gaming_hide(m);
	}
}

static Monitor *
pc_gaming_visible_monitor(void)
{
	Monitor *m;

	wl_list_for_each(m, &mons, link) {
		if (m->pc_gaming.visible)
			return m;
	}
	return NULL;
}

static void
pc_gaming_launch_game(Monitor *m)
{
	PcGamingView *pg;
	GameEntry *g;
	int idx = 0;
	const char *gpu_params = NULL;
	GpuVendor gpu_vendor = GPU_VENDOR_UNKNOWN;
	char merged_options[1024];
	pid_t pid;

	if (!m)
		return;

	pg = &m->pc_gaming;
	if (!pg->visible || pg->selected_idx < 0)
		return;

	/* Don't launch if install popup is visible */
	if (pg->install_popup_visible)
		return;

	g = pg->games;
	while (g && idx < pg->selected_idx) {
		g = g->next;
		idx++;
	}

	if (!g || !g->launch_cmd[0])
		return;

	/* Check if game is installed */
	if (!g->installed) {
		/* Show install popup */
		pc_gaming_install_popup_show(m, g);
		return;
	}

	/* Get detected GPU vendor */
	if (discrete_gpu_idx >= 0 && discrete_gpu_idx < detected_gpu_count)
		gpu_vendor = detected_gpus[discrete_gpu_idx].vendor;

	/* Get GPU-specific launch params from hardcoded table */
	gpu_params = get_game_launch_params(g->id, gpu_vendor);

	/* Game is installed - launch it */
	wlr_log(WLR_INFO, "Launching game: %s (id=%s, GPU=%s, params=%s)", g->name, g->id,
		gpu_vendor == GPU_VENDOR_NVIDIA ? "NVIDIA" :
		gpu_vendor == GPU_VENDOR_AMD ? "AMD" :
		gpu_vendor == GPU_VENDOR_INTEL ? "Intel" : "Unknown",
		gpu_params ? gpu_params : "none");

	/* Fork and exec directly - spawn() doesn't work with struct member strings */
	pid = fork();
	if (pid == 0) {
		setsid();
		/* Set discrete GPU environment for gaming */
		set_dgpu_env();

		/* Set Steam env vars if this is a Steam game (uses steam:// protocol) */
		if (g->service == GAMING_SERVICE_STEAM || is_steam_cmd(g->launch_cmd)) {
			const char *user_options;

			set_steam_env();

			/* Get user's existing launch options (Steam stores them per-game)
			 * We can't read Steam's config here, but STEAM_GAME_LAUNCH_OPTIONS
			 * gets merged with user options by Steam itself.
			 * We build merged options that won't duplicate user settings. */

			/* For now, we don't have access to user's Steam launch options at runtime,
			 * but Steam will merge STEAM_GAME_LAUNCH_OPTIONS with user-set options.
			 * Our build_merged_launch_options ensures we don't add duplicates if
			 * user sets them in Steam. Steam applies user options AFTER env var. */

			user_options = getenv("STEAM_USER_LAUNCH_OPTIONS"); /* Future: read from Steam config */

			if (gpu_params && gpu_params[0]) {
				build_merged_launch_options(user_options, gpu_params,
					merged_options, sizeof(merged_options));
				setenv("STEAM_GAME_LAUNCH_OPTIONS", merged_options, 1);
				wlr_log(WLR_INFO, "Set STEAM_GAME_LAUNCH_OPTIONS=%s", merged_options);
			}

			/* If Steam isn't running, start it with GPU flags then run the game
			 * This ensures Steam UI has full GPU acceleration */
			if (!is_process_running("steam")) {
				char cmd[512];
				snprintf(cmd, sizeof(cmd),
					"steam -cef-force-gpu -cef-disable-sandbox %s",
					strstr(g->launch_cmd, "steam://") ? strstr(g->launch_cmd, "steam://") : "");
				wlr_log(WLR_INFO, "Starting Steam with GPU flags: %s", cmd);
				execl("/bin/sh", "sh", "-c", cmd, (char *)NULL);
				_exit(127);
			}
		} else if (gpu_params && gpu_params[0]) {
			/* Non-Steam game: prepend GPU params to command
			 * Replace %command% with actual game command, or prepend if no placeholder */
			char full_cmd[2048];
			const char *placeholder = strstr(gpu_params, "%command%");
			if (placeholder) {
				/* Replace %command% with the actual launch command */
				int prefix_len = placeholder - gpu_params;
				snprintf(full_cmd, sizeof(full_cmd), "%.*s%s%s",
					prefix_len, gpu_params,
					g->launch_cmd,
					placeholder + 9);  /* 9 = strlen("%command%") */
			} else {
				/* Just prepend params to command */
				snprintf(full_cmd, sizeof(full_cmd), "%s %s", gpu_params, g->launch_cmd);
			}
			wlr_log(WLR_INFO, "Launching with GPU params: %s", full_cmd);
			execl("/bin/sh", "sh", "-c", full_cmd, (char *)NULL);
			_exit(127);
		}

		execl("/bin/sh", "sh", "-c", g->launch_cmd, (char *)NULL);
		_exit(127);
	}
	pc_gaming_hide(m);
}

static void
pc_gaming_install_popup_show(Monitor *m, GameEntry *g)
{
	PcGamingView *pg;
	float dim_color[4] = {0.0f, 0.0f, 0.0f, 0.7f};

	if (!m || !g)
		return;

	pg = &m->pc_gaming;

	/* Store game info */
	snprintf(pg->install_game_id, sizeof(pg->install_game_id), "%s", g->id);
	snprintf(pg->install_game_name, sizeof(pg->install_game_name), "%s", g->name);
	pg->install_game_service = g->service;
	pg->install_popup_selected = 0;  /* Default to "Install" */
	pg->install_popup_visible = 1;

	/* Create dim overlay */
	if (!pg->install_dim)
		pg->install_dim = wlr_scene_tree_create(layers[LyrBlock]);
	if (pg->install_dim) {
		struct wlr_scene_node *node, *tmp;
		wl_list_for_each_safe(node, tmp, &pg->install_dim->children, link)
			wlr_scene_node_destroy(node);
		wlr_scene_node_set_position(&pg->install_dim->node, m->m.x, m->m.y);
		drawrect(pg->install_dim, 0, 0, m->m.width, m->m.height, dim_color);
		wlr_scene_node_set_enabled(&pg->install_dim->node, 1);
	}

	/* Create popup */
	if (!pg->install_popup)
		pg->install_popup = wlr_scene_tree_create(layers[LyrBlock]);
	if (pg->install_popup) {
		wlr_scene_node_set_enabled(&pg->install_popup->node, 1);
		wlr_scene_node_raise_to_top(&pg->install_popup->node);
	}

	pc_gaming_install_popup_render(m);
}

static void
pc_gaming_install_popup_hide(Monitor *m)
{
	PcGamingView *pg;

	if (!m)
		return;

	pg = &m->pc_gaming;
	pg->install_popup_visible = 0;

	if (pg->install_dim)
		wlr_scene_node_set_enabled(&pg->install_dim->node, 0);
	if (pg->install_popup)
		wlr_scene_node_set_enabled(&pg->install_popup->node, 0);
}

static void
pc_gaming_install_popup_render(Monitor *m)
{
	PcGamingView *pg;
	struct wlr_scene_node *node, *tmp;
	int popup_w = 350, popup_h = 150;
	int x, y;
	float bg_color[4] = {0.12f, 0.12f, 0.14f, 0.98f};
	float border_color[4] = {0.35f, 0.35f, 0.4f, 1.0f};
	float button_color[4] = {0.18f, 0.18f, 0.22f, 1.0f};
	float selected_color[4] = {0.25f, 0.5f, 0.9f, 1.0f};
	float text_color[4] = {1.0f, 1.0f, 1.0f, 1.0f};

	if (!m || !statusfont.font)
		return;

	pg = &m->pc_gaming;
	if (!pg->install_popup_visible || !pg->install_popup)
		return;

	/* Clear previous content */
	wl_list_for_each_safe(node, tmp, &pg->install_popup->children, link)
		wlr_scene_node_destroy(node);

	/* Center popup on screen */
	x = m->m.x + (m->m.width - popup_w) / 2;
	y = m->m.y + (m->m.height - popup_h) / 2;
	wlr_scene_node_set_position(&pg->install_popup->node, x, y);

	/* Background */
	drawrect(pg->install_popup, 0, 0, popup_w, popup_h, bg_color);

	/* Border */
	drawrect(pg->install_popup, 0, 0, popup_w, 2, border_color);
	drawrect(pg->install_popup, 0, popup_h - 2, popup_w, 2, border_color);
	drawrect(pg->install_popup, 0, 0, 2, popup_h, border_color);
	drawrect(pg->install_popup, popup_w - 2, 0, 2, popup_h, border_color);

	/* Title - game name (truncated) */
	{
		char title[64];
		snprintf(title, sizeof(title), "%.40s", pg->install_game_name);
		if (strlen(pg->install_game_name) > 40)
			strcat(title, "...");
		int title_w = status_text_width(title);
		int title_x = (popup_w - title_w) / 2;
		struct wlr_scene_tree *title_tree = wlr_scene_tree_create(pg->install_popup);
		if (title_tree) {
			wlr_scene_node_set_position(&title_tree->node, title_x, 15);
			StatusModule mod = {0};
			mod.tree = title_tree;
			tray_render_label(&mod, title, 0, 30, text_color);
		}
	}

	/* "Not installed" text */
	{
		const char *msg = "Spillet er ikke installert";
		int msg_w = status_text_width(msg);
		int msg_x = (popup_w - msg_w) / 2;
		float gray[4] = {0.7f, 0.7f, 0.7f, 1.0f};
		struct wlr_scene_tree *msg_tree = wlr_scene_tree_create(pg->install_popup);
		if (msg_tree) {
			wlr_scene_node_set_position(&msg_tree->node, msg_x, 55);
			StatusModule mod = {0};
			mod.tree = msg_tree;
			tray_render_label(&mod, msg, 0, 25, gray);
		}
	}

	/* Buttons */
	int btn_w = 120, btn_h = 40;
	int btn_y = popup_h - 60;
	int install_x = popup_w / 2 - btn_w - 15;
	int close_x = popup_w / 2 + 15;

	/* Install button */
	drawrect(pg->install_popup, install_x, btn_y, btn_w, btn_h,
		pg->install_popup_selected == 0 ? selected_color : button_color);
	{
		const char *label = "Install";
		int label_w = status_text_width(label);
		struct wlr_scene_tree *btn_tree = wlr_scene_tree_create(pg->install_popup);
		if (btn_tree) {
			wlr_scene_node_set_position(&btn_tree->node, install_x + (btn_w - label_w) / 2, btn_y);
			StatusModule mod = {0};
			mod.tree = btn_tree;
			tray_render_label(&mod, label, 0, btn_h, text_color);
		}
	}

	/* Close button */
	drawrect(pg->install_popup, close_x, btn_y, btn_w, btn_h,
		pg->install_popup_selected == 1 ? selected_color : button_color);
	{
		const char *label = "Close";
		int label_w = status_text_width(label);
		struct wlr_scene_tree *btn_tree = wlr_scene_tree_create(pg->install_popup);
		if (btn_tree) {
			wlr_scene_node_set_position(&btn_tree->node, close_x + (btn_w - label_w) / 2, btn_y);
			StatusModule mod = {0};
			mod.tree = btn_tree;
			tray_render_label(&mod, label, 0, btn_h, text_color);
		}
	}
}

static int
pc_gaming_install_popup_handle_button(Monitor *m, int button, int value)
{
	PcGamingView *pg;

	if (!m)
		return 0;

	pg = &m->pc_gaming;
	if (!pg->install_popup_visible)
		return 0;

	/* Consume all button releases when popup is open */
	if (value != 1)
		return 1;

	switch (button) {
	case BTN_DPAD_LEFT:
		if (pg->install_popup_selected > 0) {
			pg->install_popup_selected--;
			pc_gaming_install_popup_render(m);
		}
		return 1;
	case BTN_DPAD_RIGHT:
		if (pg->install_popup_selected < 1) {
			pg->install_popup_selected++;
			pc_gaming_install_popup_render(m);
		}
		return 1;
	case BTN_DPAD_UP:
	case BTN_DPAD_DOWN:
		/* Consume but ignore - only left/right changes selection */
		return 1;
	case BTN_SOUTH:  /* A button - confirm */
		if (pg->install_popup_selected == 0) {
			/* Install via the appropriate client */
			char cmd[1024];
			cmd[0] = '\0';
			switch (pg->install_game_service) {
			case GAMING_SERVICE_STEAM:
				/* Use Steam client directly - steamcmd installs to wrong dir and doesn't update manifests */
				snprintf(cmd, sizeof(cmd), "steam steam://install/%s", pg->install_game_id);
				break;
			case GAMING_SERVICE_HEROIC:
				snprintf(cmd, sizeof(cmd), "heroic heroic://install/%s", pg->install_game_id);
				break;
			case GAMING_SERVICE_LUTRIS:
				snprintf(cmd, sizeof(cmd), "lutris lutris:install/%s", pg->install_game_id);
				break;
			case GAMING_SERVICE_BOTTLES:
				snprintf(cmd, sizeof(cmd), "bottles");
				break;
			default:
				break;
			}
			if (cmd[0]) {
				wlr_log(WLR_INFO, "Installing game via %s: %s",
					gaming_service_names[pg->install_game_service], pg->install_game_name);
				/* Mark game as installing immediately so progress bar shows */
				GameEntry *g = pg->games;
				while (g) {
					if (strcmp(g->id, pg->install_game_id) == 0) {
						g->is_installing = 1;
						g->install_progress = 0;
						break;
					}
					g = g->next;
				}
				/* Fork and exec directly - spawn() doesn't work with stack strings */
				pid_t pid = fork();
				if (pid == 0) {
					setsid();
					execl("/bin/sh", "sh", "-c", cmd, (char *)NULL);
					_exit(127);
				}
				/* Start/restart the install timer */
				pc_gaming_start_install_timer();
			}
		}
		pc_gaming_install_popup_hide(m);
		/* Re-render to show progress bar immediately */
		pc_gaming_render(m);
		return 1;
	case BTN_EAST:   /* B button - close */
		pc_gaming_install_popup_hide(m);
		return 1;
	default:
		/* Consume all other buttons when popup is open */
		return 1;
	}

	return 1;
}

static void
pc_gaming_scroll(Monitor *m, int delta)
{
	PcGamingView *pg;
	int max_scroll;
	int rows;

	if (!m)
		return;

	pg = &m->pc_gaming;
	if (!pg->visible)
		return;

	rows = (pg->game_count + pg->cols - 1) / pg->cols;
	max_scroll = rows * (PC_GAMING_TILE_HEIGHT + PC_GAMING_TILE_GAP) - (pg->height - 40);
	if (max_scroll < 0)
		max_scroll = 0;

	pg->scroll_offset += delta;
	if (pg->scroll_offset < 0)
		pg->scroll_offset = 0;
	if (pg->scroll_offset > max_scroll)
		pg->scroll_offset = max_scroll;

	pc_gaming_render(m);
}

static int
pc_gaming_handle_button(Monitor *m, int button, int value)
{
	PcGamingView *pg;
	Client *popup_client;

	if (!m)
		return 0;

	pg = &m->pc_gaming;
	/* Only handle input if view is visible AND on current tag */
	if (!htpc_view_is_active(m, pg->view_tag, pg->visible))
		return 0;

	/* If a window has focus (e.g. Steam dialog), click it and return to PC gaming */
	popup_client = focustop(m);
	if (popup_client && !popup_client->isfullscreen) {
		/* On A button press, click center of popup and dismiss it */
		if (value == 1 && button == BTN_SOUTH) {
			double cx = popup_client->geom.x + popup_client->geom.width / 2.0;
			double cy = popup_client->geom.y + popup_client->geom.height / 2.0;
			uint32_t time_msec = (uint32_t)(monotonic_msec() & 0xFFFFFFFF);
			wlr_cursor_warp(cursor, NULL, cx, cy);
			/* Update pointer focus and send click */
			struct wlr_surface *surface = client_surface(popup_client);
			if (surface) {
				double sx = popup_client->geom.width / 2.0;
				double sy = popup_client->geom.height / 2.0;
				wlr_seat_pointer_notify_enter(seat, surface, sx, sy);
				wlr_seat_pointer_notify_motion(seat, time_msec, sx, sy);
				/* Send click (press + release) */
				wlr_seat_pointer_notify_button(seat, time_msec, BTN_LEFT, WL_POINTER_BUTTON_STATE_PRESSED);
				wlr_seat_pointer_notify_button(seat, time_msec + 1, BTN_LEFT, WL_POINTER_BUTTON_STATE_RELEASED);
			}
			/* Unfocus popup and return to PC gaming */
			focusclient(NULL, 0);
			wlr_seat_pointer_notify_clear_focus(seat);
			return 1;
		}
		/* On B button, just dismiss popup without clicking */
		if (value == 1 && button == BTN_EAST) {
			focusclient(NULL, 0);
			wlr_seat_pointer_notify_clear_focus(seat);
			return 1;
		}
		return 0;
	}

	/* Handle install popup first if visible */
	if (pg->install_popup_visible)
		return pc_gaming_install_popup_handle_button(m, button, value);

	/* Only handle button press */
	if (value != 1)
		return 0;

	switch (button) {
	case BTN_SOUTH:  /* A button - launch game */
		pc_gaming_launch_game(m);
		return 1;
	case BTN_EAST:   /* B button - close PC gaming */
		pc_gaming_hide(m);
		return 1;
	/* BTN_MODE (guide) handled in gamepad_menu_handle_button to show menu overlay */
	case BTN_DPAD_UP:
		if (pg->selected_idx >= pg->cols) {
			pg->selected_idx -= pg->cols;
			pc_gaming_render(m);
		}
		return 1;
	case BTN_DPAD_DOWN:
		if (pg->selected_idx + pg->cols < pg->game_count) {
			pg->selected_idx += pg->cols;
			pc_gaming_render(m);
		}
		return 1;
	case BTN_DPAD_LEFT:
		if (pg->selected_idx > 0) {
			pg->selected_idx--;
			pc_gaming_render(m);
		}
		return 1;
	case BTN_DPAD_RIGHT:
		if (pg->selected_idx < pg->game_count - 1) {
			pg->selected_idx++;
			pc_gaming_render(m);
		}
		return 1;
	case BTN_TL:  /* Left bumper - scroll up */
		pc_gaming_scroll(m, -(PC_GAMING_TILE_HEIGHT + PC_GAMING_TILE_GAP) * 3);
		return 1;
	case BTN_TR:  /* Right bumper - scroll down */
		pc_gaming_scroll(m, (PC_GAMING_TILE_HEIGHT + PC_GAMING_TILE_GAP) * 3);
		return 1;
	}

	return 0;
}

static int
pc_gaming_handle_key(Monitor *m, uint32_t mods, xkb_keysym_t sym)
{
	PcGamingView *pg;

	if (!m)
		return 0;

	pg = &m->pc_gaming;
	if (!pg->visible)
		return 0;

	switch (sym) {
	case XKB_KEY_Escape:
		pc_gaming_hide(m);
		return 1;
	case XKB_KEY_Return:
	case XKB_KEY_KP_Enter:
		pc_gaming_launch_game(m);
		return 1;
	case XKB_KEY_Up:
	case XKB_KEY_k:
		if (pg->selected_idx >= pg->cols) {
			pg->selected_idx -= pg->cols;
			pc_gaming_render(m);
		}
		return 1;
	case XKB_KEY_Down:
	case XKB_KEY_j:
		if (pg->selected_idx + pg->cols < pg->game_count) {
			pg->selected_idx += pg->cols;
			pc_gaming_render(m);
		}
		return 1;
	case XKB_KEY_Left:
	case XKB_KEY_h:
		if (pg->selected_idx > 0) {
			pg->selected_idx--;
			pc_gaming_render(m);
		}
		return 1;
	case XKB_KEY_Right:
	case XKB_KEY_l:
		if (pg->selected_idx < pg->game_count - 1) {
			pg->selected_idx++;
			pc_gaming_render(m);
		}
		return 1;
	case XKB_KEY_Page_Up:
		pc_gaming_scroll(m, -(pg->height - 100));
		return 1;
	case XKB_KEY_Page_Down:
		pc_gaming_scroll(m, pg->height - 100);
		return 1;
	case XKB_KEY_Home:
		pg->scroll_offset = 0;
		pg->selected_idx = 0;
		pc_gaming_render(m);
		return 1;
	case XKB_KEY_End:
		if (pg->game_count > 0) {
			pg->selected_idx = pg->game_count - 1;
			int rows = (pg->game_count + pg->cols - 1) / pg->cols;
			int max_scroll = rows * (PC_GAMING_TILE_HEIGHT + PC_GAMING_TILE_GAP) - (pg->height - 40);
			if (max_scroll > 0)
				pg->scroll_offset = max_scroll;
			pc_gaming_render(m);
		}
		return 1;
	}

	return 1;  /* Consume all keys while view is open */
}

/* ============================================================================
 * Retro Gaming View Implementation
 * ============================================================================ */

#define RETRO_SLIDE_DURATION_MS 200  /* Smooth slide animation duration */
static struct wl_event_source *retro_anim_timer = NULL;

static void
retro_gaming_show(Monitor *m)
{
	RetroGamingView *rg;
	float dim_color[4] = {0.05f, 0.05f, 0.08f, 0.98f};

	if (!m)
		return;

	retro_gaming_hide_all();

	rg = &m->retro_gaming;
	rg->selected_console = RETRO_NES;
	rg->target_console = RETRO_NES;
	rg->anim_direction = 0;
	rg->slide_offset = 0.0f;
	rg->width = m->m.width;
	rg->height = m->m.height;
	rg->visible = 1;
	rg->view_tag = 1 << 2;  /* Tag 3 = bit 2 */

	/* Create dim overlay */
	if (!rg->dim)
		rg->dim = wlr_scene_tree_create(layers[LyrBlock]);
	if (rg->dim) {
		struct wlr_scene_node *node, *tmp;
		wl_list_for_each_safe(node, tmp, &rg->dim->children, link)
			wlr_scene_node_destroy(node);
		wlr_scene_node_set_position(&rg->dim->node, m->m.x, m->m.y);
		drawrect(rg->dim, 0, 0, m->m.width, m->m.height, dim_color);
		wlr_scene_node_set_enabled(&rg->dim->node, 1);
		wlr_scene_node_raise_to_top(&rg->dim->node);
	}

	/* Create main tree */
	if (!rg->tree)
		rg->tree = wlr_scene_tree_create(layers[LyrBlock]);
	if (rg->tree) {
		wlr_scene_node_set_position(&rg->tree->node, m->m.x, m->m.y);
		wlr_scene_node_set_enabled(&rg->tree->node, 1);
		wlr_scene_node_raise_to_top(&rg->tree->node);
	}

	retro_gaming_render(m);
}

static void
retro_gaming_hide(Monitor *m)
{
	RetroGamingView *rg;

	if (!m)
		return;

	rg = &m->retro_gaming;
	rg->visible = 0;

	if (rg->tree)
		wlr_scene_node_set_enabled(&rg->tree->node, 0);
	if (rg->dim)
		wlr_scene_node_set_enabled(&rg->dim->node, 0);
}

static void
retro_gaming_hide_all(void)
{
	Monitor *m;
	wl_list_for_each(m, &mons, link) {
		retro_gaming_hide(m);
	}
}

static void
retro_gaming_render(Monitor *m)
{
	RetroGamingView *rg;
	struct wlr_scene_node *node, *tmp;
	int menu_bar_h = 80;
	int item_spacing = 40;
	int total_width = 0;
	int x_offset;
	float bg_color[4] = {0.08f, 0.08f, 0.10f, 1.0f};
	float selected_color[4] = {0.20f, 0.45f, 0.85f, 1.0f};
	float hover_underline[4] = {0.20f, 0.45f, 0.85f, 1.0f};

	if (!m || !statusfont.font)
		return;

	rg = &m->retro_gaming;
	if (!rg->visible || !rg->tree)
		return;

	/* Clear previous content */
	wl_list_for_each_safe(node, tmp, &rg->tree->children, link) {
		wlr_scene_node_destroy(node);
	}

	/* Draw menu bar background */
	drawrect(rg->tree, 0, 0, rg->width, menu_bar_h, bg_color);

	/* Calculate total width and positions of menu items */
	int item_positions[RETRO_CONSOLE_COUNT];
	int item_widths[RETRO_CONSOLE_COUNT];
	for (int i = 0; i < RETRO_CONSOLE_COUNT; i++) {
		item_widths[i] = status_text_width(retro_console_names[i]);
		total_width += item_widths[i];
		if (i < RETRO_CONSOLE_COUNT - 1)
			total_width += item_spacing;
	}

	/* Calculate item positions (menu items stay fixed) */
	x_offset = (rg->width - total_width) / 2;
	for (int i = 0; i < RETRO_CONSOLE_COUNT; i++) {
		item_positions[i] = x_offset;
		x_offset += item_widths[i] + item_spacing;
	}

	/* Calculate animated pill position */
	int pill_pad = 15;
	int pill_h = 40;
	int pill_y = (menu_bar_h - pill_h) / 2;

	/* Interpolate pill position during animation */
	int from_console = rg->selected_console;
	int to_console = rg->target_console;
	float anim_progress = 1.0f - fabsf(rg->slide_offset);  /* slide_offset goes from +-1 to 0 */

	int pill_x, pill_w;
	if (from_console == to_console || anim_progress >= 1.0f) {
		/* No animation or animation complete */
		pill_x = item_positions[rg->selected_console] - pill_pad;
		pill_w = item_widths[rg->selected_console] + pill_pad * 2;
	} else {
		/* Animate pill between positions */
		int from_x = item_positions[from_console] - pill_pad;
		int from_w = item_widths[from_console] + pill_pad * 2;
		int to_x = item_positions[to_console] - pill_pad;
		int to_w = item_widths[to_console] + pill_pad * 2;

		/* Ease-out interpolation */
		float ease = 1.0f - (1.0f - anim_progress) * (1.0f - anim_progress);
		pill_x = from_x + (int)((to_x - from_x) * ease);
		pill_w = from_w + (int)((to_w - from_w) * ease);
	}

	/* Draw selection pill (animated) */
	drawrect(rg->tree, pill_x, pill_y, pill_w, pill_h, selected_color);

	/* Draw menu items (fixed positions) */
	for (int i = 0; i < RETRO_CONSOLE_COUNT; i++) {
		const char *name = retro_console_names[i];
		int text_y = (menu_bar_h - 20) / 2;
		int is_target = (i == rg->target_console);

		/* Draw text */
		struct wlr_scene_tree *text_tree = wlr_scene_tree_create(rg->tree);
		if (text_tree) {
			wlr_scene_node_set_position(&text_tree->node, item_positions[i], text_y);
			StatusModule mod = {0};
			mod.tree = text_tree;
			float text_color[4] = {1.0f, 1.0f, 1.0f, is_target ? 1.0f : 0.7f};
			tray_render_label(&mod, name, 0, 20, text_color);
		}
	}

	/* Draw underline (animated with pill) */
	int underline_x = pill_x + pill_pad;
	int underline_w = pill_w - pill_pad * 2;
	drawrect(rg->tree, underline_x, menu_bar_h - 4, underline_w, 3, hover_underline);

	/* Draw separator line */
	float sep_color[4] = {0.3f, 0.3f, 0.35f, 1.0f};
	drawrect(rg->tree, 0, menu_bar_h - 1, rg->width, 1, sep_color);

	/* Content area */
	float content_bg[4] = {0.06f, 0.06f, 0.08f, 1.0f};
	drawrect(rg->tree, 0, menu_bar_h, rg->width, rg->height - menu_bar_h, content_bg);

	/* Show target console name in content area (shows destination immediately) */
	struct wlr_scene_tree *content_tree = wlr_scene_tree_create(rg->tree);
	if (content_tree) {
		const char *console = retro_console_names[rg->target_console];
		int cw = status_text_width(console);
		int cx = (rg->width - cw) / 2;
		int cy = menu_bar_h + (rg->height - menu_bar_h) / 2 - 20;
		wlr_scene_node_set_position(&content_tree->node, cx, cy);
		StatusModule mod = {0};
		mod.tree = content_tree;
		float white[4] = {1.0f, 1.0f, 1.0f, 0.5f};
		tray_render_label(&mod, console, 0, 40, white);
	}
}

static int
retro_gaming_animate(void *data)
{
	Monitor *m = data;
	RetroGamingView *rg;
	uint64_t now, elapsed;
	float progress;

	if (!m)
		return 0;

	rg = &m->retro_gaming;
	if (!rg->visible)
		return 0;

	now = monotonic_msec();
	elapsed = now - rg->slide_start_ms;
	progress = (float)elapsed / RETRO_SLIDE_DURATION_MS;

	if (progress >= 1.0f) {
		/* Animation complete */
		rg->selected_console = rg->target_console;
		rg->slide_offset = 0.0f;
		rg->anim_direction = 0;
		retro_gaming_render(m);
		return 0;
	}

	/* Ease-out animation - slide_offset goes from 1.0 to 0.0 */
	float ease = 1.0f - (1.0f - progress) * (1.0f - progress);
	rg->slide_offset = (1.0f - ease) * (rg->anim_direction < 0 ? 1.0f : -1.0f);

	retro_gaming_render(m);

	/* Continue animation */
	if (retro_anim_timer)
		wl_event_source_timer_update(retro_anim_timer, 16);  /* ~60fps */

	return 0;
}

static int
retro_gaming_handle_button(Monitor *m, int button, int value)
{
	RetroGamingView *rg;
	int direction = 0;

	if (!m)
		return 0;

	rg = &m->retro_gaming;
	/* Only handle input if view is visible AND on current tag */
	if (!htpc_view_is_active(m, rg->view_tag, rg->visible))
		return 0;

	/* Only handle button press */
	if (value != 1)
		return 0;

	/* Navigation: D-pad left/right, shoulder buttons */
	switch (button) {
	case BTN_DPAD_LEFT:
	case BTN_TL:  /* Left shoulder */
		direction = -1;
		break;
	case BTN_DPAD_RIGHT:
	case BTN_TR:  /* Right shoulder */
		direction = 1;
		break;
	case BTN_EAST:  /* B button - do nothing in main view (can't be closed) */
		return 1;
	case BTN_MODE:  /* Guide button - let main handler show menu overlay */
		return 0;
	case BTN_SOUTH:  /* A button - select current console */
		/* TODO: Enter console's game list */
		return 1;
	}

	if (direction != 0) {
		int new_target = rg->target_console + direction;
		if (new_target >= 0 && new_target < RETRO_CONSOLE_COUNT) {
			/* If animation is in progress, update selected to current target first */
			if (rg->anim_direction != 0) {
				rg->selected_console = rg->target_console;
			}
			rg->target_console = new_target;
			rg->anim_direction = direction;
			rg->slide_start_ms = monotonic_msec();
			rg->slide_offset = (direction < 0) ? 1.0f : -1.0f;

			/* Start animation timer */
			if (!retro_anim_timer)
				retro_anim_timer = wl_event_loop_add_timer(
					wl_display_get_event_loop(dpy),
					retro_gaming_animate, m);
			if (retro_anim_timer)
				wl_event_source_timer_update(retro_anim_timer, 16);
		}
		return 1;
	}

	return 0;
}

/* =========================================================== */
/* Media Grid View (Movies & TV-shows) */
/* =========================================================== */

#define MEDIA_GRID_PADDING 40
#define MEDIA_GRID_GAP 20
#define MEDIA_SERVER_PORT 8080
#define MEDIA_DISCOVERY_PORT 8081
#define MEDIA_DISCOVERY_MAGIC "NIXLY_DISCOVER"
#define MEDIA_DISCOVERY_RESPONSE "NIXLY_SERVER"
#define MAX_MEDIA_SERVERS 16

/* Configured media servers (from config file) */
static char media_servers[MAX_MEDIA_SERVERS][256];
static int media_server_count = 0;
static int current_server_idx = 0;  /* Which configured server to use */

/* Discovered server URL (auto-discovered or fallback to localhost) */
static char discovered_server_url[256] = "";
static int server_discovered = 0;
static uint64_t last_discovery_attempt_ms = 0;

/* Try to discover nixly-server on local network via UDP broadcast */
static int
discover_nixly_server(void)
{
	int sock;
	struct sockaddr_in broadcast_addr, recv_addr;
	socklen_t addr_len = sizeof(recv_addr);
	char recv_buf[256];
	ssize_t recv_len;
	struct timeval tv;
	int broadcast_enable = 1;

	/* Create UDP socket */
	sock = socket(AF_INET, SOCK_DGRAM, 0);
	if (sock < 0) {
		wlr_log(WLR_DEBUG, "Discovery: failed to create socket");
		return 0;
	}

	/* Enable broadcast */
	if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &broadcast_enable, sizeof(broadcast_enable)) < 0) {
		wlr_log(WLR_DEBUG, "Discovery: failed to enable broadcast");
		close(sock);
		return 0;
	}

	/* Set receive timeout (500ms) */
	tv.tv_sec = 0;
	tv.tv_usec = 500000;
	setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));

	/* Broadcast discovery message to local network */
	memset(&broadcast_addr, 0, sizeof(broadcast_addr));
	broadcast_addr.sin_family = AF_INET;
	broadcast_addr.sin_port = htons(MEDIA_DISCOVERY_PORT);
	broadcast_addr.sin_addr.s_addr = htonl(INADDR_BROADCAST);

	if (sendto(sock, MEDIA_DISCOVERY_MAGIC, strlen(MEDIA_DISCOVERY_MAGIC), 0,
		   (struct sockaddr *)&broadcast_addr, sizeof(broadcast_addr)) < 0) {
		wlr_log(WLR_DEBUG, "Discovery: broadcast send failed");
		close(sock);
		return 0;
	}

	/* Wait for response */
	recv_len = recvfrom(sock, recv_buf, sizeof(recv_buf) - 1, 0,
			    (struct sockaddr *)&recv_addr, &addr_len);
	close(sock);

	if (recv_len > 0) {
		recv_buf[recv_len] = '\0';
		if (strncmp(recv_buf, MEDIA_DISCOVERY_RESPONSE, strlen(MEDIA_DISCOVERY_RESPONSE)) == 0) {
			/* Extract port if provided, otherwise use default */
			int port = MEDIA_SERVER_PORT;
			char *port_str = strchr(recv_buf, ':');
			if (port_str) {
				port = atoi(port_str + 1);
				if (port <= 0 || port > 65535)
					port = MEDIA_SERVER_PORT;
			}

			char ip_str[INET_ADDRSTRLEN];
			inet_ntop(AF_INET, &recv_addr.sin_addr, ip_str, sizeof(ip_str));
			snprintf(discovered_server_url, sizeof(discovered_server_url),
				 "http://%s:%d", ip_str, port);

			wlr_log(WLR_INFO, "Discovered nixly-server at %s", discovered_server_url);
			server_discovered = 1;
			return 1;
		}
	}

	return 0;
}

/* Try localhost as fallback */
static int
try_localhost_server(void)
{
	char cmd[256];
	FILE *fp;

	snprintf(cmd, sizeof(cmd), "curl -s --connect-timeout 1 http://localhost:%d/api/status 2>/dev/null", MEDIA_SERVER_PORT);
	fp = popen(cmd, "r");
	if (fp) {
		char buf[64];
		if (fgets(buf, sizeof(buf), fp) && strstr(buf, "ok")) {
			pclose(fp);
			snprintf(discovered_server_url, sizeof(discovered_server_url),
				 "http://localhost:%d", MEDIA_SERVER_PORT);
			wlr_log(WLR_INFO, "Found nixly-server on localhost");
			server_discovered = 1;
			return 1;
		}
		pclose(fp);
	}
	return 0;
}

/* Get server URL (uses config or discovers if needed) */
static const char *
get_media_server_url(void)
{
	uint64_t now = monotonic_msec();

	/* If servers are configured in config, use them (skip auto-discovery) */
	if (media_server_count > 0) {
		/* Use the current configured server */
		if (current_server_idx < media_server_count)
			return media_servers[current_server_idx];
		return media_servers[0];
	}

	/* Auto-discovery mode (no servers configured) */
	/* Don't retry too often (every 5 seconds) */
	if (!server_discovered && (now - last_discovery_attempt_ms > 5000)) {
		last_discovery_attempt_ms = now;

		/* Try localhost first (most common case) */
		if (!try_localhost_server()) {
			/* Try broadcast discovery */
			discover_nixly_server();
		}
	}

	if (server_discovered)
		return discovered_server_url;

	/* Fallback to localhost even if not responding */
	return "http://localhost:8080";
}

static MediaGridView *
media_get_view(Monitor *m, MediaViewType type)
{
	if (!m) return NULL;
	return (type == MEDIA_VIEW_MOVIES) ? &m->movies_view : &m->tvshows_view;
}

static void
media_view_free_items(MediaGridView *view)
{
	MediaItem *item, *next;
	if (!view) return;

	item = view->items;
	while (item) {
		next = item->next;
		if (item->poster_buf)
			wlr_buffer_drop(item->poster_buf);
		free(item);
		item = next;
	}
	view->items = NULL;
	view->item_count = 0;
}

/* Simple JSON string extraction helper with escape sequence handling */
static int
json_extract_string(const char *json, const char *key, char *out, size_t out_size)
{
	char search[128];
	snprintf(search, sizeof(search), "\"%s\":", key);
	const char *pos = strstr(json, search);
	if (!pos) return 0;

	pos = strchr(pos, ':');
	if (!pos) return 0;
	pos++;
	while (*pos == ' ') pos++;

	if (*pos == '"') {
		pos++;
		/* Find end quote, handling escaped quotes */
		const char *src = pos;
		char *dst = out;
		char *dst_end = out + out_size - 1;

		while (*src && *src != '"' && dst < dst_end) {
			if (*src == '\\' && src[1]) {
				src++;
				switch (*src) {
				case '"': *dst++ = '"'; break;
				case '\\': *dst++ = '\\'; break;
				case 'n': *dst++ = '\n'; break;
				case 'r': *dst++ = '\r'; break;
				case 't': *dst++ = '\t'; break;
				default: *dst++ = *src; break;
				}
				src++;
			} else {
				*dst++ = *src++;
			}
		}
		*dst = '\0';
		return 1;
	} else if (strncmp(pos, "null", 4) == 0) {
		out[0] = '\0';
		return 1;
	}
	return 0;
}

static int
json_extract_int(const char *json, const char *key)
{
	char search[128];
	snprintf(search, sizeof(search), "\"%s\":", key);
	const char *pos = strstr(json, search);
	if (!pos) return 0;
	pos = strchr(pos, ':');
	if (!pos) return 0;
	return atoi(pos + 1);
}

static float
json_extract_float(const char *json, const char *key)
{
	char search[128];
	snprintf(search, sizeof(search), "\"%s\":", key);
	const char *pos = strstr(json, search);
	if (!pos) return 0.0f;
	pos = strchr(pos, ':');
	if (!pos) return 0.0f;
	return atof(pos + 1);
}

/* Poll timer callback - refresh media views every 3 seconds */
static int
media_view_poll_timer_cb(void *data)
{
	Monitor *m;
	(void)data;

	if (!htpc_mode_active) {
		/* Re-arm timer even when inactive */
		if (media_view_poll_timer)
			wl_event_source_timer_update(media_view_poll_timer, 3000);
		return 0;
	}

	wl_list_for_each(m, &mons, link) {
		/* Update movies view if visible */
		if (m->movies_view.visible) {
			int saved_idx = m->movies_view.selected_idx;
			int saved_scroll = m->movies_view.scroll_offset;
			if (media_view_refresh(m, MEDIA_VIEW_MOVIES)) {
				/* Data changed - restore navigation and re-render */
				if (saved_idx < m->movies_view.item_count)
					m->movies_view.selected_idx = saved_idx;
				else if (m->movies_view.item_count > 0)
					m->movies_view.selected_idx = m->movies_view.item_count - 1;
				m->movies_view.scroll_offset = saved_scroll;
				media_view_render(m, MEDIA_VIEW_MOVIES);
			}
		}

		/* Update tvshows view if visible */
		if (m->tvshows_view.visible) {
			int saved_idx = m->tvshows_view.selected_idx;
			int saved_scroll = m->tvshows_view.scroll_offset;
			if (media_view_refresh(m, MEDIA_VIEW_TVSHOWS)) {
				/* Data changed - restore navigation and re-render */
				if (saved_idx < m->tvshows_view.item_count)
					m->tvshows_view.selected_idx = saved_idx;
				else if (m->tvshows_view.item_count > 0)
					m->tvshows_view.selected_idx = m->tvshows_view.item_count - 1;
				m->tvshows_view.scroll_offset = saved_scroll;
				media_view_render(m, MEDIA_VIEW_TVSHOWS);
			}
		}
	}

	/* Re-arm timer for next poll */
	if (media_view_poll_timer)
		wl_event_source_timer_update(media_view_poll_timer, 3000);

	return 0;
}

/* Fetch media list from server - returns 1 if data changed, 0 otherwise */
static int
media_view_refresh(Monitor *m, MediaViewType type)
{
	MediaGridView *view;
	FILE *fp;
	char cmd[512];
	char buffer[1024 * 1024];  /* 1MB buffer for JSON */
	size_t bytes_read;
	const char *endpoint;
	uint32_t new_hash;

	if (!m) return 0;
	view = media_get_view(m, type);
	if (!view) return 0;

	view->needs_refresh = 0;
	view->last_refresh_ms = monotonic_msec();

	endpoint = (type == MEDIA_VIEW_MOVIES) ? "/api/movies" : "/api/tvshows";
	snprintf(cmd, sizeof(cmd), "curl -s '%s%s' 2>/dev/null", get_media_server_url(), endpoint);

	fp = popen(cmd, "r");
	if (!fp) {
		wlr_log(WLR_ERROR, "Failed to fetch media list from server");
		return 0;
	}

	bytes_read = fread(buffer, 1, sizeof(buffer) - 1, fp);
	pclose(fp);

	if (bytes_read == 0) {
		wlr_log(WLR_INFO, "No media data from server (server may be offline)");
		return 0;
	}
	buffer[bytes_read] = '\0';

	/* Calculate simple hash to detect changes (djb2 algorithm) */
	new_hash = 5381;
	for (size_t i = 0; i < bytes_read; i++)
		new_hash = ((new_hash << 5) + new_hash) + (unsigned char)buffer[i];

	/* Skip update if data hasn't changed */
	if (view->items && new_hash == view->last_data_hash) {
		return 0;
	}
	view->last_data_hash = new_hash;

	/* Data changed - free old items and parse new data */
	media_view_free_items(view);

	/* Parse JSON array - simple parser for our known format */
	const char *pos = strchr(buffer, '[');
	if (!pos) return 0;
	pos++;

	MediaItem *last = NULL;
	int count = 0;

	while (*pos) {
		/* Find start of object */
		const char *obj_start = strchr(pos, '{');
		if (!obj_start) break;

		/* Find end of object */
		int depth = 1;
		const char *obj_end = obj_start + 1;
		while (*obj_end && depth > 0) {
			if (*obj_end == '{') depth++;
			else if (*obj_end == '}') depth--;
			obj_end++;
		}

		if (depth != 0) break;

		/* Extract this object */
		size_t obj_len = obj_end - obj_start;
		char *obj_json = malloc(obj_len + 1);
		if (!obj_json) break;
		strncpy(obj_json, obj_start, obj_len);
		obj_json[obj_len] = '\0';

		/* Create media item */
		MediaItem *item = calloc(1, sizeof(MediaItem));
		if (item) {
			item->id = json_extract_int(obj_json, "id");
			item->type = json_extract_int(obj_json, "type");

			/* For TV-shows: prefer tmdb_title > show_name > title
			 * For Movies: prefer tmdb_title > title */
			json_extract_string(obj_json, "show_name", item->show_name, sizeof(item->show_name));
			if (!json_extract_string(obj_json, "tmdb_title", item->title, sizeof(item->title)) ||
			    item->title[0] == '\0') {
				/* Fallback: use show_name for TV-shows, title for movies */
				if (item->show_name[0])
					snprintf(item->title, sizeof(item->title), "%s", item->show_name);
				else
					json_extract_string(obj_json, "title", item->title, sizeof(item->title));
			}
			item->season = json_extract_int(obj_json, "season");
			item->episode = json_extract_int(obj_json, "episode");
			item->duration = json_extract_int(obj_json, "duration");
			item->year = json_extract_int(obj_json, "year");
			item->rating = json_extract_float(obj_json, "rating");
			json_extract_string(obj_json, "poster", item->poster_path, sizeof(item->poster_path));
			json_extract_string(obj_json, "backdrop", item->backdrop_path, sizeof(item->backdrop_path));
			json_extract_string(obj_json, "overview", item->overview, sizeof(item->overview));
			json_extract_string(obj_json, "genres", item->genres, sizeof(item->genres));
			item->tmdb_total_seasons = json_extract_int(obj_json, "tmdb_total_seasons");
			item->tmdb_total_episodes = json_extract_int(obj_json, "tmdb_total_episodes");
			item->tmdb_episode_runtime = json_extract_int(obj_json, "tmdb_episode_runtime");
			json_extract_string(obj_json, "tmdb_status", item->tmdb_status, sizeof(item->tmdb_status));
			json_extract_string(obj_json, "tmdb_next_episode", item->tmdb_next_episode, sizeof(item->tmdb_next_episode));

			/* Add to linked list */
			if (!view->items) {
				view->items = item;
			} else {
				last->next = item;
			}
			last = item;
			count++;
		}

		free(obj_json);
		pos = obj_end;
	}

	view->item_count = count;
	wlr_log(WLR_INFO, "Media view: loaded %d items for %s",
		count, type == MEDIA_VIEW_MOVIES ? "Movies" : "TV-shows");
	return 1;  /* Data changed */
}

/* Load poster image for a media item - scale-to-fill (cover) the target area */
static void
media_view_load_poster(MediaItem *item, int target_w, int target_h)
{
	GdkPixbuf *pixbuf = NULL;
	GdkPixbuf *scaled = NULL;
	GdkPixbuf *cropped = NULL;
	GError *gerr = NULL;
	int orig_w, orig_h, scaled_w, scaled_h, crop_x, crop_y;
	double scale_w, scale_h, scale;
	guchar *pixels;
	int nchan, stride;
	uint8_t *argb = NULL;
	size_t bufsize;
	struct wlr_buffer *buf = NULL;

	if (!item || item->poster_loaded)
		return;

	item->poster_loaded = 1;

	/* Check if poster path exists */
	if (item->poster_path[0] == '\0' || strcmp(item->poster_path, "null") == 0)
		return;

	/* Check if it's a local file */
	if (item->poster_path[0] != '/')
		return;

	pixbuf = gdk_pixbuf_new_from_file(item->poster_path, &gerr);
	if (!pixbuf) {
		if (gerr) {
			wlr_log(WLR_DEBUG, "Failed to load poster %s: %s",
				item->poster_path, gerr->message);
			g_error_free(gerr);
		}
		return;
	}

	orig_w = gdk_pixbuf_get_width(pixbuf);
	orig_h = gdk_pixbuf_get_height(pixbuf);
	if (orig_w <= 0 || orig_h <= 0 || target_w <= 0 || target_h <= 0) {
		g_object_unref(pixbuf);
		return;
	}

	/* Scale-to-fill: scale so the image covers the entire target area */
	scale_w = (double)target_w / (double)orig_w;
	scale_h = (double)target_h / (double)orig_h;
	scale = (scale_w > scale_h) ? scale_w : scale_h;  /* Use larger scale to cover */

	scaled_w = (int)lround(orig_w * scale);
	scaled_h = (int)lround(orig_h * scale);
	if (scaled_w < target_w) scaled_w = target_w;
	if (scaled_h < target_h) scaled_h = target_h;

	scaled = gdk_pixbuf_scale_simple(pixbuf, scaled_w, scaled_h, GDK_INTERP_BILINEAR);
	g_object_unref(pixbuf);
	if (!scaled)
		return;

	/* Crop to center */
	crop_x = (scaled_w - target_w) / 2;
	crop_y = (scaled_h - target_h) / 2;
	if (crop_x < 0) crop_x = 0;
	if (crop_y < 0) crop_y = 0;

	cropped = gdk_pixbuf_new_subpixbuf(scaled, crop_x, crop_y, target_w, target_h);
	if (!cropped) {
		g_object_unref(scaled);
		return;
	}

	/* Convert to ARGB32 for wlr_buffer */
	nchan = gdk_pixbuf_get_n_channels(cropped);
	stride = gdk_pixbuf_get_rowstride(cropped);
	pixels = gdk_pixbuf_get_pixels(cropped);

	bufsize = (size_t)target_w * (size_t)target_h * 4;
	argb = malloc(bufsize);
	if (!argb) {
		g_object_unref(cropped);
		g_object_unref(scaled);
		return;
	}

	for (int y = 0; y < target_h; y++) {
		guchar *row = pixels + y * stride;
		for (int x = 0; x < target_w; x++) {
			uint8_t r = row[x * nchan + 0];
			uint8_t g = row[x * nchan + 1];
			uint8_t b = row[x * nchan + 2];
			uint8_t a = (nchan >= 4) ? row[x * nchan + 3] : 255;
			size_t off = ((size_t)y * (size_t)target_w + (size_t)x) * 4;
			/* ARGB32 format */
			argb[off + 0] = b;
			argb[off + 1] = g;
			argb[off + 2] = r;
			argb[off + 3] = a;
		}
	}

	buf = statusbar_buffer_from_argb32_raw((uint32_t *)argb, target_w, target_h);
	free(argb);
	g_object_unref(cropped);
	g_object_unref(scaled);

	if (buf) {
		item->poster_buf = buf;
		item->poster_w = target_w;
		item->poster_h = target_h;
	}
}

/* Load backdrop image for detail view - scale-to-fill */
static void
media_view_load_backdrop(MediaItem *item, int target_w, int target_h)
{
	GdkPixbuf *pixbuf = NULL;
	GdkPixbuf *scaled = NULL;
	GdkPixbuf *cropped = NULL;
	GError *gerr = NULL;
	int orig_w, orig_h, scaled_w, scaled_h, crop_x, crop_y;
	double scale_w, scale_h, scale;
	guchar *pixels;
	int nchan, stride;
	uint8_t *argb = NULL;
	size_t bufsize;
	struct wlr_buffer *buf = NULL;

	if (!item || item->backdrop_loaded)
		return;

	item->backdrop_loaded = 1;

	if (item->backdrop_path[0] == '\0')
		return;

	pixbuf = gdk_pixbuf_new_from_file(item->backdrop_path, &gerr);
	if (!pixbuf) {
		if (gerr) g_error_free(gerr);
		return;
	}

	orig_w = gdk_pixbuf_get_width(pixbuf);
	orig_h = gdk_pixbuf_get_height(pixbuf);

	scale_w = (double)target_w / orig_w;
	scale_h = (double)target_h / orig_h;
	scale = (scale_w > scale_h) ? scale_w : scale_h;

	scaled_w = (int)(orig_w * scale);
	scaled_h = (int)(orig_h * scale);

	scaled = gdk_pixbuf_scale_simple(pixbuf, scaled_w, scaled_h, GDK_INTERP_BILINEAR);
	g_object_unref(pixbuf);

	if (!scaled)
		return;

	crop_x = (scaled_w - target_w) / 2;
	crop_y = (scaled_h - target_h) / 2;

	cropped = gdk_pixbuf_new_subpixbuf(scaled, crop_x, crop_y, target_w, target_h);
	if (!cropped) {
		g_object_unref(scaled);
		return;
	}

	pixels = gdk_pixbuf_get_pixels(cropped);
	nchan = gdk_pixbuf_get_n_channels(cropped);
	stride = gdk_pixbuf_get_rowstride(cropped);

	bufsize = target_w * target_h * 4;
	argb = malloc(bufsize);
	if (!argb) {
		g_object_unref(cropped);
		g_object_unref(scaled);
		return;
	}

	for (int y = 0; y < target_h; y++) {
		guchar *row = pixels + y * stride;
		for (int x = 0; x < target_w; x++) {
			guchar r = row[x * nchan + 0];
			guchar g = row[x * nchan + 1];
			guchar b = row[x * nchan + 2];
			guchar a = (nchan == 4) ? row[x * nchan + 3] : 255;

			size_t off = (y * target_w + x) * 4;
			argb[off + 0] = b;
			argb[off + 1] = g;
			argb[off + 2] = r;
			argb[off + 3] = a;
		}
	}

	buf = statusbar_buffer_from_argb32_raw((uint32_t *)argb, target_w, target_h);
	free(argb);
	g_object_unref(cropped);
	g_object_unref(scaled);

	if (buf) {
		item->backdrop_buf = buf;
		item->backdrop_w = target_w;
		item->backdrop_h = target_h;
	}
}

/* Free seasons list */
static void
media_view_free_seasons(MediaGridView *view)
{
	MediaSeason *s = view->seasons;
	while (s) {
		MediaSeason *next = s->next;
		free(s);
		s = next;
	}
	view->seasons = NULL;
	view->season_count = 0;
}

/* Free episodes list */
static void
media_view_free_episodes(MediaGridView *view)
{
	MediaItem *item = view->episodes;
	while (item) {
		MediaItem *next = item->next;
		if (item->poster_buf)
			wlr_buffer_drop(item->poster_buf);
		if (item->backdrop_buf)
			wlr_buffer_drop(item->backdrop_buf);
		free(item);
		item = next;
	}
	view->episodes = NULL;
	view->episode_count = 0;
}

/* Fetch seasons for a TV show */
static void
media_view_fetch_seasons(MediaGridView *view, const char *show_name)
{
	FILE *fp;
	char cmd[1024];
	char buffer[8192];
	size_t bytes_read;

	media_view_free_seasons(view);

	/* URL-encode spaces in show name */
	char encoded_name[512];
	char *dst = encoded_name;
	for (const char *src = show_name; *src && dst < encoded_name + sizeof(encoded_name) - 4; src++) {
		if (*src == ' ') {
			*dst++ = '%';
			*dst++ = '2';
			*dst++ = '0';
		} else {
			*dst++ = *src;
		}
	}
	*dst = '\0';

	snprintf(cmd, sizeof(cmd), "curl -s '%s/api/show/%s/seasons' 2>/dev/null",
	         view->server_url, encoded_name);

	fp = popen(cmd, "r");
	if (!fp) return;

	bytes_read = fread(buffer, 1, sizeof(buffer) - 1, fp);
	pclose(fp);

	if (bytes_read == 0) return;
	buffer[bytes_read] = '\0';

	/* Parse JSON array */
	const char *pos = strchr(buffer, '[');
	if (!pos) return;
	pos++;

	MediaSeason *last = NULL;
	int count = 0;

	while (*pos) {
		const char *obj_start = strchr(pos, '{');
		if (!obj_start) break;

		int depth = 1;
		const char *obj_end = obj_start + 1;
		while (*obj_end && depth > 0) {
			if (*obj_end == '{') depth++;
			else if (*obj_end == '}') depth--;
			obj_end++;
		}

		if (depth != 0) break;

		size_t obj_len = obj_end - obj_start;
		char *obj_json = malloc(obj_len + 1);
		if (!obj_json) break;
		strncpy(obj_json, obj_start, obj_len);
		obj_json[obj_len] = '\0';

		MediaSeason *season = calloc(1, sizeof(MediaSeason));
		if (season) {
			season->season = json_extract_int(obj_json, "season");
			season->episode_count = json_extract_int(obj_json, "episode_count");

			if (!view->seasons) {
				view->seasons = season;
			} else {
				last->next = season;
			}
			last = season;
			count++;
		}

		free(obj_json);
		pos = obj_end;
	}

	view->season_count = count;
}

/* Fetch episodes for a specific season */
static void
media_view_fetch_episodes(MediaGridView *view, const char *show_name, int season)
{
	FILE *fp;
	char cmd[1024];
	char buffer[1024 * 256];
	size_t bytes_read;

	media_view_free_episodes(view);

	/* URL-encode spaces in show name */
	char encoded_name[512];
	char *dst = encoded_name;
	for (const char *src = show_name; *src && dst < encoded_name + sizeof(encoded_name) - 4; src++) {
		if (*src == ' ') {
			*dst++ = '%';
			*dst++ = '2';
			*dst++ = '0';
		} else {
			*dst++ = *src;
		}
	}
	*dst = '\0';

	snprintf(cmd, sizeof(cmd), "curl -s '%s/api/show/%s/episodes/%d' 2>/dev/null",
	         view->server_url, encoded_name, season);

	fp = popen(cmd, "r");
	if (!fp) return;

	bytes_read = fread(buffer, 1, sizeof(buffer) - 1, fp);
	pclose(fp);

	if (bytes_read == 0) return;
	buffer[bytes_read] = '\0';

	/* Parse JSON array */
	const char *pos = strchr(buffer, '[');
	if (!pos) return;
	pos++;

	MediaItem *last = NULL;
	int count = 0;

	while (*pos) {
		const char *obj_start = strchr(pos, '{');
		if (!obj_start) break;

		int depth = 1;
		const char *obj_end = obj_start + 1;
		while (*obj_end && depth > 0) {
			if (*obj_end == '{') depth++;
			else if (*obj_end == '}') depth--;
			obj_end++;
		}

		if (depth != 0) break;

		size_t obj_len = obj_end - obj_start;
		char *obj_json = malloc(obj_len + 1);
		if (!obj_json) break;
		strncpy(obj_json, obj_start, obj_len);
		obj_json[obj_len] = '\0';

		MediaItem *item = calloc(1, sizeof(MediaItem));
		if (item) {
			item->id = json_extract_int(obj_json, "id");
			item->type = json_extract_int(obj_json, "type");
			json_extract_string(obj_json, "title", item->title, sizeof(item->title));
			json_extract_string(obj_json, "show_name", item->show_name, sizeof(item->show_name));
			item->season = json_extract_int(obj_json, "season");
			item->episode = json_extract_int(obj_json, "episode");
			item->duration = json_extract_int(obj_json, "duration");
			item->year = json_extract_int(obj_json, "year");
			item->rating = json_extract_float(obj_json, "rating");
			json_extract_string(obj_json, "poster", item->poster_path, sizeof(item->poster_path));
			json_extract_string(obj_json, "backdrop", item->backdrop_path, sizeof(item->backdrop_path));
			json_extract_string(obj_json, "overview", item->overview, sizeof(item->overview));
			json_extract_string(obj_json, "episode_title", item->episode_title, sizeof(item->episode_title));
			json_extract_string(obj_json, "filepath", item->filepath, sizeof(item->filepath));

			if (!view->episodes) {
				view->episodes = item;
			} else {
				last->next = item;
			}
			last = item;
			count++;
		}

		free(obj_json);
		pos = obj_end;
	}

	view->episode_count = count;
}

/* Render detail view for a movie or TV show */
static void
media_view_render_detail(Monitor *m, MediaViewType type)
{
	MediaGridView *view;
	struct wlr_scene_node *node, *tmp;
	float bg_color[4] = {0.05f, 0.05f, 0.08f, 0.98f};
	float text_color[4] = {1.0f, 1.0f, 1.0f, 1.0f};
	float dim_text[4] = {0.7f, 0.7f, 0.7f, 1.0f};
	float accent_color[4] = {0.2f, 0.5f, 1.0f, 1.0f};
	float panel_bg[4] = {0.08f, 0.08f, 0.12f, 0.95f};
	float selected_bg[4] = {0.15f, 0.35f, 0.65f, 0.9f};
	float hover_bg[4] = {0.12f, 0.12f, 0.18f, 0.9f};

	if (!m || !statusfont.font)
		return;

	view = media_get_view(m, type);
	if (!view || !view->visible || !view->tree || !view->in_detail_view)
		return;

	MediaItem *item = view->detail_item;
	if (!item) return;

	/* Clear previous content */
	wl_list_for_each_safe(node, tmp, &view->tree->children, link) {
		wlr_scene_node_destroy(node);
	}
	view->grid = NULL;
	view->detail_panel = NULL;

	/* Background */
	drawrect(view->tree, 0, 0, view->width, view->height, bg_color);

	/* Load and display backdrop if available */
	int backdrop_h = view->height * 60 / 100;  /* 60% of screen height */
	if (!item->backdrop_loaded && item->backdrop_path[0]) {
		media_view_load_backdrop(item, view->width, backdrop_h);
	}
	if (item->backdrop_buf) {
		struct wlr_scene_buffer *backdrop = wlr_scene_buffer_create(view->tree, item->backdrop_buf);
		if (backdrop) {
			wlr_scene_node_set_position(&backdrop->node, 0, 0);
		}
		/* Gradient overlay on backdrop */
		float gradient[4] = {0.05f, 0.05f, 0.08f, 0.7f};
		drawrect(view->tree, 650, backdrop_h - 180, view->width - 650, 180, gradient);
	}

	/* Left side: poster and info */
	int poster_w = 280;
	int poster_h = 420;
	int info_x = 60;
	int info_y = (backdrop_h > 0 ? backdrop_h - poster_h / 2 : 60) + 30;

	/* Poster */
	if (!item->poster_loaded) {
		media_view_load_poster(item, poster_w, poster_h);
	}
	if (item->poster_buf) {
		/* Poster shadow/border */
		float poster_shadow[4] = {0.0f, 0.0f, 0.0f, 0.5f};
		drawrect(view->tree, info_x - 4, info_y - 4, poster_w + 8, poster_h + 8, poster_shadow);

		struct wlr_scene_buffer *poster = wlr_scene_buffer_create(view->tree, item->poster_buf);
		if (poster) {
			wlr_scene_node_set_position(&poster->node, info_x, info_y);
		}
	}

	/* Details box - starts at top-right corner of thumbnail (with gap for shadow) */
	int details_box_x = info_x + poster_w + 72;  /* 72px gap after poster shadow */
	int details_box_y = info_y;  /* Aligned with poster top */
	int details_box_w = 300;
	int details_box_h = 380;
	float details_box_bg[4] = {0.08f, 0.08f, 0.12f, 0.95f};  /* Match panel_bg */
	drawrect(view->tree, details_box_x, details_box_y, details_box_w, details_box_h, details_box_bg);

	/* Title and metadata inside details box */
	int text_x = details_box_x + 15;  /* Inside details box with padding */
	int text_y = details_box_y + 20;
	int text_max_w = 200;  /* Max width before wrapping */
	int chars_per_line = text_max_w / 9;  /* ~9px per char at size 16 */

	/* Bold label color (brighter white) */
	float label_color[4] = {1.0f, 1.0f, 1.0f, 1.0f};

	/* Title (bold/large) */
	struct wlr_scene_tree *title_tree = wlr_scene_tree_create(view->tree);
	if (title_tree) {
		wlr_scene_node_set_position(&title_tree->node, text_x, text_y);
		StatusModule mod = {0};
		mod.tree = title_tree;
		tray_render_label(&mod, item->title, 0, 28, text_color);
	}
	text_y += 50;

	/* Score */
	if (item->rating > 0) {
		/* Bold label */
		struct wlr_scene_tree *label_tree = wlr_scene_tree_create(view->tree);
		if (label_tree) {
			wlr_scene_node_set_position(&label_tree->node, text_x, text_y);
			StatusModule mod = {0};
			mod.tree = label_tree;
			tray_render_label(&mod, "Score:", 0, 16, label_color);
		}
		/* Value */
		char score_val[32];
		snprintf(score_val, sizeof(score_val), "%.1f", item->rating);
		struct wlr_scene_tree *val_tree = wlr_scene_tree_create(view->tree);
		if (val_tree) {
			wlr_scene_node_set_position(&val_tree->node, text_x + 160, text_y);
			StatusModule mod = {0};
			mod.tree = val_tree;
			tray_render_label(&mod, score_val, 0, 16, dim_text);
		}
		text_y += 35;
	}

	/* Total duration */
	{
		/* For TV shows: use TMDB episode_runtime * total_episodes if available */
		int total_duration_sec = item->duration;
		if (type == MEDIA_VIEW_TVSHOWS && item->tmdb_episode_runtime > 0 && item->tmdb_total_episodes > 0) {
			total_duration_sec = item->tmdb_episode_runtime * item->tmdb_total_episodes * 60;
		}
		if (total_duration_sec > 0) {
			/* Bold label */
			struct wlr_scene_tree *label_tree = wlr_scene_tree_create(view->tree);
			if (label_tree) {
				wlr_scene_node_set_position(&label_tree->node, text_x, text_y);
				StatusModule mod = {0};
				mod.tree = label_tree;
				tray_render_label(&mod, "Total duration:", 0, 16, label_color);
			}
			/* Value */
			char duration_val[32];
			int hours = total_duration_sec / 3600;
			int mins = (total_duration_sec % 3600) / 60;
			if (hours > 0)
				snprintf(duration_val, sizeof(duration_val), "%dh %dm", hours, mins);
			else
				snprintf(duration_val, sizeof(duration_val), "%dm", mins);
			struct wlr_scene_tree *val_tree = wlr_scene_tree_create(view->tree);
			if (val_tree) {
				wlr_scene_node_set_position(&val_tree->node, text_x + 160, text_y);
				StatusModule mod = {0};
				mod.tree = val_tree;
				tray_render_label(&mod, duration_val, 0, 16, dim_text);
			}
			text_y += 35;
		}
	}

	/* Sjanger - with text wrapping */
	if (item->genres[0]) {
		/* Bold label */
		struct wlr_scene_tree *label_tree = wlr_scene_tree_create(view->tree);
		if (label_tree) {
			wlr_scene_node_set_position(&label_tree->node, text_x, text_y);
			StatusModule mod = {0};
			mod.tree = label_tree;
			tray_render_label(&mod, "Sjanger:", 0, 16, label_color);
		}
		text_y += 22;
		/* Value with word wrap at 250px */
		char wrapped_genre[512];
		int src_idx = 0, dst_idx = 0, line_len = 0;
		while (item->genres[src_idx] && dst_idx < (int)sizeof(wrapped_genre) - 1) {
			char c = item->genres[src_idx++];
			if (line_len >= chars_per_line && (c == ' ' || c == ',')) {
				wrapped_genre[dst_idx++] = '\n';
				line_len = 0;
				if (c == ' ') continue;
			}
			wrapped_genre[dst_idx++] = c;
			line_len++;
		}
		wrapped_genre[dst_idx] = '\0';
		/* Render wrapped lines */
		char *line = wrapped_genre;
		while (line && *line) {
			char *nl = strchr(line, '\n');
			char line_buf[256];
			if (nl) {
				int len = nl - line;
				if (len > 255) len = 255;
				strncpy(line_buf, line, len);
				line_buf[len] = '\0';
				line = nl + 1;
			} else {
				strncpy(line_buf, line, 255);
				line_buf[255] = '\0';
				line = NULL;
			}
			struct wlr_scene_tree *val_tree = wlr_scene_tree_create(view->tree);
			if (val_tree) {
				wlr_scene_node_set_position(&val_tree->node, text_x, text_y);
				StatusModule mod = {0};
				mod.tree = val_tree;
				tray_render_label(&mod, line_buf, 0, 16, dim_text);
			}
			text_y += 20;
		}
		text_y += 15;
	}

	/* Release date */
	if (item->year > 0) {
		/* Bold label */
		struct wlr_scene_tree *label_tree = wlr_scene_tree_create(view->tree);
		if (label_tree) {
			wlr_scene_node_set_position(&label_tree->node, text_x, text_y);
			StatusModule mod = {0};
			mod.tree = label_tree;
			tray_render_label(&mod, "Release date:", 0, 16, label_color);
		}
		/* Value */
		char year_val[16];
		snprintf(year_val, sizeof(year_val), "%d", item->year);
		struct wlr_scene_tree *val_tree = wlr_scene_tree_create(view->tree);
		if (val_tree) {
			wlr_scene_node_set_position(&val_tree->node, text_x + 160, text_y);
			StatusModule mod = {0};
			mod.tree = val_tree;
			tray_render_label(&mod, year_val, 0, 16, dim_text);
		}
		text_y += 35;
	}

	/* Seasons and Episodes (for TV shows only) */
	if (type == MEDIA_VIEW_TVSHOWS && (item->tmdb_total_seasons > 0 || view->season_count > 0)) {
		/* Use TMDB totals if available, otherwise fall back to local counts */
		int display_seasons = item->tmdb_total_seasons > 0 ? item->tmdb_total_seasons : view->season_count;
		int display_episodes = item->tmdb_total_episodes;
		if (display_episodes <= 0) {
			display_episodes = 0;
			MediaSeason *s;
			for (s = view->seasons; s; s = s->next) {
				display_episodes += s->episode_count;
			}
		}

		/* Seasons - bold label */
		struct wlr_scene_tree *slabel_tree = wlr_scene_tree_create(view->tree);
		if (slabel_tree) {
			wlr_scene_node_set_position(&slabel_tree->node, text_x, text_y);
			StatusModule mod = {0};
			mod.tree = slabel_tree;
			tray_render_label(&mod, "Seasons:", 0, 16, label_color);
		}
		char seasons_val[16];
		snprintf(seasons_val, sizeof(seasons_val), "%d", display_seasons);
		struct wlr_scene_tree *sval_tree = wlr_scene_tree_create(view->tree);
		if (sval_tree) {
			wlr_scene_node_set_position(&sval_tree->node, text_x + 160, text_y);
			StatusModule mod = {0};
			mod.tree = sval_tree;
			tray_render_label(&mod, seasons_val, 0, 16, dim_text);
		}
		text_y += 35;

		/* Episodes - bold label */
		struct wlr_scene_tree *elabel_tree = wlr_scene_tree_create(view->tree);
		if (elabel_tree) {
			wlr_scene_node_set_position(&elabel_tree->node, text_x, text_y);
			StatusModule mod = {0};
			mod.tree = elabel_tree;
			tray_render_label(&mod, "Episodes:", 0, 16, label_color);
		}
		char episodes_val[16];
		snprintf(episodes_val, sizeof(episodes_val), "%d", display_episodes);
		struct wlr_scene_tree *eval_tree = wlr_scene_tree_create(view->tree);
		if (eval_tree) {
			wlr_scene_node_set_position(&eval_tree->node, text_x + 160, text_y);
			StatusModule mod = {0};
			mod.tree = eval_tree;
			tray_render_label(&mod, episodes_val, 0, 16, dim_text);
		}
		text_y += 35;
	}

	/* Next episode / Ended status (TV shows only) */
	if (type == MEDIA_VIEW_TVSHOWS && item->tmdb_status[0]) {
		struct wlr_scene_tree *nlabel_tree = wlr_scene_tree_create(view->tree);
		if (nlabel_tree) {
			wlr_scene_node_set_position(&nlabel_tree->node, text_x, text_y);
			StatusModule mod = {0};
			mod.tree = nlabel_tree;
			tray_render_label(&mod, "Next episode:", 0, 16, label_color);
		}
		char next_val[32];
		if (strcmp(item->tmdb_status, "Ended") == 0 ||
		    strcmp(item->tmdb_status, "Canceled") == 0) {
			snprintf(next_val, sizeof(next_val), "Ended");
		} else if (item->tmdb_next_episode[0]) {
			snprintf(next_val, sizeof(next_val), "%s", item->tmdb_next_episode);
		} else {
			snprintf(next_val, sizeof(next_val), "TBA");
		}
		struct wlr_scene_tree *nval_tree = wlr_scene_tree_create(view->tree);
		if (nval_tree) {
			wlr_scene_node_set_position(&nval_tree->node, text_x + 160, text_y);
			StatusModule mod = {0};
			mod.tree = nval_tree;
			tray_render_label(&mod, next_val, 0, 16, dim_text);
		}
		text_y += 35;
	}

	/* Overview bar - horizontal bar to the right of details_box (transparent, no background) */
	if (item->overview[0]) {
		int overview_bar_x = details_box_x + details_box_w + 85;
		int overview_bar_y = details_box_y;
		int overview_bar_w = view->width - overview_bar_x - 40;
		int overview_bar_h = 80;

		/* Word wrap overview text for horizontal bar */
		char wrapped[4096];
		int wrap_width = 800 / 9;  /* Max 800px line width for font size 16 */
		int src_idx = 0, dst_idx = 0, line_len = 0;
		int max_lines = 12;  /* Allow more lines to show full overview */
		int current_line = 0;

		while (item->overview[src_idx] && dst_idx < (int)sizeof(wrapped) - 1 && current_line < max_lines) {
			char c = item->overview[src_idx++];
			if (c == '\n' || (line_len >= wrap_width && c == ' ')) {
				wrapped[dst_idx++] = '\n';
				line_len = 0;
				current_line++;
			} else {
				wrapped[dst_idx++] = c;
				line_len++;
			}
		}
		wrapped[dst_idx] = '\0';

		/* Render overview lines in horizontal bar */
		int ov_text_x = overview_bar_x - 35;
		int ov_text_y = overview_bar_y + 12;
		char *line = wrapped;
		int lines_rendered = 0;
		while (*line && lines_rendered < max_lines) {
			char *newline = strchr(line, '\n');
			if (newline) *newline = '\0';

			struct wlr_scene_tree *line_tree = wlr_scene_tree_create(view->tree);
			if (line_tree) {
				wlr_scene_node_set_position(&line_tree->node, ov_text_x, ov_text_y);
				StatusModule mod = {0};
				mod.tree = line_tree;
				tray_render_label(&mod, line, 0, 16, dim_text);
			}
			ov_text_y += 20;
			lines_rendered++;

			if (newline) {
				line = newline + 1;
			} else {
				break;
			}
		}
	}

	/* Play button (for movies) or focus indicator */
	if (type == MEDIA_VIEW_MOVIES || (type == MEDIA_VIEW_TVSHOWS && view->detail_focus == DETAIL_FOCUS_INFO)) {
		int btn_y = info_y + poster_h + 30;
		int btn_w = 160;
		int btn_h = 50;

		float *btn_bg = (view->detail_focus == DETAIL_FOCUS_INFO) ? selected_bg : hover_bg;
		drawrect(view->tree, info_x, btn_y, btn_w, btn_h, btn_bg);

		struct wlr_scene_tree *btn_tree = wlr_scene_tree_create(view->tree);
		if (btn_tree) {
			wlr_scene_node_set_position(&btn_tree->node, info_x + 50, btn_y + 15);
			StatusModule mod = {0};
			mod.tree = btn_tree;
			tray_render_label(&mod, " Play", 0, 20, text_color);
		}
	}

	/* For TV shows: show seasons and episodes columns - placed on right side */
	if (type == MEDIA_VIEW_TVSHOWS) {
		/* Position columns on the right side */
		int panel_y = info_y + poster_h - 190;  /* 150px higher */
		int panel_h = view->height - panel_y - 30;
		int col_gap = 15;
		int season_col_w = 550;
		int episode_col_w = 550;
		int episode_col_x = view->width - 40 - episode_col_w;
		int panel_x = episode_col_x - col_gap - season_col_w;
		int row_h = 40;
		int ep_row_h = 55;
		int header_h = 45;

		/* Seasons column with clipping area */
		drawrect(view->tree, panel_x, panel_y, season_col_w, panel_h, panel_bg);

		/* Seasons header */
		struct wlr_scene_tree *sh_tree = wlr_scene_tree_create(view->tree);
		if (sh_tree) {
			wlr_scene_node_set_position(&sh_tree->node, panel_x + 12, panel_y + 12);
			StatusModule mod = {0};
			mod.tree = sh_tree;
			tray_render_label(&mod, "Seasons", 0, 16, accent_color);
		}

		/* Season list with scroll */
		int content_y = panel_y + header_h;
		int content_h = panel_h - header_h - 5;
		int visible_rows = content_h / row_h;

		/* Ensure selected season is visible */
		if (view->selected_season_idx < view->season_scroll_offset) {
			view->season_scroll_offset = view->selected_season_idx;
		} else if (view->selected_season_idx >= view->season_scroll_offset + visible_rows) {
			view->season_scroll_offset = view->selected_season_idx - visible_rows + 1;
		}
		if (view->season_scroll_offset < 0) view->season_scroll_offset = 0;

		MediaSeason *season = view->seasons;
		int season_idx = 0;
		/* Skip to scroll offset */
		while (season && season_idx < view->season_scroll_offset) {
			season = season->next;
			season_idx++;
		}

		int season_y = content_y;
		while (season && season_y + row_h <= panel_y + panel_h) {
			int is_selected = (season_idx == view->selected_season_idx);
			int is_focused = (view->detail_focus == DETAIL_FOCUS_SEASONS);

			float *row_bg = (is_selected && is_focused) ? selected_bg :
			                (is_selected ? hover_bg : NULL);

			if (row_bg) {
				drawrect(view->tree, panel_x + 4, season_y, season_col_w - 8, row_h - 4, row_bg);
			}

			char season_str[64];
			snprintf(season_str, sizeof(season_str), "Season %d", season->season);

			struct wlr_scene_tree *s_tree = wlr_scene_tree_create(view->tree);
			if (s_tree) {
				wlr_scene_node_set_position(&s_tree->node, panel_x + 12, season_y + 10);
				StatusModule mod = {0};
				mod.tree = s_tree;
				float *color = is_selected ? text_color : dim_text;
				tray_render_label(&mod, season_str, 0, 14, color);
			}

			season_y += row_h;
			season_idx++;
			season = season->next;
		}

		/* Scroll indicator for seasons if needed */
		int total_seasons = 0;
		for (MediaSeason *s = view->seasons; s; s = s->next) total_seasons++;
		if (total_seasons > visible_rows) {
			int scroll_track_h = content_h - 10;
			int scroll_thumb_h = (visible_rows * scroll_track_h) / total_seasons;
			if (scroll_thumb_h < 20) scroll_thumb_h = 20;
			int scroll_thumb_y = content_y + 5 + (view->season_scroll_offset * (scroll_track_h - scroll_thumb_h)) / (total_seasons - visible_rows);
			float scroll_color[4] = {0.3f, 0.3f, 0.4f, 0.6f};
			drawrect(view->tree, panel_x + season_col_w - 6, scroll_thumb_y, 4, scroll_thumb_h, scroll_color);
		}

		/* Episodes column */
		drawrect(view->tree, episode_col_x, panel_y, episode_col_w, panel_h, panel_bg);

		/* Episodes header */
		struct wlr_scene_tree *eh_tree = wlr_scene_tree_create(view->tree);
		if (eh_tree) {
			char ep_header[64];
			snprintf(ep_header, sizeof(ep_header), "Season %d", view->selected_season);
			wlr_scene_node_set_position(&eh_tree->node, episode_col_x + 12, panel_y + 12);
			StatusModule mod = {0};
			mod.tree = eh_tree;
			tray_render_label(&mod, ep_header, 0, 16, accent_color);
		}

		/* Episode list with scroll */
		int ep_content_y = panel_y + header_h;
		int ep_content_h = panel_h - header_h - 5;
		int ep_visible_rows = ep_content_h / ep_row_h;

		/* Ensure selected episode is visible */
		if (view->selected_episode_idx < view->episode_scroll_offset) {
			view->episode_scroll_offset = view->selected_episode_idx;
		} else if (view->selected_episode_idx >= view->episode_scroll_offset + ep_visible_rows) {
			view->episode_scroll_offset = view->selected_episode_idx - ep_visible_rows + 1;
		}
		if (view->episode_scroll_offset < 0) view->episode_scroll_offset = 0;

		MediaItem *ep = view->episodes;
		int ep_idx = 0;
		/* Skip to scroll offset */
		while (ep && ep_idx < view->episode_scroll_offset) {
			ep = ep->next;
			ep_idx++;
		}

		int ep_y = ep_content_y;
		while (ep && ep_y + ep_row_h <= panel_y + panel_h) {
			int is_selected = (ep_idx == view->selected_episode_idx);
			int is_focused = (view->detail_focus == DETAIL_FOCUS_EPISODES);

			float *row_bg = (is_selected && is_focused) ? selected_bg :
			                (is_selected ? hover_bg : NULL);

			if (row_bg) {
				drawrect(view->tree, episode_col_x + 4, ep_y, episode_col_w - 12, ep_row_h - 4, row_bg);
			}

			/* Episode number */
			char ep_str[300];
			snprintf(ep_str, sizeof(ep_str), "Episode %d", ep->episode);

			struct wlr_scene_tree *ep_tree = wlr_scene_tree_create(view->tree);
			if (ep_tree) {
				wlr_scene_node_set_position(&ep_tree->node, episode_col_x + 12, ep_y + 18);
				StatusModule mod = {0};
				mod.tree = ep_tree;
				float *color = is_selected ? text_color : dim_text;
				tray_render_label(&mod, ep_str, 0, 14, color);
			}

			ep_y += ep_row_h;
			ep_idx++;
			ep = ep->next;
		}

		/* Scroll indicator for episodes if needed */
		if (view->episode_count > ep_visible_rows) {
			int ep_scroll_track_h = ep_content_h - 10;
			int ep_scroll_thumb_h = (ep_visible_rows * ep_scroll_track_h) / view->episode_count;
			if (ep_scroll_thumb_h < 20) ep_scroll_thumb_h = 20;
			int ep_scroll_thumb_y = ep_content_y + 5;
			if (view->episode_count > ep_visible_rows) {
				ep_scroll_thumb_y += (view->episode_scroll_offset * (ep_scroll_track_h - ep_scroll_thumb_h)) / (view->episode_count - ep_visible_rows);
			}
			float scroll_color[4] = {0.3f, 0.3f, 0.4f, 0.6f};
			drawrect(view->tree, episode_col_x + episode_col_w - 8, ep_scroll_thumb_y, 4, ep_scroll_thumb_h, scroll_color);
		}
	}

	/* Navigation hint at bottom */
	struct wlr_scene_tree *hint_tree = wlr_scene_tree_create(view->tree);
	if (hint_tree) {
		const char *hint = type == MEDIA_VIEW_MOVIES ?
		                   "A/Enter: Play   B/Esc: Back" :
		                   ": Switch columns   : Navigate   A/Enter: Play   B/Esc: Back";
		wlr_scene_node_set_position(&hint_tree->node, 60, view->height - 40);
		StatusModule mod = {0};
		mod.tree = hint_tree;
		float hint_color[4] = {0.5f, 0.5f, 0.5f, 1.0f};
		tray_render_label(&mod, hint, 0, 14, hint_color);
	}
}

/* Enter detail view for selected item */
static void
media_view_enter_detail(Monitor *m, MediaViewType type)
{
	MediaGridView *view = media_get_view(m, type);
	if (!view || !view->items) return;

	/* Find selected item */
	MediaItem *item = view->items;
	for (int i = 0; i < view->selected_idx && item; i++) {
		item = item->next;
	}
	if (!item) return;

	view->in_detail_view = 1;
	view->detail_item = item;
	view->detail_focus = DETAIL_FOCUS_INFO;

	/* For TV shows, load seasons */
	if (type == MEDIA_VIEW_TVSHOWS) {
		const char *show_name = item->title[0] ? item->title : item->show_name;
		media_view_fetch_seasons(view, show_name);

		/* Select first season and load its episodes */
		view->selected_season_idx = 0;
		view->season_scroll_offset = 0;
		if (view->seasons) {
			view->selected_season = view->seasons->season;
			media_view_fetch_episodes(view, show_name, view->selected_season);
		}
		view->selected_episode_idx = 0;
		view->episode_scroll_offset = 0;
		view->detail_focus = DETAIL_FOCUS_SEASONS;
	}

	media_view_render_detail(m, type);
}

/* Exit detail view back to grid */
static void
media_view_exit_detail(Monitor *m, MediaViewType type)
{
	MediaGridView *view = media_get_view(m, type);
	if (!view) return;

	view->in_detail_view = 0;
	view->detail_item = NULL;

	/* Free TV show data */
	media_view_free_seasons(view);
	media_view_free_episodes(view);

	media_view_render(m, type);
}

/* Ensure selected item is visible (scroll if needed) */
static void
media_view_ensure_visible(Monitor *m, MediaViewType type)
{
	MediaGridView *view = media_get_view(m, type);
	if (!view) return;

	int padding = MEDIA_GRID_PADDING;
	int gap = MEDIA_GRID_GAP;
	int grid_width = view->width - 2 * padding;
	int cols = 5;
	int tile_w = (grid_width - ((cols - 1) * gap)) / cols;
	int tile_h = (tile_w * 3) / 2;  /* 2:3 poster ratio */

	int row = view->selected_idx / cols;
	int y_start = row * (tile_h + gap);
	int y_end = y_start + tile_h;
	int visible_h = view->height - 2 * padding;

	if (y_start < view->scroll_offset) {
		view->scroll_offset = y_start;
	} else if (y_end > view->scroll_offset + visible_h) {
		view->scroll_offset = y_end - visible_h;
	}

	if (view->scroll_offset < 0)
		view->scroll_offset = 0;
}

/* Render the media grid view */
static void
media_view_render(Monitor *m, MediaViewType type)
{
	MediaGridView *view;
	struct wlr_scene_node *node, *tmp;
	int padding = MEDIA_GRID_PADDING;
	int gap = MEDIA_GRID_GAP;
	float tile_color[4] = {0.12f, 0.12f, 0.15f, 0.95f};
	float text_color[4] = {1.0f, 1.0f, 1.0f, 1.0f};
	float name_bg[4] = {0.0f, 0.0f, 0.0f, 0.75f};
	float dim_color[4] = {0.05f, 0.05f, 0.08f, 0.98f};

	if (!m || !statusfont.font)
		return;

	view = media_get_view(m, type);
	if (!view || !view->visible || !view->tree)
		return;

	/* Refresh if needed */
	if (view->needs_refresh || !view->items) {
		media_view_refresh(m, type);
	}

	/* Clear previous content */
	wl_list_for_each_safe(node, tmp, &view->tree->children, link) {
		wlr_scene_node_destroy(node);
	}
	view->grid = NULL;
	view->detail_panel = NULL;

	/* Background dim */
	drawrect(view->tree, 0, 0, view->width, view->height, dim_color);

	/* Calculate grid dimensions */
	int grid_width = view->width - 2 * padding;
	int grid_height = view->height - 2 * padding;

	/* Fixed 5 columns */
	view->cols = 5;
	int tile_w = (grid_width - ((view->cols - 1) * gap)) / view->cols;
	int tile_h = (tile_w * 3) / 2;  /* 2:3 poster ratio */
	int name_bar_h = 32;

	/* Ensure selected is visible */
	media_view_ensure_visible(m, type);

	/* Create grid container */
	view->grid = wlr_scene_tree_create(view->tree);
	if (!view->grid) return;
	wlr_scene_node_set_position(&view->grid->node, padding, padding);

	/* Draw tiles */
	MediaItem *item = view->items;
	int idx = 0;
	int visible_start = view->scroll_offset / (tile_h + gap);
	int visible_rows = (grid_height + gap) / (tile_h + gap) + 2;

	while (item) {
		int row = idx / view->cols;
		int col = idx % view->cols;

		/* Only render visible tiles */
		if (row >= visible_start && row < visible_start + visible_rows) {
			int tx = col * (tile_w + gap);
			int ty = row * (tile_h + gap) - view->scroll_offset;

			if (ty + tile_h > 0 && ty < grid_height) {
				int is_selected = (idx == view->selected_idx);
				int glow_size = is_selected ? 6 : 0;

				struct wlr_scene_tree *tile = wlr_scene_tree_create(view->grid);
				if (!tile) {
					item = item->next;
					idx++;
					continue;
				}

				if (is_selected) {
					wlr_scene_node_set_position(&tile->node, tx - glow_size, ty - glow_size);

					/* Draw glow effect */
					float glow1[4] = {0.2f, 0.5f, 1.0f, 0.2f};
					float glow2[4] = {0.3f, 0.6f, 1.0f, 0.35f};
					drawrect(tile, 0, 0, tile_w + glow_size * 2, tile_h + glow_size * 2, glow1);
					drawrect(tile, 2, 2, tile_w + glow_size * 2 - 4, tile_h + glow_size * 2 - 4, glow2);
					drawrect(tile, glow_size, glow_size, tile_w, tile_h, tile_color);
				} else {
					wlr_scene_node_set_position(&tile->node, tx, ty);
					drawrect(tile, 0, 0, tile_w, tile_h, tile_color);
				}

				int img_offset = is_selected ? glow_size : 0;

				/* Load and display poster */
				if (!item->poster_loaded) {
					media_view_load_poster(item, tile_w, tile_h - name_bar_h);
				}
				if (item->poster_buf) {
					struct wlr_scene_buffer *img = wlr_scene_buffer_create(tile, item->poster_buf);
					if (img) {
						wlr_scene_node_set_position(&img->node, img_offset, img_offset);
					}
				}

				/* Title bar at bottom */
				drawrect(tile, img_offset, img_offset + tile_h - name_bar_h - glow_size,
				         tile_w, name_bar_h, name_bg);

				/* Title text */
				struct wlr_scene_tree *text_tree = wlr_scene_tree_create(tile);
				if (text_tree) {
					char display_title[128];
					if (type == MEDIA_VIEW_TVSHOWS) {
						/* TV-shows view: show title with year in parentheses */
						const char *title = item->title[0] ? item->title :
						                    (item->show_name[0] ? item->show_name : "Unknown");
						if (item->year > 0)
							snprintf(display_title, sizeof(display_title), "%s (%d)", title, item->year);
						else
							snprintf(display_title, sizeof(display_title), "%s", title);
					} else {
						/* Movies view: show movie title with year */
						if (item->year > 0)
							snprintf(display_title, sizeof(display_title), "%s (%d)", item->title, item->year);
						else
							snprintf(display_title, sizeof(display_title), "%s", item->title);
					}

					/* Truncate if too long */
					int max_chars = tile_w / 8;
					if ((int)strlen(display_title) > max_chars && max_chars > 3) {
						display_title[max_chars - 3] = '.';
						display_title[max_chars - 2] = '.';
						display_title[max_chars - 1] = '.';
						display_title[max_chars] = '\0';
					}

					wlr_scene_node_set_position(&text_tree->node,
						img_offset + 6, img_offset + tile_h - name_bar_h + 6 - glow_size);
					StatusModule mod = {0};
					mod.tree = text_tree;
					tray_render_label(&mod, display_title, 0, 18, text_color);
				}

				/* Rating badge for selected */
				if (is_selected && item->rating > 0) {
					char rating_str[16];
					snprintf(rating_str, sizeof(rating_str), "%.1f", item->rating);
					float rating_bg[4] = {0.1f, 0.1f, 0.1f, 0.85f};
					float rating_fg[4] = {1.0f, 0.8f, 0.2f, 1.0f};

					struct wlr_scene_tree *badge = wlr_scene_tree_create(tile);
					if (badge) {
						int badge_w = 40, badge_h = 22;
						wlr_scene_node_set_position(&badge->node,
							img_offset + tile_w - badge_w - 4, img_offset + 4);
						drawrect(badge, 0, 0, badge_w, badge_h, rating_bg);
						StatusModule mod = {0};
						mod.tree = badge;
						tray_render_label(&mod, rating_str, 6, 16, rating_fg);
					}
				}
			}
		}

		item = item->next;
		idx++;
	}

	/* Show count in corner */
	char count_str[64];
	snprintf(count_str, sizeof(count_str), "%d %s",
	         view->item_count,
	         type == MEDIA_VIEW_MOVIES ? "Movies" : "Episodes");
	struct wlr_scene_tree *count_tree = wlr_scene_tree_create(view->tree);
	if (count_tree) {
		wlr_scene_node_set_position(&count_tree->node, padding, view->height - 30);
		StatusModule mod = {0};
		mod.tree = count_tree;
		float count_color[4] = {0.7f, 0.7f, 0.7f, 1.0f};
		tray_render_label(&mod, count_str, 0, 18, count_color);
	}
}

static void
media_view_show(Monitor *m, MediaViewType type)
{
	MediaGridView *view;
	float dim_color[4] = {0.05f, 0.05f, 0.08f, 0.98f};

	if (!m) return;

	view = media_get_view(m, type);
	if (!view) return;

	/* Hide the other media view first to ensure clean state */
	if (type == MEDIA_VIEW_MOVIES)
		media_view_hide(m, MEDIA_VIEW_TVSHOWS);
	else
		media_view_hide(m, MEDIA_VIEW_MOVIES);

	if (view->visible) return;

	view->visible = 1;
	/* Set view tag: Movies = Tag 2 (bit 1), TV-shows = Tag 1 (bit 0) */
	view->view_tag = (type == MEDIA_VIEW_MOVIES) ? (1 << 1) : (1 << 0);
	view->width = m->m.width;
	view->height = m->m.height;
	view->view_type = type;
	view->selected_idx = 0;
	view->scroll_offset = 0;
	view->needs_refresh = 1;

	strcpy(view->server_url, get_media_server_url());

	/* Create scene tree on LyrBlock layer (same as other HTPC overlays) */
	if (!view->tree) {
		view->tree = wlr_scene_tree_create(layers[LyrBlock]);
	}
	if (view->tree) {
		wlr_scene_node_set_position(&view->tree->node, m->m.x, m->m.y);
		wlr_scene_node_set_enabled(&view->tree->node, true);
		wlr_scene_node_raise_to_top(&view->tree->node);
	}

	/* Hide mouse cursor in media views */
	wlr_cursor_set_surface(cursor, NULL, 0, 0);

	media_view_render(m, type);
}

static void
media_view_hide(Monitor *m, MediaViewType type)
{
	MediaGridView *view;

	if (!m) return;

	view = media_get_view(m, type);
	if (!view || !view->visible) return;

	view->visible = 0;

	if (view->tree) {
		wlr_scene_node_set_enabled(&view->tree->node, false);
	}
}

static void
media_view_hide_all(void)
{
	Monitor *m;
	wl_list_for_each(m, &mons, link) {
		media_view_hide(m, MEDIA_VIEW_MOVIES);
		media_view_hide(m, MEDIA_VIEW_TVSHOWS);
	}
}

static Monitor *
media_view_visible_monitor(void)
{
	Monitor *m;
	wl_list_for_each(m, &mons, link) {
		if (m->movies_view.visible || m->tvshows_view.visible)
			return m;
	}
	return NULL;
}

/* Find monitor with visible Retro Gaming view */
static Monitor *
retro_gaming_visible_monitor(void)
{
	Monitor *m;
	wl_list_for_each(m, &mons, link) {
		if (m->retro_gaming.visible)
			return m;
	}
	return NULL;
}

static void
media_view_scroll(Monitor *m, MediaViewType type, int delta)
{
	MediaGridView *view = media_get_view(m, type);
	if (!view) return;

	view->scroll_offset += delta;
	if (view->scroll_offset < 0)
		view->scroll_offset = 0;

	media_view_render(m, type);
}

/* Handle detail view button input */
static int
media_view_handle_detail_button(Monitor *m, MediaViewType type, int button)
{
	MediaGridView *view = media_get_view(m, type);
	if (!view) return 0;

	int needs_render = 0;

	switch (button) {
	case BTN_EAST:   /* B button - go back to grid */
		media_view_exit_detail(m, type);
		return 1;

	case BTN_SOUTH:  /* A button - play selected */
		if (type == MEDIA_VIEW_MOVIES) {
			/* Play movie - TODO: launch player */
			wlr_log(WLR_INFO, "Play movie: %s", view->detail_item ? view->detail_item->title : "unknown");
		} else if (type == MEDIA_VIEW_TVSHOWS) {
			if (view->detail_focus == DETAIL_FOCUS_EPISODES && view->episodes) {
				/* Play selected episode */
				MediaItem *ep = view->episodes;
				for (int i = 0; i < view->selected_episode_idx && ep; i++)
					ep = ep->next;
				if (ep) {
					wlr_log(WLR_INFO, "Play episode: S%02dE%02d %s",
					        ep->season, ep->episode, ep->episode_title);
				}
			} else if (view->detail_focus == DETAIL_FOCUS_SEASONS) {
				/* Move to episodes column */
				view->detail_focus = DETAIL_FOCUS_EPISODES;
				view->selected_episode_idx = 0;
				needs_render = 1;
			}
		}
		break;

	case BTN_DPAD_UP:
		if (type == MEDIA_VIEW_TVSHOWS) {
			if (view->detail_focus == DETAIL_FOCUS_SEASONS) {
				if (view->selected_season_idx > 0) {
					view->selected_season_idx--;
					/* Load episodes for new season */
					MediaSeason *s = view->seasons;
					for (int i = 0; i < view->selected_season_idx && s; i++)
						s = s->next;
					if (s) {
						view->selected_season = s->season;
						const char *show = view->detail_item->title[0] ?
						                   view->detail_item->title : view->detail_item->show_name;
						media_view_fetch_episodes(view, show, s->season);
						view->selected_episode_idx = 0;
						view->episode_scroll_offset = 0;
					}
					needs_render = 1;
				}
			} else if (view->detail_focus == DETAIL_FOCUS_EPISODES) {
				if (view->selected_episode_idx > 0) {
					view->selected_episode_idx--;
					needs_render = 1;
				}
			}
		}
		break;

	case BTN_DPAD_DOWN:
		if (type == MEDIA_VIEW_TVSHOWS) {
			if (view->detail_focus == DETAIL_FOCUS_SEASONS) {
				if (view->selected_season_idx < view->season_count - 1) {
					view->selected_season_idx++;
					/* Load episodes for new season */
					MediaSeason *s = view->seasons;
					for (int i = 0; i < view->selected_season_idx && s; i++)
						s = s->next;
					if (s) {
						view->selected_season = s->season;
						const char *show = view->detail_item->title[0] ?
						                   view->detail_item->title : view->detail_item->show_name;
						media_view_fetch_episodes(view, show, s->season);
						view->selected_episode_idx = 0;
						view->episode_scroll_offset = 0;
					}
					needs_render = 1;
				}
			} else if (view->detail_focus == DETAIL_FOCUS_EPISODES) {
				if (view->selected_episode_idx < view->episode_count - 1) {
					view->selected_episode_idx++;
					needs_render = 1;
				}
			}
		}
		break;

	case BTN_DPAD_LEFT:
		if (type == MEDIA_VIEW_TVSHOWS) {
			if (view->detail_focus == DETAIL_FOCUS_EPISODES) {
				view->detail_focus = DETAIL_FOCUS_SEASONS;
				needs_render = 1;
			}
		}
		break;

	case BTN_DPAD_RIGHT:
		if (type == MEDIA_VIEW_TVSHOWS) {
			if (view->detail_focus == DETAIL_FOCUS_SEASONS && view->episode_count > 0) {
				view->detail_focus = DETAIL_FOCUS_EPISODES;
				needs_render = 1;
			}
		}
		break;

	case BTN_MODE:   /* Guide button */
		return 0;

	default:
		return 0;
	}

	if (needs_render) {
		media_view_render_detail(m, type);
	}

	return 1;
}

static int
media_view_handle_button(Monitor *m, MediaViewType type, int button, int value)
{
	MediaGridView *view;

	if (!m) return 0;

	view = media_get_view(m, type);
	if (!view) return 0;

	/* Only handle input if view is visible AND on current tag */
	if (!htpc_view_is_active(m, view->view_tag, view->visible)) return 0;

	/* Only handle button press */
	if (value != 1) return 0;

	/* Handle detail view separately */
	if (view->in_detail_view) {
		return media_view_handle_detail_button(m, type, button);
	}

	int old_idx = view->selected_idx;
	int cols = view->cols > 0 ? view->cols : 5;

	switch (button) {
	case BTN_DPAD_UP:
		if (view->selected_idx >= cols)
			view->selected_idx -= cols;
		break;
	case BTN_DPAD_DOWN:
		if (view->selected_idx + cols < view->item_count)
			view->selected_idx += cols;
		break;
	case BTN_DPAD_LEFT:
		if (view->selected_idx > 0)
			view->selected_idx--;
		break;
	case BTN_DPAD_RIGHT:
		if (view->selected_idx < view->item_count - 1)
			view->selected_idx++;
		break;
	case BTN_EAST:   /* B button - do nothing in grid view (main views can't be closed) */
		return 1;
	case BTN_MODE:   /* Guide button - let main handler show menu overlay */
		return 0;
	case BTN_SOUTH:  /* A button - enter detail view */
		media_view_enter_detail(m, type);
		return 1;
	case BTN_TL:     /* LB - scroll up */
		view->scroll_offset -= 200;
		if (view->scroll_offset < 0) view->scroll_offset = 0;
		break;
	case BTN_TR:     /* RB - scroll down */
		view->scroll_offset += 200;
		break;
	default:
		return 0;
	}

	if (view->selected_idx != old_idx || button == BTN_TL || button == BTN_TR) {
		media_view_render(m, type);
	}

	return 1;
}

/* Handle detail view keyboard input */
static int
media_view_handle_detail_key(Monitor *m, MediaViewType type, xkb_keysym_t sym)
{
	MediaGridView *view = media_get_view(m, type);
	if (!view) return 0;

	int needs_render = 0;

	switch (sym) {
	case XKB_KEY_Escape:
		media_view_exit_detail(m, type);
		return 1;

	case XKB_KEY_Return:
	case XKB_KEY_KP_Enter:
		if (type == MEDIA_VIEW_MOVIES) {
			/* Play movie */
			wlr_log(WLR_INFO, "Play movie: %s", view->detail_item ? view->detail_item->title : "unknown");
		} else if (type == MEDIA_VIEW_TVSHOWS) {
			if (view->detail_focus == DETAIL_FOCUS_EPISODES && view->episodes) {
				MediaItem *ep = view->episodes;
				for (int i = 0; i < view->selected_episode_idx && ep; i++)
					ep = ep->next;
				if (ep) {
					wlr_log(WLR_INFO, "Play episode: S%02dE%02d %s",
					        ep->season, ep->episode, ep->episode_title);
				}
			} else if (view->detail_focus == DETAIL_FOCUS_SEASONS) {
				view->detail_focus = DETAIL_FOCUS_EPISODES;
				view->selected_episode_idx = 0;
				needs_render = 1;
			}
		}
		break;

	case XKB_KEY_Up:
	case XKB_KEY_k:
		if (type == MEDIA_VIEW_TVSHOWS) {
			if (view->detail_focus == DETAIL_FOCUS_SEASONS) {
				if (view->selected_season_idx > 0) {
					view->selected_season_idx--;
					MediaSeason *s = view->seasons;
					for (int i = 0; i < view->selected_season_idx && s; i++)
						s = s->next;
					if (s) {
						view->selected_season = s->season;
						const char *show = view->detail_item->title[0] ?
						                   view->detail_item->title : view->detail_item->show_name;
						media_view_fetch_episodes(view, show, s->season);
						view->selected_episode_idx = 0;
						view->episode_scroll_offset = 0;
					}
					needs_render = 1;
				}
			} else if (view->detail_focus == DETAIL_FOCUS_EPISODES) {
				if (view->selected_episode_idx > 0) {
					view->selected_episode_idx--;
					needs_render = 1;
				}
			}
		}
		break;

	case XKB_KEY_Down:
	case XKB_KEY_j:
		if (type == MEDIA_VIEW_TVSHOWS) {
			if (view->detail_focus == DETAIL_FOCUS_SEASONS) {
				if (view->selected_season_idx < view->season_count - 1) {
					view->selected_season_idx++;
					MediaSeason *s = view->seasons;
					for (int i = 0; i < view->selected_season_idx && s; i++)
						s = s->next;
					if (s) {
						view->selected_season = s->season;
						const char *show = view->detail_item->title[0] ?
						                   view->detail_item->title : view->detail_item->show_name;
						media_view_fetch_episodes(view, show, s->season);
						view->selected_episode_idx = 0;
						view->episode_scroll_offset = 0;
					}
					needs_render = 1;
				}
			} else if (view->detail_focus == DETAIL_FOCUS_EPISODES) {
				if (view->selected_episode_idx < view->episode_count - 1) {
					view->selected_episode_idx++;
					needs_render = 1;
				}
			}
		}
		break;

	case XKB_KEY_Left:
	case XKB_KEY_h:
		if (type == MEDIA_VIEW_TVSHOWS) {
			if (view->detail_focus == DETAIL_FOCUS_EPISODES) {
				view->detail_focus = DETAIL_FOCUS_SEASONS;
				needs_render = 1;
			}
		}
		break;

	case XKB_KEY_Right:
	case XKB_KEY_l:
		if (type == MEDIA_VIEW_TVSHOWS) {
			if (view->detail_focus == DETAIL_FOCUS_SEASONS && view->episode_count > 0) {
				view->detail_focus = DETAIL_FOCUS_EPISODES;
				needs_render = 1;
			}
		}
		break;

	default:
		return 0;
	}

	if (needs_render) {
		media_view_render_detail(m, type);
	}

	return 1;
}

static int
media_view_handle_key(Monitor *m, MediaViewType type, xkb_keysym_t sym)
{
	MediaGridView *view;

	if (!m) return 0;

	view = media_get_view(m, type);
	if (!view) return 0;

	/* Only handle input if view is visible AND on current tag */
	if (!htpc_view_is_active(m, view->view_tag, view->visible)) return 0;

	/* Handle detail view separately */
	if (view->in_detail_view) {
		return media_view_handle_detail_key(m, type, sym);
	}

	int old_idx = view->selected_idx;
	int cols = view->cols > 0 ? view->cols : 5;

	switch (sym) {
	case XKB_KEY_Escape:
		/* Do nothing in grid view - main views can't be closed */
		return 1;
	case XKB_KEY_Return:
	case XKB_KEY_KP_Enter:
		/* Enter detail view */
		media_view_enter_detail(m, type);
		return 1;
	case XKB_KEY_Up:
	case XKB_KEY_k:
		if (view->selected_idx >= cols)
			view->selected_idx -= cols;
		break;
	case XKB_KEY_Down:
	case XKB_KEY_j:
		if (view->selected_idx + cols < view->item_count)
			view->selected_idx += cols;
		break;
	case XKB_KEY_Left:
	case XKB_KEY_h:
		if (view->selected_idx > 0)
			view->selected_idx--;
		break;
	case XKB_KEY_Right:
	case XKB_KEY_l:
		if (view->selected_idx < view->item_count - 1)
			view->selected_idx++;
		break;
	case XKB_KEY_Page_Up:
		view->scroll_offset -= 400;
		if (view->scroll_offset < 0) view->scroll_offset = 0;
		media_view_render(m, type);
		return 1;
	case XKB_KEY_Page_Down:
		view->scroll_offset += 400;
		media_view_render(m, type);
		return 1;
	default:
		return 0;
	}

	if (view->selected_idx != old_idx) {
		media_view_render(m, type);
	}

	return 1;
}

/* =========================================================== */
/* End Media Grid View */
/* =========================================================== */

/* Check if device is a gamepad (not keyboard/mouse) */
static int
gamepad_is_gamepad_device(int fd)
{
	unsigned long evbit[((EV_MAX) / (8 * sizeof(unsigned long))) + 1] = {0};
	unsigned long keybit[((KEY_MAX) / (8 * sizeof(unsigned long))) + 1] = {0};

	/* Get event types */
	if (ioctl(fd, EVIOCGBIT(0, sizeof(evbit)), evbit) < 0)
		return 0;

	/* Must have EV_KEY */
	if (!(evbit[0] & (1 << EV_KEY)))
		return 0;

	/* Get key capabilities */
	if (ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(keybit)), keybit) < 0)
		return 0;

	/* Check for gamepad-specific buttons */
	/* BTN_GAMEPAD is 0x130, BTN_SOUTH is 0x130, BTN_MODE is 0x13c */
	int has_gamepad_btn = 0;

	/* Check for BTN_SOUTH (A button) - 0x130 = 304 */
	if (keybit[BTN_SOUTH / (8 * sizeof(unsigned long))] & (1UL << (BTN_SOUTH % (8 * sizeof(unsigned long)))))
		has_gamepad_btn = 1;

	/* Check for BTN_MODE (guide button) - 0x13c = 316 */
	if (keybit[BTN_MODE / (8 * sizeof(unsigned long))] & (1UL << (BTN_MODE % (8 * sizeof(unsigned long)))))
		has_gamepad_btn = 1;

	/* Reject if it has typical keyboard keys (KEY_A through KEY_Z) */
	/* KEY_A = 30 */
	if (keybit[KEY_A / (8 * sizeof(unsigned long))] & (1UL << (KEY_A % (8 * sizeof(unsigned long)))))
		return 0;

	/* Reject if it has BTN_LEFT (mouse) - 0x110 = 272 */
	if (keybit[BTN_LEFT / (8 * sizeof(unsigned long))] & (1UL << (BTN_LEFT % (8 * sizeof(unsigned long)))))
		return 0;

	return has_gamepad_btn;
}

static int
gamepad_event_cb(int fd, uint32_t mask, void *data)
{
	GamepadDevice *gp = data;
	GamepadDevice *iter;
	struct input_event ev;
	Monitor *m;
	ssize_t n;
	int found = 0;

	if (!gp)
		return 0;

	/* Verify gp is still in the list (not already freed by inotify handler) */
	wl_list_for_each(iter, &gamepads, link) {
		if (iter == gp) {
			found = 1;
			break;
		}
	}
	if (!found)
		return 0;

	/* Handle device disconnection/error */
	if (mask & (WL_EVENT_ERROR | WL_EVENT_HANGUP)) {
		wlr_log(WLR_INFO, "Gamepad disconnected (fd event): %s (%s)", gp->name, gp->path);
		if (gp->event_source) {
			wl_event_source_remove(gp->event_source);
			gp->event_source = NULL;
		}
		if (gp->fd >= 0) {
			close(gp->fd);
			gp->fd = -1;
		}
		wl_list_remove(&gp->link);
		free(gp);
		return 0;
	}

	while ((n = read(fd, &ev, sizeof(ev))) == sizeof(ev)) {
		/* Skip sync events for activity tracking */
		if (ev.type == EV_SYN)
			continue;

		/* Update activity timestamp */
		gp->last_activity_ms = monotonic_msec();

		/* Handle wake from suspended state - guide button wakes the controller */
		if (gp->suspended) {
			if (ev.type == EV_KEY && ev.code == BTN_MODE && ev.value == 1) {
				gamepad_resume(gp);
			}
			continue;  /* Ignore other input while suspended */
		}

		/* Find the currently selected monitor */
		m = selmon ? selmon : (wl_list_empty(&mons) ? NULL :
			wl_container_of(mons.next, m, link));

		/* Handle key/button events */
		if (ev.type == EV_KEY) {
			if (m)
				gamepad_menu_handle_button(m, ev.code, ev.value);
			continue;
		}

		/* Handle axis events */
		if (ev.type == EV_ABS) {
			/* Joystick axes for cursor movement */
			switch (ev.code) {
			case ABS_X:
				gp->left_x = ev.value;
				break;
			case ABS_Y:
				gp->left_y = ev.value;
				break;
			case ABS_RX:
				gp->right_x = ev.value;
				break;
			case ABS_RY:
				gp->right_y = ev.value;
				break;
			case ABS_HAT0X:
				/* D-pad left/right for navigation */
				if (ev.value != 0) {
					int handled = 0;
					int button = ev.value < 0 ? BTN_DPAD_LEFT : BTN_DPAD_RIGHT;

					/* Check OSK first - highest priority */
					Monitor *osk_mon = osk_visible_monitor();
					if (osk_mon) {
						handled = osk_handle_button(osk_mon, button, 1);
						/* Start repeat timer for hold-to-slide */
						osk_dpad_repeat_start(osk_mon, button);
					}

					/* Check Retro gaming on any monitor (must be active on current tag) */
					Monitor *rg_mon = retro_gaming_visible_monitor();
					if (rg_mon && htpc_view_is_active(rg_mon, rg_mon->retro_gaming.view_tag, rg_mon->retro_gaming.visible)) {
						handled = retro_gaming_handle_button(rg_mon, button, 1);
					}

					/* Check PC gaming on any monitor */
					if (!handled) {
						Monitor *pg_mon = pc_gaming_visible_monitor();
						if (pg_mon && htpc_view_is_active(pg_mon, pg_mon->pc_gaming.view_tag, pg_mon->pc_gaming.visible)) {
							PcGamingView *pg = &pg_mon->pc_gaming;
							/* Handle install popup if visible */
							if (pg->install_popup_visible) {
								if (ev.value == -1 && pg->install_popup_selected > 0) {
									pg->install_popup_selected--;
									pc_gaming_install_popup_render(pg_mon);
									handled = 1;
								} else if (ev.value == 1 && pg->install_popup_selected < 1) {
									pg->install_popup_selected++;
									pc_gaming_install_popup_render(pg_mon);
									handled = 1;
								}
							} else {
								if (ev.value == -1 && pg->selected_idx > 0) {
									pg->selected_idx--;
									pc_gaming_render(pg_mon);
									handled = 1;
								} else if (ev.value == 1 && pg->selected_idx < pg->game_count - 1) {
									pg->selected_idx++;
									pc_gaming_render(pg_mon);
									handled = 1;
								}
							}
						}
					}

					/* Check Media views on any monitor */
					if (!handled) {
						Monitor *media_mon = media_view_visible_monitor();
						if (media_mon) {
							if (htpc_view_is_active(media_mon, media_mon->movies_view.view_tag, media_mon->movies_view.visible)) {
								media_view_handle_button(media_mon, MEDIA_VIEW_MOVIES, button, 1);
							} else if (htpc_view_is_active(media_mon, media_mon->tvshows_view.view_tag, media_mon->tvshows_view.visible)) {
								media_view_handle_button(media_mon, MEDIA_VIEW_TVSHOWS, button, 1);
							}
						}
					}
				} else {
					/* D-pad released - stop OSK repeat if active */
					if (osk_dpad_held_button == BTN_DPAD_LEFT || osk_dpad_held_button == BTN_DPAD_RIGHT)
						osk_dpad_repeat_stop();
				}
				break;
			case ABS_HAT0Y:
				/* D-pad up/down for menu/grid navigation */
				if (ev.value != 0) {
					int handled = 0;
					int button = ev.value < 0 ? BTN_DPAD_UP : BTN_DPAD_DOWN;

					/* Check OSK first - highest priority */
					Monitor *osk_mon_y = osk_visible_monitor();
					if (osk_mon_y) {
						handled = osk_handle_button(osk_mon_y, button, 1);
						/* Start repeat timer for hold-to-slide */
						osk_dpad_repeat_start(osk_mon_y, button);
					}

					/* Check gamepad menu on selmon first (uses m) */
					if (m && m->gamepad_menu.visible) {
						GamepadMenu *gm = &m->gamepad_menu;
						if (ev.value == -1 && gm->selected > 0) {
							gm->selected--;
							gamepad_menu_render(m);
							handled = 1;
						} else if (ev.value == 1 && gm->selected < gm->item_count - 1) {
							gm->selected++;
							gamepad_menu_render(m);
							handled = 1;
						}
					}

					/* Check Retro gaming on any monitor (must be active on current tag) */
					if (!handled) {
						Monitor *rg_mon = retro_gaming_visible_monitor();
						if (rg_mon && htpc_view_is_active(rg_mon, rg_mon->retro_gaming.view_tag, rg_mon->retro_gaming.visible)) {
							handled = retro_gaming_handle_button(rg_mon, button, 1);
						}
					}

					/* Check PC gaming on any monitor */
					if (!handled) {
						Monitor *pg_mon = pc_gaming_visible_monitor();
						if (pg_mon && htpc_view_is_active(pg_mon, pg_mon->pc_gaming.view_tag, pg_mon->pc_gaming.visible)) {
							PcGamingView *pg = &pg_mon->pc_gaming;
							/* Skip if install popup is visible */
							if (!pg->install_popup_visible) {
								if (ev.value == -1 && pg->selected_idx >= pg->cols) {
									pg->selected_idx -= pg->cols;
									pc_gaming_render(pg_mon);
									handled = 1;
								} else if (ev.value == 1 && pg->selected_idx + pg->cols < pg->game_count) {
									pg->selected_idx += pg->cols;
									pc_gaming_render(pg_mon);
									handled = 1;
								}
							}
						}
					}

					/* Check Media views on any monitor */
					if (!handled) {
						Monitor *media_mon = media_view_visible_monitor();
						if (media_mon) {
							if (htpc_view_is_active(media_mon, media_mon->movies_view.view_tag, media_mon->movies_view.visible)) {
								media_view_handle_button(media_mon, MEDIA_VIEW_MOVIES, button, 1);
							} else if (htpc_view_is_active(media_mon, media_mon->tvshows_view.view_tag, media_mon->tvshows_view.visible)) {
								media_view_handle_button(media_mon, MEDIA_VIEW_TVSHOWS, button, 1);
							}
						}
					}
				} else {
					/* D-pad released - stop OSK repeat if active */
					if (osk_dpad_held_button == BTN_DPAD_UP || osk_dpad_held_button == BTN_DPAD_DOWN)
						osk_dpad_repeat_stop();
				}
				break;
			}
		}
	}

	/* Check for read errors indicating device disconnection */
	if (n < 0 && errno != EAGAIN && errno != EWOULDBLOCK) {
		wlr_log(WLR_INFO, "Gamepad read error (errno=%d): %s (%s)", errno, gp->name, gp->path);
		if (gp->event_source) {
			wl_event_source_remove(gp->event_source);
			gp->event_source = NULL;
		}
		if (gp->fd >= 0) {
			close(gp->fd);
			gp->fd = -1;
		}
		wl_list_remove(&gp->link);
		free(gp);
		return 0;
	}

	return 0;
}

static void
gamepad_device_add(const char *path)
{
	GamepadDevice *gp, *existing;
	int fd;
	char name[128] = "Unknown";

	if (!path)
		return;

	/* Check if already added */
	wl_list_for_each(existing, &gamepads, link) {
		if (strcmp(existing->path, path) == 0)
			return;
	}

	fd = open(path, O_RDONLY | O_NONBLOCK | O_CLOEXEC);
	if (fd < 0)
		return;

	/* Check if it's a gamepad */
	if (!gamepad_is_gamepad_device(fd)) {
		close(fd);
		return;
	}

	/* Get device name */
	ioctl(fd, EVIOCGNAME(sizeof(name)), name);

	gp = ecalloc(1, sizeof(*gp));
	gp->fd = fd;
	snprintf(gp->path, sizeof(gp->path), "%s", path);
	snprintf(gp->name, sizeof(gp->name), "%s", name);

	/* Read axis calibration from device */
	struct input_absinfo absinfo;
	/* Left stick X */
	if (ioctl(fd, EVIOCGABS(ABS_X), &absinfo) == 0) {
		gp->cal_lx.min = absinfo.minimum;
		gp->cal_lx.max = absinfo.maximum;
		gp->cal_lx.center = (absinfo.minimum + absinfo.maximum) / 2;
		gp->cal_lx.flat = absinfo.flat;
		gp->left_x = gp->cal_lx.center;
	} else {
		gp->cal_lx.min = -32768; gp->cal_lx.max = 32767; gp->cal_lx.center = 0; gp->cal_lx.flat = 0;
		gp->left_x = 0;
	}
	/* Left stick Y */
	if (ioctl(fd, EVIOCGABS(ABS_Y), &absinfo) == 0) {
		gp->cal_ly.min = absinfo.minimum;
		gp->cal_ly.max = absinfo.maximum;
		gp->cal_ly.center = (absinfo.minimum + absinfo.maximum) / 2;
		gp->cal_ly.flat = absinfo.flat;
		gp->left_y = gp->cal_ly.center;
	} else {
		gp->cal_ly.min = -32768; gp->cal_ly.max = 32767; gp->cal_ly.center = 0; gp->cal_ly.flat = 0;
		gp->left_y = 0;
	}
	/* Right stick X */
	if (ioctl(fd, EVIOCGABS(ABS_RX), &absinfo) == 0) {
		gp->cal_rx.min = absinfo.minimum;
		gp->cal_rx.max = absinfo.maximum;
		gp->cal_rx.center = (absinfo.minimum + absinfo.maximum) / 2;
		gp->cal_rx.flat = absinfo.flat;
		gp->right_x = gp->cal_rx.center;
	} else {
		gp->cal_rx.min = -32768; gp->cal_rx.max = 32767; gp->cal_rx.center = 0; gp->cal_rx.flat = 0;
		gp->right_x = 0;
	}
	/* Right stick Y */
	if (ioctl(fd, EVIOCGABS(ABS_RY), &absinfo) == 0) {
		gp->cal_ry.min = absinfo.minimum;
		gp->cal_ry.max = absinfo.maximum;
		gp->cal_ry.center = (absinfo.minimum + absinfo.maximum) / 2;
		gp->cal_ry.flat = absinfo.flat;
		gp->right_y = gp->cal_ry.center;
	} else {
		gp->cal_ry.min = -32768; gp->cal_ry.max = 32767; gp->cal_ry.center = 0; gp->cal_ry.flat = 0;
		gp->right_y = 0;
	}

	wlr_log(WLR_INFO, "Gamepad calibration: LX[%d-%d c=%d], LY[%d-%d c=%d]",
		gp->cal_lx.min, gp->cal_lx.max, gp->cal_lx.center,
		gp->cal_ly.min, gp->cal_ly.max, gp->cal_ly.center);

	/* Initialize activity tracking */
	gp->last_activity_ms = monotonic_msec();
	gp->suspended = 0;
	gp->grabbed = 0;

	/* Don't grab gamepad - let Steam and other apps receive input normally */

	/* Add to event loop */
	gp->event_source = wl_event_loop_add_fd(event_loop, fd,
		WL_EVENT_READABLE, gamepad_event_cb, gp);

	/* Start timers if this is the first gamepad */
	if (wl_list_empty(&gamepads)) {
		if (gamepad_cursor_timer)
			wl_event_source_timer_update(gamepad_cursor_timer, GAMEPAD_CURSOR_INTERVAL_MS);
		if (gamepad_inactivity_timer)
			wl_event_source_timer_update(gamepad_inactivity_timer, GAMEPAD_INACTIVITY_CHECK_MS);
	}

	wl_list_insert(&gamepads, &gp->link);

	wlr_log(WLR_INFO, "Gamepad connected: %s (%s)", name, path);

	/* Enter HTPC mode when controller connects (if mode == 1) */
	if (htpc_mode == 1)
		htpc_mode_enter();

	/* Switch TV/Monitor to this HDMI input via CEC */
	cec_switch_to_active_source();

	/* Update grab state for new gamepad (grab if in HTPC mode on non-Steam tag) */
	gamepad_update_grab_state();
}

static void
gamepad_device_remove(const char *path)
{
	GamepadDevice *gp, *tmp;

	if (!path)
		return;

	wl_list_for_each_safe(gp, tmp, &gamepads, link) {
		if (strcmp(gp->path, path) == 0) {
			wlr_log(WLR_INFO, "Gamepad disconnected: %s (%s)", gp->name, gp->path);
			if (gp->event_source)
				wl_event_source_remove(gp->event_source);
			if (gp->fd >= 0)
				close(gp->fd);
			wl_list_remove(&gp->link);
			free(gp);
			return;
		}
	}
}

/* Grab exclusive access to gamepad (prevents Steam from receiving input) */
static void
gamepad_grab(GamepadDevice *gp)
{
	if (!gp || gp->fd < 0 || gp->grabbed)
		return;

	if (ioctl(gp->fd, EVIOCGRAB, 1) == 0) {
		gp->grabbed = 1;
		wlr_log(WLR_INFO, "Gamepad grabbed: %s", gp->name);
	}
}

/* Release exclusive access to gamepad (allows Steam to receive input) */
static void
gamepad_ungrab(GamepadDevice *gp)
{
	if (!gp || gp->fd < 0 || !gp->grabbed)
		return;

	if (ioctl(gp->fd, EVIOCGRAB, 0) == 0) {
		gp->grabbed = 0;
		wlr_log(WLR_INFO, "Gamepad ungrabbed: %s", gp->name);
	}
}

/*
 * Determine if nixlytile should grab gamepads.
 * We grab when we need the input (HTPC views on non-Steam tags).
 * We release when Steam/games need it (Steam focused or on Steam tag).
 */
static int
gamepad_should_grab(void)
{
	Client *focused;
	unsigned int steam_tag;

	/* Only grab in HTPC mode */
	if (!htpc_mode_active)
		return 0;

	/* Steam is on tag 4 (index 3) */
	steam_tag = 1 << 3;

	/* If we're on the Steam tag, let Steam have the gamepad */
	if (selmon && (selmon->tagset[selmon->seltags] & steam_tag))
		return 0;

	/* If Steam or a Steam game is focused, let it have the gamepad */
	focused = focustop(selmon);
	if (focused && (is_steam_client(focused) || is_steam_game(focused)))
		return 0;

	/* We're on a non-Steam tag in HTPC mode - grab for our UI */
	return 1;
}

/* Update grab state for all gamepads based on current context */
static void
gamepad_update_grab_state(void)
{
	GamepadDevice *gp;
	int should_grab;

	should_grab = gamepad_should_grab();

	wl_list_for_each(gp, &gamepads, link) {
		if (gp->suspended)
			continue;
		if (should_grab && !gp->grabbed) {
			gamepad_grab(gp);
		} else if (!should_grab && gp->grabbed) {
			gamepad_ungrab(gp);
		}
	}
}

/* Timer callback to process pending gamepad devices */
static int
gamepad_pending_timer_cb(void *data)
{
	int i;

	(void)data;

	for (i = 0; i < gamepad_pending_count; i++) {
		gamepad_device_add(gamepad_pending_paths[i]);
	}
	gamepad_pending_count = 0;

	return 0;
}

static int
gamepad_inotify_cb(int fd, uint32_t mask, void *data)
{
	char buf[4096] __attribute__((aligned(__alignof__(struct inotify_event))));
	const struct inotify_event *event;
	ssize_t len;
	char *ptr;
	char path[128];
	int schedule_pending = 0;

	(void)mask;
	(void)data;

	while ((len = read(fd, buf, sizeof(buf))) > 0) {
		for (ptr = buf; ptr < buf + len;
		     ptr += sizeof(struct inotify_event) + event->len) {
			event = (const struct inotify_event *)ptr;

			/* Only interested in event* files */
			if (!event->name || strncmp(event->name, "event", 5) != 0)
				continue;

			snprintf(path, sizeof(path), "/dev/input/%s", event->name);

			if (event->mask & IN_CREATE) {
				/* Queue device for delayed add (non-blocking) */
				if (gamepad_pending_count < GAMEPAD_PENDING_MAX) {
					snprintf(gamepad_pending_paths[gamepad_pending_count],
						sizeof(gamepad_pending_paths[0]), "%s", path);
					gamepad_pending_count++;
					schedule_pending = 1;
				}
			} else if (event->mask & IN_DELETE) {
				gamepad_device_remove(path);
			}
		}
	}

	/* Schedule timer to add pending devices after delay */
	if (schedule_pending && gamepad_pending_timer) {
		wl_event_source_timer_update(gamepad_pending_timer, 100); /* 100ms */
	}

	return 0;
}

static void
gamepad_scan_devices(void)
{
	DIR *dir;
	struct dirent *entry;
	char path[128];

	dir = opendir("/dev/input");
	if (!dir)
		return;

	while ((entry = readdir(dir)) != NULL) {
		if (strncmp(entry->d_name, "event", 5) != 0)
			continue;

		snprintf(path, sizeof(path), "/dev/input/%s", entry->d_name);
		gamepad_device_add(path);
	}

	closedir(dir);
}

/* Joystick navigation state for PC gaming view */
static uint64_t joystick_nav_last_move = 0;
static int joystick_nav_repeat_started = 0;
#define JOYSTICK_NAV_INITIAL_DELAY 300  /* ms before repeat starts */
#define JOYSTICK_NAV_REPEAT_RATE 150    /* ms between repeats */

/* Update cursor position based on joystick input from all gamepads */
static void
gamepad_update_cursor(void)
{
	GamepadDevice *gp;
	double total_dx = 0, total_dy = 0;
	int any_input = 0;
	uint64_t now = monotonic_msec();

	if (wl_list_empty(&gamepads))
		return;

	/* Handle Retro gaming view joystick navigation */
	if (selmon && htpc_view_is_active(selmon, selmon->retro_gaming.view_tag, selmon->retro_gaming.visible)) {
		int nav_x = 0;

		/* Read joystick values from all gamepads */
		wl_list_for_each(gp, &gamepads, link) {
			if (gp->suspended)
				continue;

			int lx_offset = gp->left_x - gp->cal_lx.center;
			int lx_range = (gp->cal_lx.max - gp->cal_lx.min) / 2;
			if (lx_range == 0) lx_range = 32767;

			/* Threshold at 50% deflection for navigation */
			int nav_threshold = lx_range / 2;

			if (lx_offset < -nav_threshold) nav_x = -1;
			else if (lx_offset > nav_threshold) nav_x = 1;
		}

		/* Handle navigation with repeat */
		if (nav_x != 0) {
			uint64_t delay = joystick_nav_repeat_started ? JOYSTICK_NAV_REPEAT_RATE : JOYSTICK_NAV_INITIAL_DELAY;

			if (joystick_nav_last_move == 0 || (now - joystick_nav_last_move) >= delay) {
				joystick_nav_last_move = now;
				joystick_nav_repeat_started = 1;
				retro_gaming_handle_button(selmon, nav_x < 0 ? BTN_DPAD_LEFT : BTN_DPAD_RIGHT, 1);
			}
		} else {
			/* Reset repeat state when joystick returns to center */
			joystick_nav_last_move = 0;
			joystick_nav_repeat_started = 0;
		}

		/* Right joystick scrolls in retro gaming view */
		wl_list_for_each(gp, &gamepads, link) {
			if (gp->suspended)
				continue;

			int ry_offset = gp->right_y - gp->cal_ry.center;
			int ry_range = (gp->cal_ry.max - gp->cal_ry.min) / 2;
			if (ry_range == 0) ry_range = 32767;
			int ry_deadzone = gp->cal_ry.flat > 0 ? gp->cal_ry.flat : (ry_range * GAMEPAD_DEADZONE / 32767);

			if (abs(ry_offset) > ry_deadzone) {
				double ny = (double)ry_offset / (double)ry_range;
				if (ny > 1.0) ny = 1.0;
				if (ny < -1.0) ny = -1.0;

				double scroll_amount = ny * 3.0;
				uint32_t time_msec = (uint32_t)(monotonic_msec() & 0xFFFFFFFF);

				wlr_seat_pointer_notify_axis(seat, time_msec,
					WL_POINTER_AXIS_VERTICAL_SCROLL,
					scroll_amount, (int32_t)(scroll_amount * 120),
					WL_POINTER_AXIS_SOURCE_CONTINUOUS,
					WL_POINTER_AXIS_RELATIVE_DIRECTION_IDENTICAL);
			}
		}

		return;
	}

	/* Handle PC gaming view joystick navigation */
	if (selmon && htpc_view_is_active(selmon, selmon->pc_gaming.view_tag, selmon->pc_gaming.visible)) {
		PcGamingView *pg = &selmon->pc_gaming;
		Client *popup_client = focustop(selmon);

		/* If a window has focus (e.g. Steam install dialog), allow mouse control */
		if (popup_client && !popup_client->isfullscreen) {
			/* Show cursor when controlling popup window */
			wlr_cursor_set_xcursor(cursor, cursor_mgr, "default");
			/* Fall through to normal mouse control code below */
		} else {
			/* No popup window - use grid navigation */
			int nav_x = 0, nav_y = 0;

			/* Read joystick values from all gamepads */
			wl_list_for_each(gp, &gamepads, link) {
				if (gp->suspended)
					continue;

				int lx_offset = gp->left_x - gp->cal_lx.center;
				int ly_offset = gp->left_y - gp->cal_ly.center;
				int lx_range = (gp->cal_lx.max - gp->cal_lx.min) / 2;
				int ly_range = (gp->cal_ly.max - gp->cal_ly.min) / 2;
				if (lx_range == 0) lx_range = 32767;
				if (ly_range == 0) ly_range = 32767;
				int lx_deadzone = gp->cal_lx.flat > 0 ? gp->cal_lx.flat : (lx_range * GAMEPAD_DEADZONE / 32767);
				int ly_deadzone = gp->cal_ly.flat > 0 ? gp->cal_ly.flat : (ly_range * GAMEPAD_DEADZONE / 32767);

				/* Threshold at 50% deflection for navigation */
				int nav_threshold_x = lx_range / 2;
				int nav_threshold_y = ly_range / 2;

				if (lx_offset < -nav_threshold_x) nav_x = -1;
				else if (lx_offset > nav_threshold_x) nav_x = 1;
				if (ly_offset < -nav_threshold_y) nav_y = -1;
				else if (ly_offset > nav_threshold_y) nav_y = 1;
			}

			/* Handle navigation with repeat */
			if (nav_x != 0 || nav_y != 0) {
				int should_move = 0;
				uint64_t delay = joystick_nav_repeat_started ? JOYSTICK_NAV_REPEAT_RATE : JOYSTICK_NAV_INITIAL_DELAY;

				if (joystick_nav_last_move == 0 || (now - joystick_nav_last_move) >= delay) {
					should_move = 1;
					joystick_nav_last_move = now;
					joystick_nav_repeat_started = 1;
				}

				if (should_move) {
					if (pg->install_popup_visible) {
						/* Navigate install popup */
						if (nav_x == -1 && pg->install_popup_selected > 0) {
							pg->install_popup_selected--;
							pc_gaming_install_popup_render(selmon);
						} else if (nav_x == 1 && pg->install_popup_selected < 1) {
							pg->install_popup_selected++;
							pc_gaming_install_popup_render(selmon);
						}
					} else {
						/* Navigate game grid */
						int new_idx = pg->selected_idx;
						if (nav_x == -1 && new_idx > 0)
							new_idx--;
						else if (nav_x == 1 && new_idx < pg->game_count - 1)
							new_idx++;
						if (nav_y == -1 && new_idx >= pg->cols)
							new_idx -= pg->cols;
						else if (nav_y == 1 && new_idx + pg->cols < pg->game_count)
							new_idx += pg->cols;

						if (new_idx != pg->selected_idx) {
							pg->selected_idx = new_idx;
							pc_gaming_render(selmon);
						}
					}
				}
			} else {
				/* Reset repeat state when joystick returns to center */
				joystick_nav_last_move = 0;
				joystick_nav_repeat_started = 0;
			}

			/* Right joystick scrolls in PC gaming view */
			wl_list_for_each(gp, &gamepads, link) {
				if (gp->suspended)
					continue;

				int ry_offset = gp->right_y - gp->cal_ry.center;
				int ry_range = (gp->cal_ry.max - gp->cal_ry.min) / 2;
				if (ry_range == 0) ry_range = 32767;
				int ry_deadzone = gp->cal_ry.flat > 0 ? gp->cal_ry.flat : (ry_range * GAMEPAD_DEADZONE / 32767);

				if (abs(ry_offset) > ry_deadzone) {
					double ny = (double)ry_offset / (double)ry_range;
					if (ny > 1.0) ny = 1.0;
					if (ny < -1.0) ny = -1.0;

					double scroll_amount = ny * 3.0;
					uint32_t time_msec = (uint32_t)(monotonic_msec() & 0xFFFFFFFF);

					wlr_seat_pointer_notify_axis(seat, time_msec,
						WL_POINTER_AXIS_VERTICAL_SCROLL,
						scroll_amount, (int32_t)(scroll_amount * 120),
						WL_POINTER_AXIS_SOURCE_CONTINUOUS,
						WL_POINTER_AXIS_RELATIVE_DIRECTION_IDENTICAL);
				}
			}

			/* Don't move mouse cursor while in PC gaming view without popup */
			return;
		}
	}

	/* Handle Media views (Movies/TV-shows) joystick navigation */
	{
		Monitor *media_mon = media_view_visible_monitor();
		if (media_mon) {
			MediaGridView *view = NULL;
			MediaViewType view_type = MEDIA_VIEW_MOVIES;

			if (htpc_view_is_active(media_mon, media_mon->movies_view.view_tag, media_mon->movies_view.visible)) {
				view = &media_mon->movies_view;
				view_type = MEDIA_VIEW_MOVIES;
			} else if (htpc_view_is_active(media_mon, media_mon->tvshows_view.view_tag, media_mon->tvshows_view.visible)) {
				view = &media_mon->tvshows_view;
				view_type = MEDIA_VIEW_TVSHOWS;
			}

			if (view) {
				int nav_x = 0, nav_y = 0;

				/* Read joystick values from all gamepads */
				wl_list_for_each(gp, &gamepads, link) {
					if (gp->suspended)
						continue;

					int lx_offset = gp->left_x - gp->cal_lx.center;
					int ly_offset = gp->left_y - gp->cal_ly.center;
					int lx_range = (gp->cal_lx.max - gp->cal_lx.min) / 2;
					int ly_range = (gp->cal_ly.max - gp->cal_ly.min) / 2;
					if (lx_range == 0) lx_range = 32767;
					if (ly_range == 0) ly_range = 32767;

					/* Threshold at 50% deflection for navigation */
					int nav_threshold_x = lx_range / 2;
					int nav_threshold_y = ly_range / 2;

					if (lx_offset < -nav_threshold_x) nav_x = -1;
					else if (lx_offset > nav_threshold_x) nav_x = 1;
					if (ly_offset < -nav_threshold_y) nav_y = -1;
					else if (ly_offset > nav_threshold_y) nav_y = 1;
				}

				/* Handle navigation with repeat */
				if (nav_x != 0 || nav_y != 0) {
					int should_move = 0;
					uint64_t delay = joystick_nav_repeat_started ? JOYSTICK_NAV_REPEAT_RATE : JOYSTICK_NAV_INITIAL_DELAY;

					if (joystick_nav_last_move == 0 || (now - joystick_nav_last_move) >= delay) {
						should_move = 1;
						joystick_nav_last_move = now;
						joystick_nav_repeat_started = 1;
					}

					if (should_move) {
						/* Handle detail view navigation for TV shows */
						if (view->in_detail_view && view_type == MEDIA_VIEW_TVSHOWS) {
							int needs_render = 0;

							/* Left/Right switches between seasons and episodes */
							if (nav_x == -1 && view->detail_focus == DETAIL_FOCUS_EPISODES) {
								view->detail_focus = DETAIL_FOCUS_SEASONS;
								needs_render = 1;
							} else if (nav_x == 1 && view->detail_focus == DETAIL_FOCUS_SEASONS && view->episode_count > 0) {
								view->detail_focus = DETAIL_FOCUS_EPISODES;
								needs_render = 1;
							}

							/* Up/Down navigates within the current column */
							if (view->detail_focus == DETAIL_FOCUS_SEASONS) {
								if (nav_y == -1 && view->selected_season_idx > 0) {
									view->selected_season_idx--;
									MediaSeason *s = view->seasons;
									for (int i = 0; i < view->selected_season_idx && s; i++)
										s = s->next;
									if (s) {
										view->selected_season = s->season;
										const char *show = view->detail_item->title[0] ?
										                   view->detail_item->title : view->detail_item->show_name;
										media_view_fetch_episodes(view, show, s->season);
										view->selected_episode_idx = 0;
										view->episode_scroll_offset = 0;
									}
									needs_render = 1;
								} else if (nav_y == 1 && view->selected_season_idx < view->season_count - 1) {
									view->selected_season_idx++;
									MediaSeason *s = view->seasons;
									for (int i = 0; i < view->selected_season_idx && s; i++)
										s = s->next;
									if (s) {
										view->selected_season = s->season;
										const char *show = view->detail_item->title[0] ?
										                   view->detail_item->title : view->detail_item->show_name;
										media_view_fetch_episodes(view, show, s->season);
										view->selected_episode_idx = 0;
										view->episode_scroll_offset = 0;
									}
									needs_render = 1;
								}
							} else if (view->detail_focus == DETAIL_FOCUS_EPISODES) {
								if (nav_y == -1 && view->selected_episode_idx > 0) {
									view->selected_episode_idx--;
									needs_render = 1;
								} else if (nav_y == 1 && view->selected_episode_idx < view->episode_count - 1) {
									view->selected_episode_idx++;
									needs_render = 1;
								}
							}

							if (needs_render)
								media_view_render_detail(media_mon, view_type);
						} else {
							/* Grid view navigation */
							int cols = view->cols > 0 ? view->cols : 5;
							int old_idx = view->selected_idx;

							if (nav_x == -1 && view->selected_idx > 0)
								view->selected_idx--;
							else if (nav_x == 1 && view->selected_idx < view->item_count - 1)
								view->selected_idx++;
							if (nav_y == -1 && view->selected_idx >= cols)
								view->selected_idx -= cols;
							else if (nav_y == 1 && view->selected_idx + cols < view->item_count)
								view->selected_idx += cols;

							if (view->selected_idx != old_idx)
								media_view_render(media_mon, view_type);
						}
					}
				} else {
					/* Reset repeat state when joystick returns to center */
					joystick_nav_last_move = 0;
					joystick_nav_repeat_started = 0;
				}

				/* Right joystick scrolls in media view */
				wl_list_for_each(gp, &gamepads, link) {
					if (gp->suspended)
						continue;

					int ry_offset = gp->right_y - gp->cal_ry.center;
					int ry_range = (gp->cal_ry.max - gp->cal_ry.min) / 2;
					if (ry_range == 0) ry_range = 32767;
					int ry_deadzone = gp->cal_ry.flat > 0 ? gp->cal_ry.flat : (ry_range * GAMEPAD_DEADZONE / 32767);

					if (abs(ry_offset) > ry_deadzone) {
						double ny = (double)ry_offset / (double)ry_range;
						if (ny > 1.0) ny = 1.0;
						if (ny < -1.0) ny = -1.0;

						double scroll_amount = ny * 3.0;
						uint32_t time_msec = (uint32_t)(monotonic_msec() & 0xFFFFFFFF);

						wlr_seat_pointer_notify_axis(seat, time_msec,
							WL_POINTER_AXIS_VERTICAL_SCROLL,
							scroll_amount, (int32_t)(scroll_amount * 120),
							WL_POINTER_AXIS_SOURCE_CONTINUOUS,
							WL_POINTER_AXIS_RELATIVE_DIRECTION_IDENTICAL);
					}
				}

				/* Don't move mouse cursor while in media view */
				return;
			}
		}
	}

	/* Check if we should skip cursor movement for fullscreen clients
	 * (let game handle joystick input), but always allow right stick scrolling */
	int skip_cursor_move = 0;
	Client *focused = focustop(selmon);
	if (focused && focused->isfullscreen) {
		/* In HTPC mode, allow cursor control for browsers (kiosk mode) */
		if (htpc_mode_active && is_browser_client(focused)) {
			/* Browser in fullscreen - allow gamepad cursor control and scroll */
		} else if (htpc_mode_active) {
			/* Check for Steam popup that needs mouse control */
			Client *popup = NULL;
			Client *c;
			wl_list_for_each(c, &clients, link) {
				if (c->isfloating && !c->isfullscreen && is_steam_popup(c)) {
					popup = c;
					break;
				}
			}
			if (!popup) {
				/* No popup - skip cursor but still allow scroll for focused client */
				skip_cursor_move = 1;
			}
			/* There's a Steam popup - allow mouse control below */
		} else if (is_browser_client(focused)) {
			/* Browser fullscreen outside HTPC mode - still allow scroll */
		} else {
			/* Fullscreen game - skip cursor but allow scroll to pass through */
			skip_cursor_move = 1;
		}
	}

	/* Also skip cursor movement if physical mouse was used recently */
	if (last_pointer_motion_ms && (now - last_pointer_motion_ms) < 100)
		skip_cursor_move = 1;

	/* Collect scroll input from right sticks */
	double scroll_x = 0, scroll_y = 0;
	int any_scroll = 0;

	wl_list_for_each(gp, &gamepads, link) {
		double dx = 0, dy = 0;
		double magnitude, normalized;

		/* Skip suspended gamepads */
		if (gp->suspended)
			continue;

		/* Normalize axis values relative to calibrated center */
		int lx_offset = gp->left_x - gp->cal_lx.center;
		int ly_offset = gp->left_y - gp->cal_ly.center;

		/* Calculate range for normalization (half the total range) */
		int lx_range = (gp->cal_lx.max - gp->cal_lx.min) / 2;
		int ly_range = (gp->cal_ly.max - gp->cal_ly.min) / 2;
		if (lx_range == 0) lx_range = 32767;
		if (ly_range == 0) ly_range = 32767;

		/* Calculate deadzone threshold based on device flat value or default */
		int lx_deadzone = gp->cal_lx.flat > 0 ? gp->cal_lx.flat : (lx_range * GAMEPAD_DEADZONE / 32767);
		int ly_deadzone = gp->cal_ly.flat > 0 ? gp->cal_ly.flat : (ly_range * GAMEPAD_DEADZONE / 32767);

		/* Apply deadzone to left stick */
		if (abs(lx_offset) > lx_deadzone || abs(ly_offset) > ly_deadzone) {
			/* Normalize to -1.0 to 1.0 range based on calibration */
			double nx = (double)lx_offset / (double)lx_range;
			double ny = (double)ly_offset / (double)ly_range;

			/* Clamp values */
			if (nx > 1.0) nx = 1.0;
			if (nx < -1.0) nx = -1.0;
			if (ny > 1.0) ny = 1.0;
			if (ny < -1.0) ny = -1.0;

			/* Calculate magnitude for acceleration */
			magnitude = sqrt(nx * nx + ny * ny);
			if (magnitude > 1.0)
				magnitude = 1.0;

			/* Apply acceleration curve (higher values accelerate more) */
			normalized = magnitude * magnitude * GAMEPAD_CURSOR_ACCEL;
			if (normalized < 1.0)
				normalized = 1.0;

			/* Calculate delta movement */
			dx = nx * GAMEPAD_CURSOR_SPEED * normalized;
			dy = ny * GAMEPAD_CURSOR_SPEED * normalized;

			any_input = 1;
		}

		/* Right stick - normalize relative to calibrated center */
		int rx_offset = gp->right_x - gp->cal_rx.center;
		int ry_offset = gp->right_y - gp->cal_ry.center;
		int rx_range = (gp->cal_rx.max - gp->cal_rx.min) / 2;
		int ry_range = (gp->cal_ry.max - gp->cal_ry.min) / 2;
		if (rx_range == 0) rx_range = 32767;
		if (ry_range == 0) ry_range = 32767;
		int rx_deadzone = gp->cal_rx.flat > 0 ? gp->cal_rx.flat : (rx_range * GAMEPAD_DEADZONE / 32767);
		int ry_deadzone = gp->cal_ry.flat > 0 ? gp->cal_ry.flat : (ry_range * GAMEPAD_DEADZONE / 32767);

		/* Collect right stick scroll values */
		if (abs(ry_offset) > ry_deadzone) {
			double ny = (double)ry_offset / (double)ry_range;
			if (ny > 1.0) ny = 1.0;
			if (ny < -1.0) ny = -1.0;
			scroll_y += ny * 3.0;
			any_scroll = 1;
		}

		if (abs(rx_offset) > rx_deadzone) {
			double nx = (double)rx_offset / (double)rx_range;
			if (nx > 1.0) nx = 1.0;
			if (nx < -1.0) nx = -1.0;
			scroll_x += nx * 3.0;
			any_scroll = 1;
		}

		total_dx += dx;
		total_dy += dy;
	}

	/* Move cursor if there's any input (skip if physical mouse was used recently) */
	if (!skip_cursor_move && any_input && cursor && (fabs(total_dx) > 0.1 || fabs(total_dy) > 0.1)) {
		/* Move cursor directly (fast) */
		wlr_cursor_move(cursor, NULL, total_dx, total_dy);
		wlr_idle_notifier_v1_notify_activity(idle_notifier, seat);

		/* Update hover feedback for statusbar */
		if (selmon && selmon->showbar) {
			updatetaghover(selmon, cursor->x, cursor->y);
			updatenethover(selmon, cursor->x, cursor->y);
		}
	}

	/* Update pointer focus for cursor movement */
	if (!skip_cursor_move && any_input && cursor) {
		double sx, sy;
		struct wlr_surface *surface = NULL;
		Client *c = NULL;
		xytonode(cursor->x, cursor->y, &surface, &c, NULL, &sx, &sy);
		if (surface) {
			uint32_t time_msec = (uint32_t)(now & 0xFFFFFFFF);
			wlr_seat_pointer_notify_enter(seat, surface, sx, sy);
			wlr_seat_pointer_notify_motion(seat, time_msec, sx, sy);
		}
	}

	/* Send scroll events to focused window (not cursor position) */
	if (any_scroll) {
		Client *scroll_target = focustop(selmon);
		if (scroll_target && client_surface(scroll_target) && client_surface(scroll_target)->mapped) {
			struct wlr_surface *target_surface = client_surface(scroll_target);
			uint32_t time_msec = (uint32_t)(now & 0xFFFFFFFF);

			/* Calculate surface-local coordinates (center of window) */
			double sx = scroll_target->geom.width / 2.0;
			double sy = scroll_target->geom.height / 2.0;

			/* Enter pointer focus on the focused window for scroll events */
			wlr_seat_pointer_notify_enter(seat, target_surface, sx, sy);

			if (fabs(scroll_y) > 0.01) {
				wlr_seat_pointer_notify_axis(seat, time_msec,
					WL_POINTER_AXIS_VERTICAL_SCROLL,
					scroll_y, (int32_t)(scroll_y * 120),
					WL_POINTER_AXIS_SOURCE_CONTINUOUS,
					WL_POINTER_AXIS_RELATIVE_DIRECTION_IDENTICAL);
			}
			if (fabs(scroll_x) > 0.01) {
				wlr_seat_pointer_notify_axis(seat, time_msec,
					WL_POINTER_AXIS_HORIZONTAL_SCROLL,
					scroll_x, (int32_t)(scroll_x * 120),
					WL_POINTER_AXIS_SOURCE_CONTINUOUS,
					WL_POINTER_AXIS_RELATIVE_DIRECTION_IDENTICAL);
			}
			wlr_idle_notifier_v1_notify_activity(idle_notifier, seat);
		}
	}
}

static int
gamepad_cursor_timer_cb(void *data)
{
	GamepadDevice *gp;
	Monitor *m;
	int64_t now;

	(void)data;

	/* Update cursor position */
	gamepad_update_cursor();


	/* Reschedule timer if we have gamepads */
	if (!wl_list_empty(&gamepads) && gamepad_cursor_timer) {
		wl_event_source_timer_update(gamepad_cursor_timer, GAMEPAD_CURSOR_INTERVAL_MS);
	}

	return 0;
}

/* Switch TV/Monitor to this device via HDMI-CEC */
static void
cec_switch_to_active_source(void)
{
	pid_t pid;

	wlr_log(WLR_INFO, "Switching TV to active source via CEC");

	pid = fork();
	if (pid == 0) {
		/* Child process */
		int fd;

		setsid();
		fd = open("/dev/null", O_RDWR);
		if (fd >= 0) {
			dup2(fd, STDIN_FILENO);
			dup2(fd, STDOUT_FILENO);
			dup2(fd, STDERR_FILENO);
			if (fd > 2)
				close(fd);
		}

		/* Send "active source" command via cec-client
		 * "as" = Active Source - tells TV to switch to this input
		 * -s = single command mode
		 * -d 1 = minimal output */
		execlp("sh", "sh", "-c",
			"echo 'as' | cec-client -s -d 1 2>/dev/null || "
			"echo 'tx 4F:82:10:00' | cec-client -s -d 1 2>/dev/null",
			(char *)NULL);
		_exit(0);
	}
	/* Parent doesn't wait - fire and forget */
}

/* ============================================================================
 * Bluetooth Controller Auto-Pairing
 * ============================================================================ */

/* Check if device name matches known gamepad patterns */
static int
bt_is_gamepad_name(const char *name)
{
	int i;

	if (!name || !*name)
		return 0;

	for (i = 0; bt_gamepad_patterns[i]; i++) {
		if (strcasestr(name, bt_gamepad_patterns[i]))
			return 1;
	}
	return 0;
}

/* Trust a Bluetooth device (allows auto-reconnect) */
static void
bt_trust_device(const char *path)
{
	sd_bus_error error = SD_BUS_ERROR_NULL;
	int r;

	if (!bt_bus || !path)
		return;

	/* This is a quick local operation, keep synchronous */
	r = sd_bus_set_property(bt_bus, "org.bluez", path,
		"org.bluez.Device1", "Trusted",
		&error, "b", 1);

	if (r < 0)
		wlr_log(WLR_DEBUG, "Failed to trust %s: %s", path, error.message);

	sd_bus_error_free(&error);
}

/* Async callback for Pair method */
static int
bt_pair_cb(sd_bus_message *reply, void *userdata, sd_bus_error *error)
{
	char *path = userdata;

	if (sd_bus_error_is_set(error)) {
		/* AlreadyExists means already paired - that's fine */
		if (!strstr(error->message, "AlreadyExists"))
			wlr_log(WLR_DEBUG, "Pairing failed for %s: %s", path ? path : "unknown", error->message);
	} else {
		wlr_log(WLR_INFO, "Paired with: %s", path ? path : "unknown");
	}

	free(path);
	return 0;
}

/* Pair with a Bluetooth device (async) */
static void
bt_pair_device(const char *path)
{
	int r;
	char *path_copy;

	if (!bt_bus || !path)
		return;

	wlr_log(WLR_INFO, "Pairing with Bluetooth device: %s", path);

	/* First trust the device (quick operation) */
	bt_trust_device(path);

	/* Then pair asynchronously */
	path_copy = strdup(path);
	if (!path_copy)
		return;

	r = sd_bus_call_method_async(bt_bus, NULL,
		"org.bluez", path,
		"org.bluez.Device1", "Pair",
		bt_pair_cb, path_copy, "");

	if (r < 0) {
		wlr_log(WLR_DEBUG, "Failed to start async Pair: %s", strerror(-r));
		free(path_copy);
	}
}

/* Async callback for Connect method */
static int
bt_connect_cb(sd_bus_message *reply, void *userdata, sd_bus_error *error)
{
	char *path = userdata;

	if (sd_bus_error_is_set(error)) {
		wlr_log(WLR_DEBUG, "Connect failed for %s: %s", path ? path : "unknown", error->message);
	} else {
		wlr_log(WLR_INFO, "Connected to: %s", path ? path : "unknown");
	}

	free(path);
	return 0;
}

/* Connect to a paired Bluetooth device (async) */
static void
bt_connect_device(const char *path)
{
	int r;
	char *path_copy;

	if (!bt_bus || !path)
		return;

	wlr_log(WLR_INFO, "Connecting to Bluetooth device: %s", path);

	path_copy = strdup(path);
	if (!path_copy)
		return;

	r = sd_bus_call_method_async(bt_bus, NULL,
		"org.bluez", path,
		"org.bluez.Device1", "Connect",
		bt_connect_cb, path_copy, "");

	if (r < 0) {
		wlr_log(WLR_DEBUG, "Failed to start async Connect: %s", strerror(-r));
		free(path_copy);
	}
}

/* Handle new device discovery signal from BlueZ */
static int
bt_device_signal_cb(sd_bus_message *m, void *userdata, sd_bus_error *error)
{
	const char *path;
	const char *interface;
	int r;

	(void)userdata;
	(void)error;

	/* Get object path */
	path = sd_bus_message_get_path(m);
	if (!path || !strstr(path, "/org/bluez/"))
		return 0;

	/* Parse InterfacesAdded signal */
	r = sd_bus_message_read(m, "s", &interface);
	if (r < 0)
		return 0;

	/* Only interested in Device1 interface */
	if (strcmp(interface, "org.bluez.Device1") != 0)
		return 0;

	/* Enter the properties array */
	r = sd_bus_message_enter_container(m, 'a', "{sv}");
	if (r < 0)
		return 0;

	/* Look for Name property */
	while (sd_bus_message_enter_container(m, 'e', "sv") > 0) {
		const char *prop_name;
		r = sd_bus_message_read(m, "s", &prop_name);
		if (r < 0)
			break;

		if (strcmp(prop_name, "Name") == 0) {
			r = sd_bus_message_enter_container(m, 'v', "s");
			if (r >= 0) {
				const char *name;
				r = sd_bus_message_read(m, "s", &name);
				if (r >= 0 && bt_is_gamepad_name(name)) {
					wlr_log(WLR_INFO, "Discovered gamepad: %s at %s", name, path);
					bt_pair_device(path);
					bt_connect_device(path);
				}
				sd_bus_message_exit_container(m);
			}
		}
		sd_bus_message_exit_container(m);
	}
	sd_bus_message_exit_container(m);

	return 0;
}

/* Async callback for GetManagedObjects - checks and connects gamepads */
static int
bt_check_existing_cb(sd_bus_message *reply, void *userdata, sd_bus_error *error)
{
	int r;

	(void)userdata;

	if (sd_bus_error_is_set(error)) {
		wlr_log(WLR_DEBUG, "Failed to get BlueZ objects: %s", error->message);
		return 0;
	}

	/* Parse response: a{oa{sa{sv}}} */
	r = sd_bus_message_enter_container(reply, 'a', "{oa{sa{sv}}}");
	if (r < 0)
		return 0;

	while (sd_bus_message_enter_container(reply, 'e', "oa{sa{sv}}") > 0) {
		const char *obj_path;
		r = sd_bus_message_read(reply, "o", &obj_path);
		if (r < 0)
			break;

		/* Enter interfaces dict */
		r = sd_bus_message_enter_container(reply, 'a', "{sa{sv}}");
		if (r < 0)
			break;

		while (sd_bus_message_enter_container(reply, 'e', "sa{sv}") > 0) {
			const char *iface;
			r = sd_bus_message_read(reply, "s", &iface);
			if (r < 0)
				break;

			if (strcmp(iface, "org.bluez.Device1") == 0) {
				/* Enter properties dict */
				r = sd_bus_message_enter_container(reply, 'a', "{sv}");
				if (r < 0)
					break;

				const char *name = NULL;
				int connected = 0;
				int paired = 0;

				while (sd_bus_message_enter_container(reply, 'e', "sv") > 0) {
					const char *prop;
					r = sd_bus_message_read(reply, "s", &prop);
					if (r >= 0) {
						if (strcmp(prop, "Name") == 0) {
							sd_bus_message_enter_container(reply, 'v', "s");
							sd_bus_message_read(reply, "s", &name);
							sd_bus_message_exit_container(reply);
						} else if (strcmp(prop, "Connected") == 0) {
							sd_bus_message_enter_container(reply, 'v', "b");
							sd_bus_message_read(reply, "b", &connected);
							sd_bus_message_exit_container(reply);
						} else if (strcmp(prop, "Paired") == 0) {
							sd_bus_message_enter_container(reply, 'v', "b");
							sd_bus_message_read(reply, "b", &paired);
							sd_bus_message_exit_container(reply);
						} else {
							sd_bus_message_skip(reply, "v");
						}
					}
					sd_bus_message_exit_container(reply);
				}
				sd_bus_message_exit_container(reply);

				/* Auto-connect known gamepads that are paired but not connected */
				if (name && bt_is_gamepad_name(name)) {
					if (!paired) {
						wlr_log(WLR_INFO, "Found unpaired gamepad: %s", name);
						bt_pair_device(obj_path);
						bt_connect_device(obj_path);
					} else if (!connected) {
						wlr_log(WLR_INFO, "Reconnecting paired gamepad: %s", name);
						bt_connect_device(obj_path);
					}
				}
			} else {
				sd_bus_message_skip(reply, "a{sv}");
			}
			sd_bus_message_exit_container(reply);
		}
		sd_bus_message_exit_container(reply);
		sd_bus_message_exit_container(reply);
	}

	return 0;
}

/* Check existing devices and pair any gamepads (async) */
static void
bt_check_existing_devices(void)
{
	int r;

	if (!bt_bus)
		return;

	/* Async call to get managed objects */
	r = sd_bus_call_method_async(bt_bus, NULL,
		"org.bluez", "/",
		"org.freedesktop.DBus.ObjectManager", "GetManagedObjects",
		bt_check_existing_cb, NULL, "");

	if (r < 0) {
		wlr_log(WLR_DEBUG, "Failed to start async GetManagedObjects: %s", strerror(-r));
	}
}

/* Async callback for StartDiscovery */
static int
bt_start_discovery_cb(sd_bus_message *reply, void *userdata, sd_bus_error *error)
{
	(void)reply;
	(void)userdata;

	if (sd_bus_error_is_set(error)) {
		bt_scanning = 0;
		wlr_log(WLR_DEBUG, "StartDiscovery failed: %s", error->message);
		return 0;
	}

	wlr_log(WLR_INFO, "Started Bluetooth discovery for controllers");

	/* Schedule stop after scan duration */
	if (bt_scan_timer)
		wl_event_source_timer_update(bt_scan_timer, BT_SCAN_DURATION_MS);

	return 0;
}

/* Start Bluetooth discovery (async) */
static void
bt_start_discovery(void)
{
	int r;

	if (!bt_bus || bt_scanning)
		return;

	/* Set scanning flag early to prevent duplicate calls */
	bt_scanning = 1;

	/* Async call to start discovery */
	r = sd_bus_call_method_async(bt_bus, NULL,
		"org.bluez", "/org/bluez/hci0",
		"org.bluez.Adapter1", "StartDiscovery",
		bt_start_discovery_cb, NULL, "");

	if (r < 0) {
		bt_scanning = 0;
		wlr_log(WLR_DEBUG, "Failed to start async StartDiscovery: %s", strerror(-r));
	}
}

/* Async callback for StopDiscovery */
static int
bt_stop_discovery_cb(sd_bus_message *reply, void *userdata, sd_bus_error *error)
{
	(void)reply;
	(void)userdata;
	(void)error;

	wlr_log(WLR_DEBUG, "Stopped Bluetooth discovery");
	return 0;
}

/* Stop Bluetooth discovery (async) */
static void
bt_stop_discovery(void)
{
	int r;

	if (!bt_bus || !bt_scanning)
		return;

	bt_scanning = 0;

	/* Async call to stop discovery - fire and forget */
	r = sd_bus_call_method_async(bt_bus, NULL,
		"org.bluez", "/org/bluez/hci0",
		"org.bluez.Adapter1", "StopDiscovery",
		bt_stop_discovery_cb, NULL, "");

	if (r < 0) {
		wlr_log(WLR_DEBUG, "Failed to start async StopDiscovery: %s", strerror(-r));
	}
}

/* Timer callback for Bluetooth scanning */
static int
bt_scan_timer_cb(void *data)
{
	(void)data;

	if (bt_scanning) {
		/* Stop discovery and schedule next scan */
		bt_stop_discovery();
		if (bt_scan_timer)
			wl_event_source_timer_update(bt_scan_timer, BT_SCAN_INTERVAL_MS);
	} else {
		/* Check existing devices and start new discovery */
		bt_check_existing_devices();
		bt_start_discovery();
	}

	return 0;
}

/* Bluetooth bus event callback - processes D-Bus messages without blocking */
static int
bt_bus_event_cb(int fd, uint32_t mask, void *data)
{
	sd_bus *bus = data;
	int r;
	int events;
	uint32_t newmask;

	(void)fd;
	if (!bus)
		return 0;

	if (mask & (WL_EVENT_HANGUP | WL_EVENT_ERROR))
		return 0;

	/* Process all pending D-Bus messages (non-blocking) */
	while ((r = sd_bus_process(bus, NULL)) > 0)
		;

	/* Update event mask for next iteration */
	events = sd_bus_get_events(bus);
	newmask = 0;
	if (events & SD_BUS_EVENT_READABLE)
		newmask |= WL_EVENT_READABLE;
	if (events & SD_BUS_EVENT_WRITABLE)
		newmask |= WL_EVENT_WRITABLE;
	if (bt_bus_event)
		wl_event_source_fd_update(bt_bus_event, newmask ? newmask : WL_EVENT_READABLE);

	return 0;
}

/* Initialize Bluetooth controller auto-pairing */
static void
bt_controller_setup(void)
{
	int r;
	int fd, events;
	uint32_t mask;

	/* Check if Bluetooth is available */
	if (!bluetooth_available)
		return;

	/* Connect to system bus */
	r = sd_bus_open_system(&bt_bus);
	if (r < 0) {
		wlr_log(WLR_DEBUG, "Failed to connect to system bus for Bluetooth: %s", strerror(-r));
		return;
	}

	/* Set timeout - still useful for async calls that block internally */
	sd_bus_set_method_call_timeout(bt_bus, 500 * 1000); /* 500ms - reduced from 2s */

	/* Add bt_bus to event loop for async processing */
	fd = sd_bus_get_fd(bt_bus);
	events = sd_bus_get_events(bt_bus);
	mask = 0;
	if (events & SD_BUS_EVENT_READABLE)
		mask |= WL_EVENT_READABLE;
	if (events & SD_BUS_EVENT_WRITABLE)
		mask |= WL_EVENT_WRITABLE;
	if (mask == 0)
		mask = WL_EVENT_READABLE;

	bt_bus_event = wl_event_loop_add_fd(event_loop, fd, mask, bt_bus_event_cb, bt_bus);
	if (!bt_bus_event) {
		wlr_log(WLR_ERROR, "Failed to add Bluetooth bus to event loop");
		sd_bus_unref(bt_bus);
		bt_bus = NULL;
		return;
	}

	/* Add match for new device signals */
	r = sd_bus_match_signal(bt_bus, NULL, "org.bluez", NULL,
		"org.freedesktop.DBus.ObjectManager", "InterfacesAdded",
		bt_device_signal_cb, NULL);

	if (r < 0)
		wlr_log(WLR_DEBUG, "Failed to add BlueZ signal match: %s", strerror(-r));

	/* Create scan timer */
	bt_scan_timer = wl_event_loop_add_timer(event_loop, bt_scan_timer_cb, NULL);

	/* Start initial scan after a short delay */
	if (bt_scan_timer)
		wl_event_source_timer_update(bt_scan_timer, 5000);

	wlr_log(WLR_INFO, "Bluetooth controller auto-pairing initialized");
}

/* Cleanup Bluetooth controller auto-pairing */
static void
bt_controller_cleanup(void)
{
	if (bt_scanning)
		bt_stop_discovery();

	if (bt_scan_timer) {
		wl_event_source_remove(bt_scan_timer);
		bt_scan_timer = NULL;
	}

	if (bt_bus_event) {
		wl_event_source_remove(bt_bus_event);
		bt_bus_event = NULL;
	}

	if (bt_bus) {
		sd_bus_unref(bt_bus);
		bt_bus = NULL;
	}
}

/* Check if any monitor is active (enabled and not asleep) */
static int
gamepad_any_monitor_active(void)
{
	Monitor *m;

	wl_list_for_each(m, &mons, link) {
		if (m->wlr_output && m->wlr_output->enabled && !m->asleep)
			return 1;
	}
	return 0;
}

/* Turn off Xbox controller LED via sysfs */
static void
gamepad_turn_off_led_sysfs(GamepadDevice *gp)
{
	DIR *dir;
	struct dirent *entry;
	char event_name[32];
	char led_path[256];
	char sysfs_path[256];
	const char *event_part;
	int found = 0;

	if (!gp || !gp->path[0])
		return;

	/* Extract event number from path (e.g., /dev/input/event5 -> event5) */
	event_part = strrchr(gp->path, '/');
	if (!event_part)
		return;
	event_part++;  /* Skip the '/' */
	snprintf(event_name, sizeof(event_name), "%s", event_part);

	/* Method 1: Check /sys/class/input/eventX/device/device/leds/ (for xpadneo/xone) */
	snprintf(sysfs_path, sizeof(sysfs_path),
		"/sys/class/input/%s/device/device/leds", event_name);
	dir = opendir(sysfs_path);
	if (dir) {
		while ((entry = readdir(dir)) != NULL) {
			if (entry->d_name[0] == '.')
				continue;
			/* Try to write 0 to brightness */
			snprintf(led_path, sizeof(led_path), "%s/%s/brightness",
				sysfs_path, entry->d_name);
			int fd = open(led_path, O_WRONLY);
			if (fd >= 0) {
				write(fd, "0\n", 2);
				close(fd);
				wlr_log(WLR_INFO, "Turned off LED via %s", led_path);
				found = 1;
			}
		}
		closedir(dir);
	}

	/* Method 2: Check /sys/class/leds/ for xpad* entries */
	if (!found) {
		dir = opendir("/sys/class/leds");
		if (dir) {
			while ((entry = readdir(dir)) != NULL) {
				/* Look for xpad LEDs (Xbox 360) or gip* LEDs (xone) */
				if (strncmp(entry->d_name, "xpad", 4) == 0 ||
				    strncmp(entry->d_name, "gip", 3) == 0) {
					snprintf(led_path, sizeof(led_path),
						"/sys/class/leds/%s/brightness", entry->d_name);
					int fd = open(led_path, O_WRONLY);
					if (fd >= 0) {
						/* Pattern 0 = all LEDs off for xpad */
						write(fd, "0\n", 2);
						close(fd);
						wlr_log(WLR_INFO, "Turned off LED via %s", led_path);
						found = 1;
					}
				}
			}
			closedir(dir);
		}
	}

	if (!found) {
		wlr_log(WLR_DEBUG, "No sysfs LED found for gamepad %s", gp->name);
	}
}

/* Async callback for Bluetooth Disconnect method */
static int
bt_disconnect_reply_cb(sd_bus_message *reply, void *userdata, sd_bus_error *error)
{
	char *name = userdata;

	if (sd_bus_error_is_set(error)) {
		wlr_log(WLR_DEBUG, "Async disconnect failed for %s: %s", name ? name : "unknown", error->message);
	} else {
		wlr_log(WLR_INFO, "Controller disconnected: %s", name ? name : "unknown");
	}

	free(name);
	return 0;
}

/* Async callback for GetManagedObjects - finds and disconnects the device */
static int
bt_get_objects_disconnect_cb(sd_bus_message *reply, void *userdata, sd_bus_error *error)
{
	char *target_name = userdata;
	const char *obj_path;
	int r;

	if (!target_name)
		return 0;

	if (sd_bus_error_is_set(error)) {
		wlr_log(WLR_DEBUG, "Failed to get Bluetooth objects: %s", error->message);
		free(target_name);
		return 0;
	}

	/* Iterate through objects to find our device */
	r = sd_bus_message_enter_container(reply, 'a', "{oa{sa{sv}}}");
	if (r < 0)
		goto done;

	while ((r = sd_bus_message_enter_container(reply, 'e', "oa{sa{sv}}")) > 0) {
		r = sd_bus_message_read(reply, "o", &obj_path);
		if (r < 0)
			break;

		/* Enter interfaces dict */
		r = sd_bus_message_enter_container(reply, 'a', "{sa{sv}}");
		if (r < 0)
			break;

		while ((r = sd_bus_message_enter_container(reply, 'e', "sa{sv}")) > 0) {
			const char *interface;
			r = sd_bus_message_read(reply, "s", &interface);
			if (r < 0)
				break;

			if (strcmp(interface, "org.bluez.Device1") == 0) {
				/* Enter properties dict */
				r = sd_bus_message_enter_container(reply, 'a', "{sv}");
				if (r < 0)
					break;

				const char *device_name = NULL;
				int connected = 0;

				while ((r = sd_bus_message_enter_container(reply, 'e', "sv")) > 0) {
					const char *prop;
					r = sd_bus_message_read(reply, "s", &prop);
					if (r < 0)
						break;

					if (strcmp(prop, "Name") == 0) {
						r = sd_bus_message_enter_container(reply, 'v', "s");
						if (r >= 0) {
							sd_bus_message_read(reply, "s", &device_name);
							sd_bus_message_exit_container(reply);
						}
					} else if (strcmp(prop, "Connected") == 0) {
						r = sd_bus_message_enter_container(reply, 'v', "b");
						if (r >= 0) {
							sd_bus_message_read(reply, "b", &connected);
							sd_bus_message_exit_container(reply);
						}
					} else {
						sd_bus_message_skip(reply, "v");
					}
					sd_bus_message_exit_container(reply);
				}
				sd_bus_message_exit_container(reply);

				/* Check if this is our device (match in either direction) */
				if (device_name && connected &&
				    (strcasestr(target_name, device_name) ||
				     strcasestr(device_name, target_name))) {
					wlr_log(WLR_INFO, "Disconnecting Bluetooth controller: %s", device_name);

					/* Async disconnect - fire and forget */
					char *name_copy = strdup(device_name);
					r = sd_bus_call_method_async(bt_bus, NULL,
						"org.bluez",
						obj_path,
						"org.bluez.Device1",
						"Disconnect",
						bt_disconnect_reply_cb,
						name_copy,
						"");

					if (r < 0) {
						wlr_log(WLR_DEBUG, "Failed to start async disconnect: %s", strerror(-r));
						free(name_copy);
					}
					goto done;
				}
			} else {
				sd_bus_message_skip(reply, "a{sv}");
			}
			sd_bus_message_exit_container(reply);
		}
		sd_bus_message_exit_container(reply);
		sd_bus_message_exit_container(reply);
	}

done:
	free(target_name);
	return 0;
}

/* Disconnect Bluetooth device by name - completely powers off the controller (async) */
static void
gamepad_bt_disconnect(GamepadDevice *gp)
{
	int r;
	char *name_copy;

	if (!bt_bus || !gp)
		return;

	/* Copy name since gp may be freed before async callback */
	name_copy = strdup(gp->name);
	if (!name_copy)
		return;

	/* Async call to get managed objects */
	r = sd_bus_call_method_async(bt_bus, NULL,
		"org.bluez",
		"/",
		"org.freedesktop.DBus.ObjectManager",
		"GetManagedObjects",
		bt_get_objects_disconnect_cb,
		name_copy,
		"");

	if (r < 0) {
		wlr_log(WLR_DEBUG, "Failed to start async GetManagedObjects: %s", strerror(-r));
		free(name_copy);
	}
}

/* Suspend gamepad - power it off completely */
static void
gamepad_suspend(GamepadDevice *gp)
{
	char name_copy[128];

	if (!gp || gp->suspended)
		return;

	/* Mark as suspended FIRST before any operations that might trigger removal */
	gp->suspended = 1;

	/* Copy name before potential free */
	snprintf(name_copy, sizeof(name_copy), "%s", gp->name);

	/* Turn off LED via sysfs (Xbox controllers) */
	gamepad_turn_off_led_sysfs(gp);

	/* Disconnect Bluetooth controller - this will power it off completely.
	 * WARNING: This may trigger inotify which calls gamepad_device_remove()
	 * and frees gp. Do NOT access gp after this call! */
	gamepad_bt_disconnect(gp);

	/* gp may be freed at this point - use copied name */
	wlr_log(WLR_INFO, "Gamepad powered off due to inactivity: %s", name_copy);
}

/* Resume gamepad - wake it up */
static void
gamepad_resume(GamepadDevice *gp)
{
	if (!gp || !gp->suspended)
		return;

	gp->suspended = 0;
	gp->last_activity_ms = monotonic_msec();
	wlr_log(WLR_INFO, "Gamepad resumed: %s", gp->name);

	/* Switch TV to active source when gamepad wakes */
	cec_switch_to_active_source();
}

/* Gamepad inactivity timer callback */
static int
gamepad_inactivity_timer_cb(void *data)
{
	GamepadDevice *gp, *tmp;
	int64_t now = monotonic_msec();
	int any_active = 0;
	int monitors_active = gamepad_any_monitor_active();

	(void)data;

	/* Use _safe iteration because gamepad_suspend may trigger device removal */
	wl_list_for_each_safe(gp, tmp, &gamepads, link) {
		if (gp->suspended)
			continue;

		any_active = 1;

		/* Suspend if monitors are off or inactive for too long */
		if (!monitors_active ||
		    (now - gp->last_activity_ms) >= GAMEPAD_INACTIVITY_TIMEOUT_MS) {
			gamepad_suspend(gp);
		}
	}

	/* Reschedule timer if there are active gamepads */
	if (any_active && gamepad_inactivity_timer) {
		wl_event_source_timer_update(gamepad_inactivity_timer, GAMEPAD_INACTIVITY_CHECK_MS);
	}

	return 0;
}

static void
gamepad_setup(void)
{
	wl_list_init(&gamepads);

	/* Set up inotify to watch /dev/input for new devices */
	gamepad_inotify_fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC);
	if (gamepad_inotify_fd < 0) {
		wlr_log(WLR_ERROR, "Failed to create gamepad inotify: %s", strerror(errno));
		return;
	}

	gamepad_inotify_wd = inotify_add_watch(gamepad_inotify_fd, "/dev/input",
		IN_CREATE | IN_DELETE);
	if (gamepad_inotify_wd < 0) {
		wlr_log(WLR_ERROR, "Failed to watch /dev/input: %s", strerror(errno));
		close(gamepad_inotify_fd);
		gamepad_inotify_fd = -1;
		return;
	}

	gamepad_inotify_event = wl_event_loop_add_fd(event_loop, gamepad_inotify_fd,
		WL_EVENT_READABLE, gamepad_inotify_cb, NULL);

	/* Create cursor movement timer */
	gamepad_cursor_timer = wl_event_loop_add_timer(event_loop, gamepad_cursor_timer_cb, NULL);

	/* Create pending device timer for delayed add */
	gamepad_pending_timer = wl_event_loop_add_timer(event_loop, gamepad_pending_timer_cb, NULL);

	/* Create inactivity timer for auto-suspend */
	gamepad_inactivity_timer = wl_event_loop_add_timer(event_loop, gamepad_inactivity_timer_cb, NULL);

	/* Scan existing devices */
	gamepad_scan_devices();

	/* Start timers if we found any gamepads */
	if (!wl_list_empty(&gamepads)) {
		if (gamepad_cursor_timer)
			wl_event_source_timer_update(gamepad_cursor_timer, GAMEPAD_CURSOR_INTERVAL_MS);
		if (gamepad_inactivity_timer)
			wl_event_source_timer_update(gamepad_inactivity_timer, GAMEPAD_INACTIVITY_CHECK_MS);
	}

	wlr_log(WLR_INFO, "Gamepad support initialized");
}

static void
gamepad_cleanup(void)
{
	GamepadDevice *gp, *tmp;

	/* Remove all gamepads */
	wl_list_for_each_safe(gp, tmp, &gamepads, link) {
		if (gp->event_source)
			wl_event_source_remove(gp->event_source);
		if (gp->fd >= 0)
			close(gp->fd);
		wl_list_remove(&gp->link);
		free(gp);
	}

	/* Clean up cursor timer */
	if (gamepad_cursor_timer) {
		wl_event_source_remove(gamepad_cursor_timer);
		gamepad_cursor_timer = NULL;
	}

	/* Clean up pending device timer */
	if (gamepad_pending_timer) {
		wl_event_source_remove(gamepad_pending_timer);
		gamepad_pending_timer = NULL;
	}
	gamepad_pending_count = 0;

	/* Clean up inactivity timer */
	if (gamepad_inactivity_timer) {
		wl_event_source_remove(gamepad_inactivity_timer);
		gamepad_inactivity_timer = NULL;
	}

	/* Clean up inotify */
	if (gamepad_inotify_event) {
		wl_event_source_remove(gamepad_inotify_event);
		gamepad_inotify_event = NULL;
	}
	if (gamepad_inotify_fd >= 0) {
		if (gamepad_inotify_wd >= 0)
			inotify_rm_watch(gamepad_inotify_fd, gamepad_inotify_wd);
		close(gamepad_inotify_fd);
		gamepad_inotify_fd = -1;
		gamepad_inotify_wd = -1;
	}
}

static void
schedule_next_status_refresh(void)
{
	uint64_t now = monotonic_msec();
	uint64_t next = UINT64_MAX;

	if (!status_cpu_timer || game_mode_active || htpc_mode_active)
		return;

	for (size_t i = 0; i < LENGTH(status_tasks); i++) {
		if (status_tasks[i].next_due_ms < next)
			next = status_tasks[i].next_due_ms;
	}

	if (next == UINT64_MAX)
		return;

	if (next <= now)
		wl_event_source_timer_update(status_cpu_timer, 1);
	else
		wl_event_source_timer_update(status_cpu_timer, (int)(next - now));
}

static void
schedule_status_timer(void)
{
	struct timespec ts;
	double now, next;
	int ms;

	if (!status_timer || game_mode_active || htpc_mode_active)
		return;

	clock_gettime(CLOCK_REALTIME, &ts);
	now = ts.tv_sec + ts.tv_nsec / 1e9;
	next = ceil(now / 60.0) * 60.0;
	ms = (int)((next - now) * 1000.0);
	if (ms < 1)
		ms = 1;

	wl_event_source_timer_update(status_timer, ms);
}

static int
updatestatuscpu(void *data)
{
	size_t chosen = 0;
	uint64_t best = 0;
	uint64_t now = monotonic_msec();
	int found = 0;
	uint64_t since_motion = last_pointer_motion_ms ? now - last_pointer_motion_ms : UINT64_MAX;

	(void)data;

	if (since_motion < 8) {
		wl_event_source_timer_update(status_cpu_timer, 8 - (int)since_motion);
		return 0;
	}

	for (size_t i = 0; i < LENGTH(status_tasks); i++) {
		if (!found || status_tasks[i].next_due_ms < best) {
			best = status_tasks[i].next_due_ms;
			chosen = i;
			found = 1;
		}
	}

	if (!found) {
		schedule_next_status_refresh();
		return 0;
	}

	if (best > now) {
		schedule_next_status_refresh();
		return 0;
	}

	status_tasks[chosen].fn();
	if (status_tasks[chosen].fn == refreshstatusnet) {
		uint64_t delay_ms = 60000;
		uint64_t allow_fast_after = now;
		int popup_active = 0;
		Monitor *m;

		wl_list_for_each(m, &mons, link) {
			if (m->showbar && m->statusbar.net_popup.visible) {
				popup_active = 1;
				if (m->statusbar.net_popup.suppress_refresh_until_ms > allow_fast_after)
					allow_fast_after = m->statusbar.net_popup.suppress_refresh_until_ms;
			}
		}

		if (popup_active) {
			if (allow_fast_after > now)
				delay_ms = allow_fast_after - now;
			else
				delay_ms = 1000;
		}
		status_tasks[chosen].next_due_ms = now + delay_ms;
	} else if (status_task_hover_active(status_tasks[chosen].fn)) {
		status_tasks[chosen].next_due_ms = now + STATUS_FAST_MS;
	} else {
		status_tasks[chosen].next_due_ms = now + random_status_delay_ms();
	}
	schedule_next_status_refresh();
	return 0;
}

static int
updatehoverfade(void *data)
{
	int need_more = 0;
	Monitor *mon;
	float step;

	(void)data;

	if (statusbar_hover_fade_ms <= 0)
		return 0;

	step = 16.0f / (float)statusbar_hover_fade_ms;

	wl_list_for_each(mon, &mons, link) {
		Monitor *m = mon;
		int barh;
		if (!m->showbar || !m->statusbar.tags.tree)
			continue;
		if (m->statusbar.tags.hover_tag < 0 && m->statusbar.tags.tagmask == 0)
			continue;

		for (int i = 0; i < TAGCOUNT; i++) {
			float target = (m->statusbar.tags.hover_tag == i) ? 1.0f : 0.0f;
			float alpha = m->statusbar.tags.hover_alpha[i];
			if (target > alpha) {
				alpha += step;
				if (alpha > target)
					alpha = target;
			} else if (target < alpha) {
				alpha -= step;
				if (alpha < target)
					alpha = target;
			}
			if (alpha != m->statusbar.tags.hover_alpha[i])
				need_more = 1;
			m->statusbar.tags.hover_alpha[i] = alpha;
		}

		barh = m->statusbar.area.height ? m->statusbar.area.height : (int)statusbar_height;
		renderworkspaces(m, &m->statusbar.tags, barh);
		positionstatusmodules(m);
	}

	if (need_more && status_hover_timer)
		wl_event_source_timer_update(status_hover_timer, 16);

	return 0;
}

static void
updatecpuhover(Monitor *m, double cx, double cy)
{
	int lx, ly;
	int inside = 0;
	int popup_hover = 0;
	int was_visible;
	CpuPopup *p;
	int popup_x;
	int new_hover = -1;
	uint64_t now = monotonic_msec();
	int need_refresh = 0;
	int stale_refresh = 0;

	if (!m || !m->showbar || !m->statusbar.cpu.tree || !m->statusbar.cpu_popup.tree) {
		if (m && m->statusbar.cpu_popup.tree) {
			wlr_scene_node_set_enabled(&m->statusbar.cpu_popup.tree->node, 0);
			m->statusbar.cpu_popup.visible = 0;
			m->statusbar.cpu_popup.hover_idx = -1;
		}
		return;
	}

	p = &m->statusbar.cpu_popup;
	lx = (int)floor(cx) - m->statusbar.area.x;
	ly = (int)floor(cy) - m->statusbar.area.y;

	popup_x = m->statusbar.cpu.x;
	if (p->width > 0 && m->statusbar.area.width > 0) {
		int max_x = m->statusbar.area.width - p->width;
		if (max_x < 0)
			max_x = 0;
		if (popup_x > max_x)
			popup_x = max_x;
		if (popup_x < 0)
			popup_x = 0;
	}

	if (p->visible && p->width > 0 && p->height > 0 &&
			lx >= popup_x &&
			lx < popup_x + p->width &&
			ly >= m->statusbar.area.height &&
			ly < m->statusbar.area.height + p->height) {
		popup_hover = 1;
	}

	if (lx >= m->statusbar.cpu.x &&
			lx < m->statusbar.cpu.x + m->statusbar.cpu.width &&
			ly >= 0 && ly < m->statusbar.area.height &&
			m->statusbar.cpu.width > 0) {
		inside = 1;
	} else if (popup_hover) {
		inside = 1;
	}

	was_visible = p->visible;

	if (inside) {
		/* Track when hover started for delay */
		if (p->hover_start_ms == 0)
			p->hover_start_ms = now;

		/* Wait 300ms before showing popup */
		if (!was_visible && (now - p->hover_start_ms) < 300) {
			/* Schedule timer to check again after remaining delay */
			uint64_t remaining = 300 - (now - p->hover_start_ms);
			schedule_popup_delay(remaining + 1);
			return;
		}

		if (!was_visible) {
			/* Delay heavy popup refresh until pointer lingers for 1s */
			p->suppress_refresh_until_ms = now + 1000;
		}
		p->visible = 1;
		wlr_scene_node_set_enabled(&p->tree->node, 1);
		wlr_scene_node_set_position(&p->tree->node,
				popup_x, m->statusbar.area.height);
		new_hover = cpu_popup_hover_index(m, p);
		stale_refresh = (p->last_fetch_ms == 0 ||
				now < p->last_fetch_ms ||
				(now - p->last_fetch_ms) >= cpu_popup_refresh_interval_ms);
		need_refresh = (!was_visible || stale_refresh) &&
				(p->suppress_refresh_until_ms == 0 ||
				 now >= p->suppress_refresh_until_ms);
		if (need_refresh)
			p->refresh_data = 1;
		if (new_hover != p->hover_idx || !was_visible || need_refresh) {
			int allow_render = 1;
			if (!need_refresh && was_visible && new_hover != p->hover_idx &&
					p->last_render_ms > 0 && now >= p->last_render_ms &&
					now - p->last_render_ms < 16)
				allow_render = 0;
			if (allow_render) {
				p->hover_idx = new_hover;
				rendercpupopup(m);
			}
		}
		if (!was_visible)
			schedule_cpu_popup_refresh(1000);
	} else if (p->visible || p->hover_start_ms != 0) {
		p->visible = 0;
		wlr_scene_node_set_enabled(&p->tree->node, 0);
		p->hover_idx = -1;
		p->refresh_data = 0;
		p->last_render_ms = 0;
		p->suppress_refresh_until_ms = 0;
		p->hover_start_ms = 0;
	}
}

static void
updateramhover(Monitor *m, double cx, double cy)
{
	int lx, ly;
	int inside = 0;
	int popup_hover = 0;
	int was_visible;
	RamPopup *p;
	int popup_x;
	int new_hover = -1;
	uint64_t now = monotonic_msec();
	int need_refresh = 0;
	int stale_refresh = 0;

	if (!m || !m->showbar || !m->statusbar.ram.tree || !m->statusbar.ram_popup.tree) {
		if (m && m->statusbar.ram_popup.tree) {
			wlr_scene_node_set_enabled(&m->statusbar.ram_popup.tree->node, 0);
			m->statusbar.ram_popup.visible = 0;
			m->statusbar.ram_popup.hover_idx = -1;
		}
		return;
	}

	p = &m->statusbar.ram_popup;
	lx = (int)floor(cx) - m->statusbar.area.x;
	ly = (int)floor(cy) - m->statusbar.area.y;

	popup_x = m->statusbar.ram.x;
	if (p->width > 0 && m->statusbar.area.width > 0) {
		int max_x = m->statusbar.area.width - p->width;
		if (max_x < 0)
			max_x = 0;
		if (popup_x > max_x)
			popup_x = max_x;
		if (popup_x < 0)
			popup_x = 0;
	}

	if (p->visible && p->width > 0 && p->height > 0 &&
			lx >= popup_x &&
			lx < popup_x + p->width &&
			ly >= m->statusbar.area.height &&
			ly < m->statusbar.area.height + p->height) {
		popup_hover = 1;
	}

	if (lx >= m->statusbar.ram.x &&
			lx < m->statusbar.ram.x + m->statusbar.ram.width &&
			ly >= 0 && ly < m->statusbar.area.height &&
			m->statusbar.ram.width > 0) {
		inside = 1;
	} else if (popup_hover) {
		inside = 1;
	}

	was_visible = p->visible;

	if (inside) {
		/* Track when hover started for delay */
		if (p->hover_start_ms == 0)
			p->hover_start_ms = now;

		/* Wait 300ms before showing popup */
		if (!was_visible && (now - p->hover_start_ms) < 300) {
			/* Schedule timer to check again after remaining delay */
			uint64_t remaining = 300 - (now - p->hover_start_ms);
			schedule_popup_delay(remaining + 1);
			return;
		}

		if (!was_visible) {
			/* Short delay to avoid flicker on quick mouse movements */
			p->suppress_refresh_until_ms = now + 100;
			p->refresh_data = 1; /* Trigger immediate fetch when delay passes */
		}
		p->visible = 1;
		wlr_scene_node_set_enabled(&p->tree->node, 1);
		wlr_scene_node_set_position(&p->tree->node,
				popup_x, m->statusbar.area.height);
		new_hover = ram_popup_hover_index(m, p);
		stale_refresh = (p->last_fetch_ms == 0 ||
				now < p->last_fetch_ms ||
				(now - p->last_fetch_ms) >= ram_popup_refresh_interval_ms);
		need_refresh = (!was_visible || stale_refresh) &&
				(p->suppress_refresh_until_ms == 0 ||
				 now >= p->suppress_refresh_until_ms);
		if (need_refresh)
			p->refresh_data = 1;
		if (new_hover != p->hover_idx || !was_visible || need_refresh) {
			int allow_render = 1;
			if (!need_refresh && was_visible && new_hover != p->hover_idx &&
					p->last_render_ms > 0 && now >= p->last_render_ms &&
					now - p->last_render_ms < 16)
				allow_render = 0;
			if (allow_render) {
				p->hover_idx = new_hover;
				renderrampopup(m);
			}
		}
		if (!was_visible)
			schedule_ram_popup_refresh(100);
	} else if (p->visible || p->hover_start_ms != 0) {
		p->visible = 0;
		wlr_scene_node_set_enabled(&p->tree->node, 0);
		p->hover_idx = -1;
		p->refresh_data = 0;
		p->last_render_ms = 0;
		p->suppress_refresh_until_ms = 0;
		p->hover_start_ms = 0;
	}
}

static void
updatenethover(Monitor *m, double cx, double cy)
{
	int lx, ly;
	int inside = 0;
	int was_visible;
	StatusModule *icon_mod;
	NetPopup *p;
	uint64_t now = monotonic_msec();

	if (!m || !m->showbar || !m->statusbar.net_popup.tree
			|| (m->statusbar.net_menu.visible)) {
		if (m && m->statusbar.net_popup.tree) {
			wlr_scene_node_set_enabled(&m->statusbar.net_popup.tree->node, 0);
			m->statusbar.net_popup.visible = 0;
		}
		return;
	}

	p = &m->statusbar.net_popup;
	icon_mod = &m->statusbar.sysicons;
	lx = (int)floor(cx) - m->statusbar.area.x;
	ly = (int)floor(cy) - m->statusbar.area.y;

	if (icon_mod->width > 0 &&
		lx >= icon_mod->x &&
		lx < icon_mod->x + icon_mod->width &&
		ly >= 0 && ly < m->statusbar.area.height) {
		inside = 1;
	}
	/* Allow anchor data when icon is temporarily zero-sized */
	if (!inside && p->anchor_w > 0) {
		int lx_abs = (int)floor(cx);
		int ly_abs = (int)floor(cy);
		int ax0 = m->statusbar.area.x + p->anchor_x;
		int ay0 = m->statusbar.area.y;
		if (lx_abs >= ax0 && lx_abs < ax0 + p->anchor_w &&
				ly_abs >= ay0 && ly_abs < ay0 + m->statusbar.area.height)
			inside = 1;
	}

	/* Keep visible while hovering popup itself */
	if (!inside && p->visible && p->width > 0 && p->height > 0) {
		int px0 = m->statusbar.area.x + (icon_mod->width > 0 ? icon_mod->x : p->anchor_x);
		int py0 = m->statusbar.area.y + m->statusbar.area.height;
		int px1 = px0 + p->width;
		int py1 = py0 + p->height;
		int cx_i = (int)floor(cx);
		int cy_i = (int)floor(cy);
		if (cx_i >= px0 && cx_i < px1 && cy_i >= py0 && cy_i < py1)
			inside = 1;
	}

	was_visible = p->visible;

	if (inside) {
		/* Track when hover started for delay */
		if (p->hover_start_ms == 0)
			p->hover_start_ms = now;

		/* Wait 300ms before showing popup */
		if (!was_visible && (now - p->hover_start_ms) < 300) {
			/* Schedule timer to check again after remaining delay */
			uint64_t remaining = 300 - (now - p->hover_start_ms);
			schedule_popup_delay(remaining + 1);
			return;
		}

		if (!was_visible) {
			p->suppress_refresh_until_ms = now + 2000;
			set_status_task_due(refreshstatusnet, p->suppress_refresh_until_ms);
		}
		p->visible = 1;
		wlr_scene_node_set_enabled(&p->tree->node, 1);
		wlr_scene_node_set_position(&p->tree->node,
				icon_mod->width > 0 ? icon_mod->x : p->anchor_x,
				m->statusbar.area.height);
		if (!was_visible) {
			p->anchor_x = icon_mod->width > 0 ? icon_mod->x : p->anchor_x;
			p->anchor_y = m->statusbar.area.height;
			p->anchor_w = icon_mod->width > 0 ? icon_mod->width : p->anchor_w;
			rendernetpopup(m);
		}
	} else if (p->visible || p->hover_start_ms != 0) {
		p->visible = 0;
		wlr_scene_node_set_enabled(&p->tree->node, 0);
		p->suppress_refresh_until_ms = 0;
		p->hover_start_ms = 0;
		set_status_task_due(refreshstatusnet, now + 60000);
	}
}

static int
updatestatusclock(void *data)
{
	(void)data;
	refreshstatusclock();
	schedule_status_timer();
	return 0;
}

/* Check if a view is active (visible and on current tag) */
static int
htpc_view_is_active(Monitor *m, unsigned int view_tag, int visible)
{
	if (!m || !htpc_mode_active || !visible || !view_tag)
		return 0;
	return (view_tag & m->tagset[m->seltags]) != 0;
}

/* Update HTPC view visibility based on current tag */
static void
htpc_views_update_visibility(Monitor *m)
{
	unsigned int tagset;

	if (!m || !htpc_mode_active)
		return;

	tagset = m->tagset[m->seltags];

	/* PC Gaming view - visible on tag 4 (bit 3) */
	if (m->pc_gaming.tree) {
		int vis = m->pc_gaming.visible && (m->pc_gaming.view_tag & tagset);
		wlr_scene_node_set_enabled(&m->pc_gaming.tree->node, vis);
	}

	/* Retro Gaming view - visible on tag 3 (bit 2) */
	if (m->retro_gaming.tree) {
		int vis = m->retro_gaming.visible && (m->retro_gaming.view_tag & tagset);
		wlr_scene_node_set_enabled(&m->retro_gaming.tree->node, vis);
		if (m->retro_gaming.dim)
			wlr_scene_node_set_enabled(&m->retro_gaming.dim->node, vis);
	}

	/* Movies view - visible on tag 2 (bit 1) */
	if (m->movies_view.tree) {
		int vis = m->movies_view.visible && (m->movies_view.view_tag & tagset);
		wlr_scene_node_set_enabled(&m->movies_view.tree->node, vis);
	}

	/* TV-shows view - visible on tag 1 (bit 0) */
	if (m->tvshows_view.tree) {
		int vis = m->tvshows_view.visible && (m->tvshows_view.view_tag & tagset);
		wlr_scene_node_set_enabled(&m->tvshows_view.tree->node, vis);
	}
}

void
arrange(Monitor *m)
{
	Client *c;

	if (!m->wlr_output->enabled)
		return;

	/* Update HTPC view visibility when tags change */
	htpc_views_update_visibility(m);

	wl_list_for_each(c, &clients, link) {
		if (c->mon == m) {
			wlr_scene_node_set_enabled(&c->scene->node, VISIBLEON(c, m));
			client_set_suspended(c, !VISIBLEON(c, m));
		}
	}

	/*
	 * fullscreen_bg is used to hide content behind fullscreen windows that
	 * don't fill the entire screen. However, for direct scanout to work
	 * (bypassing composition entirely), the fullscreen window must be the
	 * ONLY visible element. So we only show fullscreen_bg when the fullscreen
	 * window doesn't cover the full monitor area.
	 *
	 * This allows games and videos to achieve direct scanout for best
	 * frame pacing and lowest latency when they fill the screen.
	 */
	/* Find fullscreen client on this monitor's current tag */
	c = NULL;
	wl_list_for_each(c, &clients, link) {
		if (c->isfullscreen && VISIBLEON(c, m))
			break;
	}
	if (&c->link == &clients)
		c = NULL;

	if (c && c->isfullscreen) {
		/* Check if window covers the full monitor */
		int covers_full_screen =
			c->geom.x <= m->m.x &&
			c->geom.y <= m->m.y &&
			c->geom.x + c->geom.width >= m->m.x + m->m.width &&
			c->geom.y + c->geom.height >= m->m.y + m->m.height;

		/* Only show bg if fullscreen window doesn't cover everything */
		wlr_scene_node_set_enabled(&m->fullscreen_bg->node, !covers_full_screen);

		/*
		 * Hide ALL background elements when fullscreen covers the whole screen.
		 * This is CRITICAL for direct scanout - wlroots can only do direct
		 * scanout when there's exactly one visible surface covering the output.
		 * Any other visible scene nodes (root_bg, swaybg, etc.) prevent this.
		 */
		wlr_scene_node_set_enabled(&layers[LyrBg]->node, !covers_full_screen);
		wlr_scene_node_set_enabled(&root_bg->node, !covers_full_screen);

		/*
		 * AUTOMATIC FOCUS FOR FULLSCREEN CLIENTS
		 * If there's a visible fullscreen client on the current tag, it MUST
		 * have keyboard focus. This handles Steam games and other apps that
		 * go fullscreen but don't receive focus automatically.
		 */
		if (m == selmon && seat->keyboard_state.focused_surface != client_surface(c)) {
			exclusive_focus = NULL;
			focusclient(c, 0);  /* Don't lift/warp, just give focus */
		}
	} else {
		wlr_scene_node_set_enabled(&m->fullscreen_bg->node, 0);
		wlr_scene_node_set_enabled(&layers[LyrBg]->node, 1);
		wlr_scene_node_set_enabled(&root_bg->node, 1);
	}

	strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, LENGTH(m->ltsymbol));

	/* We move all clients (except fullscreen and unmanaged) to LyrTile while
	 * in floating layout to avoid "real" floating clients be always on top */
	wl_list_for_each(c, &clients, link) {
		if (c->mon != m || c->scene->node.parent == layers[LyrFS])
			continue;

		wlr_scene_node_reparent(&c->scene->node,
				(!m->lt[m->sellt]->arrange && c->isfloating)
						? layers[LyrTile]
						: (m->lt[m->sellt]->arrange && c->isfloating)
								? layers[LyrFloat]
								: c->scene->node.parent);
	}

	if (m->lt[m->sellt]->arrange)
		m->lt[m->sellt]->arrange(m);
	motionnotify(0, NULL, 0, 0, 0, 0);
	checkidleinhibitor(NULL);
	refreshstatustags();
	warpcursor(focustop(selmon));
}

void
arrangelayer(Monitor *m, struct wl_list *list, struct wlr_box *usable_area, int exclusive)
{
	LayerSurface *l;
	struct wlr_box full_area = m->m;

	wl_list_for_each(l, list, link) {
		struct wlr_layer_surface_v1 *layer_surface = l->layer_surface;

		if (!layer_surface->initialized)
			continue;

		if (exclusive != (layer_surface->current.exclusive_zone > 0))
			continue;

		wlr_scene_layer_surface_v1_configure(l->scene_layer, &full_area, usable_area);
		wlr_scene_node_set_position(&l->popups->node, l->scene->node.x, l->scene->node.y);
	}
}

void
arrangelayers(Monitor *m)
{
	int i;
	struct wlr_box usable_area = m->m;
	struct wlr_box client_area;
	struct wlr_box old_w = m->w;
	LayerSurface *l;
	uint32_t layers_above_shell[] = {
		ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY,
		ZWLR_LAYER_SHELL_V1_LAYER_TOP,
	};
	if (!m->wlr_output->enabled)
		return;

	/* Arrange exclusive surfaces from top->bottom */
	for (i = 3; i >= 0; i--)
		arrangelayer(m, &m->layers[i], &usable_area, 1);

	client_area = usable_area;
	layoutstatusbar(m, &usable_area, &client_area);

	if (!wlr_box_equal(&client_area, &old_w)) {
		m->w = client_area;
		arrange(m);
	} else {
		positionstatusmodules(m);
	}

	/* Arrange non-exlusive surfaces from top->bottom */
	for (i = 3; i >= 0; i--)
		arrangelayer(m, &m->layers[i], &usable_area, 0);

	refreshstatusclock();

	/* Find topmost keyboard interactive layer, if such a layer exists */
	for (i = 0; i < (int)LENGTH(layers_above_shell); i++) {
		wl_list_for_each_reverse(l, &m->layers[layers_above_shell[i]], link) {
			if (locked || !l->layer_surface->current.keyboard_interactive || !l->mapped)
				continue;
			/* Deactivate the focused client. */
			focusclient(NULL, 0);
			exclusive_focus = l;
			client_notify_enter(l->layer_surface->surface, wlr_seat_get_keyboard(seat));
			return;
		}
	}
}

static int
scrollsteps(const struct wlr_pointer_axis_event *event)
{
	int steps;

	if (!event)
		return 0;

	if (event->delta_discrete > 0)
		steps = 1;
	else if (event->delta_discrete < 0)
		steps = -1;
	else if (event->delta > 0.0)
		steps = 1;
	else if (event->delta < 0.0)
		steps = -1;
	else
		steps = 0;

	if (event->relative_direction == WL_POINTER_AXIS_RELATIVE_DIRECTION_INVERTED)
		steps = -steps;

	return steps;
}

static int
adjust_backlight_by_steps(int steps)
{
	double percent;
	double delta;

	if (steps == 0)
		return 0;

	backlight_available = findbacklightdevice(backlight_brightness_path,
			sizeof(backlight_brightness_path),
			backlight_max_path, sizeof(backlight_max_path));

	percent = backlight_percent();
	if (percent < 0.0)
		percent = light_last_percent;
	if (percent < 0.0)
		percent = light_cached_percent >= 0.0 ? light_cached_percent : 50.0; /* fallback default */

	delta = (double)steps * light_step;

	/* First try relative adjustment via helper and return on success */
	if (set_backlight_relative(delta) == 0) {
		double newp = backlight_percent();
		if (newp >= 0.0)
			percent = newp;
		else
			percent = percent + delta;
		if (percent < 0.0)
			percent = 0.0;
		if (percent > 100.0)
			percent = 100.0;
		light_last_percent = percent;
		light_cached_percent = percent;
		refreshstatuslight();
		return 1;
	}

	/* Fall back to absolute write */
	{
		double target = percent + delta;
		if (target < 0.0)
			target = 0.0;
		if (target > 100.0)
			target = 100.0;

		if (set_backlight_percent(target) != 0) {
			light_last_percent = target;
			light_cached_percent = target;
			refreshstatuslight();
			return 1;
		}
		light_last_percent = target;
		light_cached_percent = target;
	}

	refreshstatuslight();
	return 1;
}

static int
adjust_volume_by_steps(int steps)
{
	double vol;
	int is_headset;
	uint64_t now;

	if (steps == 0)
		return 0;

	is_headset = pipewire_sink_is_headset();
	volume_invalidate_cache(is_headset); /* force fresh read if needed */

	vol = speaker_active >= 0.0 ? speaker_active : volume_last_for_type(is_headset);
	if (vol < 0.0)
		vol = pipewire_volume_percent(&is_headset);
	if (vol < 0.0)
		return 0;

	if (volume_muted == 1) {
		set_pipewire_mute(0);
	}

	vol += (double)steps * volume_step;
	if (vol < 0.0)
		vol = 0.0;
	if (vol > volume_max_percent)
		vol = volume_max_percent;

	if (set_pipewire_volume(vol) != 0)
		return 0;

	now = monotonic_msec();
	volume_cache_store(is_headset, vol, 0, now);
	speaker_active = vol;
	if (is_headset) {
		volume_cached_headset_muted = 0;
	} else {
		volume_cached_speaker_muted = 0;
	}
	refreshstatusvolume();
	return 1;
}

static int
adjust_mic_by_steps(int steps)
{
	double vol;
	double target;

	if (steps == 0)
		return 0;

	mic_last_read_ms = 0;
	vol = microphone_active >= 0.0 ? microphone_active : mic_last_percent;
	if (vol < 0.0)
		vol = pipewire_mic_volume_percent();
	if (vol < 0.0)
		return 0;

	if (mic_muted == 1) {
		set_pipewire_mic_mute(0);
	}

	target = vol + (double)steps * mic_step;
	if (target < 0.0)
		target = 0.0;
	if (target > mic_max_percent)
		target = mic_max_percent;

	if (set_pipewire_mic_volume(target) != 0)
		return 0;

	mic_last_percent = target;
	mic_cached = target;
	mic_cached_muted = 0;
	mic_muted = 0;
	mic_last_read_ms = monotonic_msec();
	microphone_active = target;
	refreshstatusmic();
	return 1;
}

static int
handlestatusscroll(struct wlr_pointer_axis_event *event)
{
	Monitor *m;
	int lx, ly, steps;

	if (!event || locked)
		return 0;

	if (event->orientation != WL_POINTER_AXIS_VERTICAL_SCROLL)
		return 0;

	m = xytomon(cursor->x, cursor->y);
	if (!m)
		return 0;
	selmon = m;

	if (!m->showbar || !m->statusbar.area.width || !m->statusbar.area.height)
		return 0;

	lx = (int)floor(cursor->x) - m->statusbar.area.x;
	ly = (int)floor(cursor->y) - m->statusbar.area.y;
	if (lx < 0 || ly < 0 || lx >= m->statusbar.area.width || ly >= m->statusbar.area.height)
		return 0;

	steps = scrollsteps(event);
	if (steps == 0)
		return 0;

	if (m->statusbar.light.width > 0 &&
			lx >= m->statusbar.light.x &&
			lx < m->statusbar.light.x + m->statusbar.light.width) {
		return adjust_backlight_by_steps(steps);
	}

	if (m->statusbar.mic.width > 0 &&
			lx >= m->statusbar.mic.x &&
			lx < m->statusbar.mic.x + m->statusbar.mic.width) {
		return adjust_mic_by_steps(steps);
	}

	if (m->statusbar.volume.width > 0 &&
			lx >= m->statusbar.volume.x &&
			lx < m->statusbar.volume.x + m->statusbar.volume.width) {
		return adjust_volume_by_steps(steps);
	}

	return 0;
}

void
axisnotify(struct wl_listener *listener, void *data)
{
	/* This event is forwarded by the cursor when a pointer emits an axis event,
	 * for example when you move the scroll wheel. */
	struct wlr_pointer_axis_event *event = data;
	wlr_idle_notifier_v1_notify_activity(idle_notifier, seat);
	if (!handlestatusscroll(event)) {
		/* Notify the client with pointer focus of the axis event. */
		wlr_seat_pointer_notify_axis(seat,
				event->time_msec, event->orientation, event->delta,
				event->delta_discrete, event->source, event->relative_direction);
	}
}

/* Internal handler for pointer button events - used by both real mouse and gamepad */
void
handle_pointer_button_internal(uint32_t button, uint32_t state, uint32_t time_msec)
{
	struct wlr_keyboard *keyboard;
	uint32_t mods;
	Client *c;
	const Button *b;

	wlr_idle_notifier_v1_notify_activity(idle_notifier, seat);

	if (state == WL_POINTER_BUTTON_STATE_PRESSED) {
		cursor_mode = CurPressed;
		selmon = xytomon(cursor->x, cursor->y);
		if (locked)
			goto notify_client;

		/* Modal overlay eats clicks; outside closes it */
		{
			Monitor *modal_mon = modal_visible_monitor();
			if (modal_mon) {
				ModalOverlay *mo = &modal_mon->modal;
				int inside = cursor->x >= mo->x && cursor->x < mo->x + mo->width &&
						cursor->y >= mo->y && cursor->y < mo->y + mo->height;
				if (!inside)
					modal_hide(modal_mon);
				return;
			}
		}

		if (selmon && selmon->statusbar.tray_menu.visible) {
			int lx = (int)lround(cursor->x - selmon->statusbar.area.x);
			int ly = (int)lround(cursor->y - selmon->statusbar.area.y);
			TrayMenu *menu = &selmon->statusbar.tray_menu;
			int relx = lx - menu->x;
			int rely = ly - menu->y;
			if (relx >= 0 && rely >= 0 &&
					relx < menu->width && rely < menu->height) {
				TrayMenuEntry *entry = tray_menu_entry_at(selmon, relx, rely);
				if (entry)
					tray_menu_send_event(menu, entry, time_msec);
				tray_menu_hide_all();
				return;
			} else {
				tray_menu_hide_all();
			}
		}

		if (selmon && selmon->wifi_popup.visible) {
			int lx = (int)lround(cursor->x);
			int ly = (int)lround(cursor->y);
			if (wifi_popup_handle_click(selmon, lx, ly, button))
				return;
		}

		if (selmon && selmon->statusbar.net_menu.visible) {
			int lx = (int)lround(cursor->x - selmon->statusbar.area.x);
			int ly = (int)lround(cursor->y - selmon->statusbar.area.y);
			if (net_menu_handle_click(selmon, lx, ly, button))
				return;
		}

		if (selmon && selmon->showbar) {
			int lx = (int)lround(cursor->x - selmon->statusbar.area.x);
			int ly = (int)lround(cursor->y - selmon->statusbar.area.y);
			StatusModule *tags = &selmon->statusbar.tags;
			StatusModule *mic = &selmon->statusbar.mic;
			StatusModule *vol = &selmon->statusbar.volume;
			StatusModule *cpu = &selmon->statusbar.cpu;
			StatusModule *sys = &selmon->statusbar.sysicons;
			StatusModule *bt = &selmon->statusbar.bluetooth;
			StatusModule *stm = &selmon->statusbar.steam;
			StatusModule *dsc = &selmon->statusbar.discord;

			if (selmon->statusbar.cpu_popup.visible) {
				if (cpu_popup_handle_click(selmon, lx, ly, button))
					return;
			}

			if (selmon->statusbar.ram_popup.visible) {
				if (ram_popup_handle_click(selmon, lx, ly, button))
					return;
			}

			if (lx >= 0 && ly >= 0 &&
					lx < selmon->statusbar.area.width &&
					ly < selmon->statusbar.area.height) {
				if (button == BTN_RIGHT &&
						sys->width > 0 &&
						lx >= sys->x && lx < sys->x + sys->width) {
					net_menu_hide_all();
					net_menu_open(selmon);
					return;
				}

				if (button == BTN_LEFT &&
						sys->width > 0 &&
						lx >= sys->x && lx < sys->x + sys->width) {
					Arg arg = { .v = netcmd };
					spawn(&arg);
					return;
				}

				if (cpu->width > 0 && lx >= cpu->x && lx < cpu->x + cpu->width) {
					Arg arg = { .v = btopcmd };
					spawn(&arg);
					return;
				}

				if (mic->width > 0 && lx >= mic->x && lx < mic->x + mic->width) {
					toggle_pipewire_mic_mute();
					return;
				}

				if (vol->width > 0 && lx >= vol->x && lx < vol->x + vol->width) {
					toggle_pipewire_mute();
					return;
				}

				/* Bluetooth module click - open bluetooth manager */
				if (button == BTN_LEFT &&
						bt->width > 0 &&
						lx >= bt->x && lx < bt->x + bt->width) {
					pid_t pid = fork();
					if (pid == 0) {
						setsid();
						execlp("blueman-manager", "blueman-manager", NULL);
						_exit(1);
					}
					return;
				}

				/* Steam module click - focus or launch Steam */
				if (button == BTN_LEFT &&
						stm->width > 0 &&
						lx >= stm->x && lx < stm->x + stm->width) {
					focus_or_launch_app("steam", "steam");
					return;
				}

				/* Discord module click - focus or launch Discord */
				if (button == BTN_LEFT &&
						dsc->width > 0 &&
						lx >= dsc->x && lx < dsc->x + dsc->width) {
					focus_or_launch_app("discord", "discord");
					return;
				}

				if (button == BTN_LEFT && lx < tags->width) {
					for (int i = 0; i < tags->box_count; i++) {
						int bx = tags->box_x[i];
						int bw = tags->box_w[i];
						if (lx >= bx && lx < bx + bw) {
							Arg arg = { .ui = 1u << tags->box_tag[i] };
							view(&arg);
							return;
						}
					}
				}
			}
		}

		/* Change focus if the button was _pressed_ over a client */
		xytonode(cursor->x, cursor->y, NULL, &c, NULL, NULL, NULL);
		if (c && (!client_is_unmanaged(c) || client_wants_focus(c)))
			focusclient(c, 1);

		keyboard = wlr_seat_get_keyboard(seat);
		mods = keyboard ? wlr_keyboard_get_modifiers(keyboard) : 0;
		for (b = buttons; b < END(buttons); b++) {
			if (CLEANMASK(mods) == CLEANMASK(b->mod) &&
					button == b->button && b->func) {
				b->func(&b->arg);
				return;
			}
		}
	} else if (state == WL_POINTER_BUTTON_STATE_RELEASED) {
		/* Reset cursor mode on release */
		if (cursor_mode == CurPressed)
			cursor_mode = CurNormal;
	}

notify_client:
	/* Notify the client with pointer focus */
	wlr_seat_pointer_notify_button(seat, time_msec, button, state);
}

void
buttonpress(struct wl_listener *listener, void *data)
{
	struct wlr_pointer_button_event *event = data;
	struct wlr_keyboard *keyboard;
	uint32_t mods;
	Client *c, *target = NULL;
	const Button *b;

	wlr_idle_notifier_v1_notify_activity(idle_notifier, seat);

	switch (event->state) {
	case WL_POINTER_BUTTON_STATE_PRESSED:
		cursor_mode = CurPressed;
		selmon = xytomon(cursor->x, cursor->y);
		if (locked)
			break;

		/* Modal overlay eats clicks; outside closes it */
		{
			Monitor *modal_mon = modal_visible_monitor();
			if (modal_mon) {
				ModalOverlay *mo = &modal_mon->modal;
				int inside = cursor->x >= mo->x && cursor->x < mo->x + mo->width &&
						cursor->y >= mo->y && cursor->y < mo->y + mo->height;
				if (!inside)
					modal_hide(modal_mon);
				return;
			}
		}

		/* Handle gamepad/HTPC menu clicks */
		if (selmon && selmon->gamepad_menu.visible) {
			int cx = (int)lround(cursor->x);
			int cy = (int)lround(cursor->y);
			if (gamepad_menu_handle_click(selmon, cx, cy, event->button))
				return;
		}

		if (selmon && selmon->statusbar.tray_menu.visible) {
			int lx = (int)lround(cursor->x - selmon->statusbar.area.x);
			int ly = (int)lround(cursor->y - selmon->statusbar.area.y);
			TrayMenu *menu = &selmon->statusbar.tray_menu;
			int relx = lx - menu->x;
			int rely = ly - menu->y;
			if (relx >= 0 && rely >= 0 &&
					relx < menu->width && rely < menu->height) {
				TrayMenuEntry *entry = tray_menu_entry_at(selmon, relx, rely);
				if (entry)
					tray_menu_send_event(menu, entry, event->time_msec);
				tray_menu_hide_all();
				return;
			} else {
				tray_menu_hide_all();
			}
		}

		if (selmon && selmon->wifi_popup.visible) {
			int lx = (int)lround(cursor->x);
			int ly = (int)lround(cursor->y);
			if (wifi_popup_handle_click(selmon, lx, ly, event->button))
				return;
		}

		if (selmon && selmon->statusbar.net_menu.visible) {
			int lx = (int)lround(cursor->x - selmon->statusbar.area.x);
			int ly = (int)lround(cursor->y - selmon->statusbar.area.y);
			if (net_menu_handle_click(selmon, lx, ly, event->button))
				return;
		}

		if (selmon && selmon->showbar) {
			int lx = (int)lround(cursor->x - selmon->statusbar.area.x);
			int ly = (int)lround(cursor->y - selmon->statusbar.area.y);
			StatusModule *tags = &selmon->statusbar.tags;
			StatusModule *mic = &selmon->statusbar.mic;
			StatusModule *vol = &selmon->statusbar.volume;
			StatusModule *cpu = &selmon->statusbar.cpu;
			StatusModule *sys = &selmon->statusbar.sysicons;
			StatusModule *bt = &selmon->statusbar.bluetooth;
			StatusModule *stm = &selmon->statusbar.steam;
			StatusModule *dsc = &selmon->statusbar.discord;

			if (selmon->statusbar.cpu_popup.visible) {
				if (cpu_popup_handle_click(selmon, lx, ly, event->button))
					return;
			}

			if (selmon->statusbar.ram_popup.visible) {
				if (ram_popup_handle_click(selmon, lx, ly, event->button))
					return;
			}

			if (lx >= 0 && ly >= 0 &&
					lx < selmon->statusbar.area.width &&
					ly < selmon->statusbar.area.height) {
				if (event->button == BTN_RIGHT &&
						sys->width > 0 &&
						lx >= sys->x && lx < sys->x + sys->width) {
					net_menu_hide_all();
					net_menu_open(selmon);
					return;
				}

				if (event->button == BTN_LEFT &&
						sys->width > 0 &&
						lx >= sys->x && lx < sys->x + sys->width) {
					Arg arg = { .v = netcmd };
					spawn(&arg);
					return;
				}

				if (cpu->width > 0 && lx >= cpu->x && lx < cpu->x + cpu->width) {
					Arg arg = { .v = btopcmd };
					spawn(&arg);
					return;
				}

				if (mic->width > 0 && lx >= mic->x && lx < mic->x + mic->width) {
					toggle_pipewire_mic_mute();
					return;
				}

				if (vol->width > 0 && lx >= vol->x && lx < vol->x + vol->width) {
					toggle_pipewire_mute();
					return;
				}

				/* Bluetooth module click - open bluetooth manager */
				if (event->button == BTN_LEFT &&
						bt->width > 0 &&
						lx >= bt->x && lx < bt->x + bt->width) {
					pid_t pid = fork();
					if (pid == 0) {
						setsid();
						execlp("blueman-manager", "blueman-manager", NULL);
						_exit(1);
					}
					return;
				}

				/* Steam module click - focus or launch Steam */
				if (event->button == BTN_LEFT &&
						stm->width > 0 &&
						lx >= stm->x && lx < stm->x + stm->width) {
					focus_or_launch_app("steam", "steam");
					return;
				}

				/* Discord module click - focus or launch Discord */
				if (event->button == BTN_LEFT &&
						dsc->width > 0 &&
						lx >= dsc->x && lx < dsc->x + dsc->width) {
					focus_or_launch_app("discord", "discord");
					return;
				}

				if (event->button == BTN_LEFT && lx < tags->width) {
					for (int i = 0; i < tags->box_count; i++) {
						int bx = tags->box_x[i];
						int bw = tags->box_w[i];
						if (lx >= bx && lx < bx + bw) {
							Arg arg = { .ui = 1u << tags->box_tag[i] };
							view(&arg);
							return;
						}
					}
				}
			}
		}

		/* Change focus if the button was _pressed_ over a client */
		xytonode(cursor->x, cursor->y, NULL, &c, NULL, NULL, NULL);
		if (c && (!client_is_unmanaged(c) || client_wants_focus(c)))
			focusclient(c, 1);

		keyboard = wlr_seat_get_keyboard(seat);
		mods = keyboard ? wlr_keyboard_get_modifiers(keyboard) : 0;
		for (b = buttons; b < END(buttons); b++) {
			if (CLEANMASK(mods) == CLEANMASK(b->mod) &&
					event->button == b->button && b->func) {
				b->func(&b->arg);
				return;
			}
		}
		break;
	case WL_POINTER_BUTTON_STATE_RELEASED:
		/* If you released any buttons, we exit interactive move/resize mode. */
		/* TODO: should reset to the pointer focus's current setcursor */
		if (!locked && cursor_mode != CurNormal && cursor_mode != CurPressed) {
			c = grabc;
			if (c && c->was_tiled && !strcmp(selmon->ltsymbol, "|w|")) {
				if (cursor_mode == CurMove && c->isfloating) {
					target = xytoclient(cursor->x, cursor->y);
					int was_alone = drag_was_alone_in_column;
					int move_allowed;

					/* Clear drag state before modifying tree */
					end_tile_drag();

					/* Restore tiled state */
					c->isfloating = 0;

					/* Column swap takes priority - check if source was alone and target is in different column */
					if (was_alone && target && target != c &&
					    !target->isfloating && !target->isfullscreen &&
					    !same_column(selmon, c, target)) {
						/* Swap columns if dragged tile was alone in its column */
						swap_columns(selmon, c, target);
						arrange(selmon);
					} else {
						/* Check if movement is allowed before modifying anything */
						if (target && target != c && !target->isfloating && !target->isfullscreen)
							move_allowed = can_move_tile(selmon, c, target);
						else
							move_allowed = can_move_tile(selmon, c, NULL);

						if (move_allowed == 0) {
							/* Movement blocked (4 tiles in source or target column) */
							/* Just restore to original position, no change */
							arrange(selmon);
						} else if (move_allowed == 2 && target && target != c) {
							/* Same column swap */
							swap_tiles_in_tree(selmon, c, target);
							arrange(selmon);
						} else {
							/* Remove from old position and insert at new */
							remove_client(selmon, c);
							if (target && target != c && !target->isfloating && !target->isfullscreen)
								insert_client_at(selmon, target, c, cursor->x, cursor->y);
							else
								insert_client(selmon, NULL, c);
							arrange(selmon);
						}
					}

				} else if (cursor_mode == CurResize && !c->isfloating) {
					resizing_from_mouse = 0;
				}
			} else {
				if (cursor_mode == CurResize && resizing_from_mouse)
					resizing_from_mouse = 0;
				resize_last_time = 0;
				end_tile_drag();
			}
			/* Default behaviour */
			wlr_cursor_set_xcursor(cursor, cursor_mgr, "default");
			cursor_mode = CurNormal;
			/* Drop the window off on its new monitor */
			selmon = xytomon(cursor->x, cursor->y);
			setmon(grabc, selmon, 0);
			grabc = NULL;
			return;
		}
		cursor_mode = CurNormal;
		break;
	}
	/* If the event wasn't handled by the compositor, notify the client with
	 * pointer focus that a button press has occurred */
	wlr_seat_pointer_notify_button(seat,
			event->time_msec, event->button, event->state);
}

void
chvt(const Arg *arg)
{
	wlr_session_change_vt(session, arg->ui);
}

void
checkidleinhibitor(struct wlr_surface *exclude)
{
	int inhibited = 0, unused_lx, unused_ly;
	struct wlr_idle_inhibitor_v1 *inhibitor;
	wl_list_for_each(inhibitor, &idle_inhibit_mgr->inhibitors, link) {
		struct wlr_surface *surface = wlr_surface_get_root_surface(inhibitor->surface);
		struct wlr_scene_tree *tree = surface->data;
		if (exclude != surface && (bypass_surface_visibility || (!tree
				|| wlr_scene_node_coords(&tree->node, &unused_lx, &unused_ly)))) {
			inhibited = 1;
			break;
		}
	}

	wlr_idle_notifier_v1_set_inhibited(idle_notifier, inhibited);
}

void
cleanup(void)
{
	TrayItem *it, *tmp;

	wlr_log(WLR_ERROR, "cleanup() called - starting cleanup sequence");
	cleanuplisteners();
	gamepad_cleanup();
	bt_controller_cleanup();
	drop_net_icon_buffer();
	drop_cpu_icon_buffer();
	drop_clock_icon_buffer();
	drop_light_icon_buffer();
	drop_ram_icon_buffer();
	drop_battery_icon_buffer();
	drop_mic_icon_buffer();
	drop_volume_icon_buffer();
	drop_bluetooth_icon_buffer();
	drop_steam_icon_buffer();
	drop_discord_icon_buffer();
	stop_public_ip_fetch();
	stop_ssid_fetch();
	wifi_scan_finish();
	net_menu_hide_all();
	wifi_networks_clear();
	last_clock_render[0] = last_cpu_render[0] = last_ram_render[0] = '\0';
	last_light_render[0] = last_volume_render[0] = last_mic_render[0] = last_battery_render[0] = '\0';
	last_net_render[0] = '\0';
	last_clock_h = last_cpu_h = last_ram_h = last_light_h = last_volume_h = last_mic_h = last_battery_h = last_net_h = 0;
	if (wifi_scan_timer) {
		wl_event_source_remove(wifi_scan_timer);
		wifi_scan_timer = NULL;
	}
	if (status_timer) {
		wl_event_source_remove(status_timer);
		status_timer = NULL;
	}
	if (status_cpu_timer) {
		wl_event_source_remove(status_cpu_timer);
		status_cpu_timer = NULL;
	}
	if (status_hover_timer) {
		wl_event_source_remove(status_hover_timer);
		status_hover_timer = NULL;
	}
	if (cpu_popup_refresh_timer) {
		wl_event_source_remove(cpu_popup_refresh_timer);
		cpu_popup_refresh_timer = NULL;
	}
	if (ram_popup_refresh_timer) {
		wl_event_source_remove(ram_popup_refresh_timer);
		ram_popup_refresh_timer = NULL;
	}
	if (popup_delay_timer) {
		wl_event_source_remove(popup_delay_timer);
		popup_delay_timer = NULL;
	}
	if (pc_gaming_install_timer) {
		wl_event_source_remove(pc_gaming_install_timer);
		pc_gaming_install_timer = NULL;
	}
	/* Clean up config rewatch timer */
	if (config_rewatch_timer) {
		wl_event_source_remove(config_rewatch_timer);
		config_rewatch_timer = NULL;
	}
	config_needs_rewatch = 0;
	tray_menu_hide_all();
	if (tray_event) {
		wl_event_source_remove(tray_event);
		tray_event = NULL;
	}
	if (tray_vtable_slot)
		sd_bus_slot_unref(tray_vtable_slot);
	if (tray_fdo_vtable_slot)
		sd_bus_slot_unref(tray_fdo_vtable_slot);
	if (tray_name_slot)
		sd_bus_slot_unref(tray_name_slot);
	if (tray_bus)
		sd_bus_unref(tray_bus);
	wl_list_for_each_safe(it, tmp, &tray_items, link) {
		if (it->icon_buf)
			wlr_buffer_drop(it->icon_buf);
		wl_list_remove(&it->link);
		free(it);
	}
#ifdef XWAYLAND
	wlr_xwayland_destroy(xwayland);
	xwayland = NULL;
#endif
	/* Stop systemd target */
	if (fork() == 0) {
		setsid();
		if (has_nixlytile_session_target()) {
			execvp("systemctl", (char *const[]) {
				"systemctl", "--user", "stop", "nixlytile-session.target", NULL
			});
		}
		exit(1);
	}

	/* Send close to all clients and give them time to save state */
	{
		Client *c;
		int has_clients = 0;
		wl_list_for_each(c, &clients, link) {
			client_send_close(c);
			has_clients = 1;
		}
		/* Wait for clients to close gracefully */
		if (has_clients) {
			struct timespec ts = {0, 500000000}; /* 500ms */
			nanosleep(&ts, NULL);
		}
	}

	wl_display_destroy_clients(dpy);
	if (child_pid > 0) {
		kill(-child_pid, SIGTERM);
		waitpid(child_pid, NULL, 0);
	}
	freestatusfont();
	if (fcft_initialized) {
		fcft_fini();
		fcft_initialized = 0;
	}
	wlr_xcursor_manager_destroy(cursor_mgr);

	destroykeyboardgroup(&kb_group->destroy, NULL);

	/* If it's not destroyed manually, it will cause a use-after-free of wlr_seat.
	 * Destroy it until it's fixed on the wlroots side */
	wlr_backend_destroy(backend);

	wl_display_destroy(dpy);
	/* Destroy after the wayland display (when the monitors are already destroyed)
	   to avoid destroying them with an invalid scene output. */
	wlr_scene_node_destroy(&scene->tree.node);
}

void
cleanupmon(struct wl_listener *listener, void *data)
{
	Monitor *m = wl_container_of(listener, m, destroy);
	LayerSurface *l, *tmp;
	size_t i;

	modal_file_search_stop(m);

	/* m->layers[i] are intentionally not unlinked */
	for (i = 0; i < LENGTH(m->layers); i++) {
		wl_list_for_each_safe(l, tmp, &m->layers[i], link)
			wlr_layer_surface_v1_destroy(l->layer_surface);
	}

	wl_list_remove(&m->destroy.link);
	wl_list_remove(&m->frame.link);
	wl_list_remove(&m->link);
	wl_list_remove(&m->request_state.link);
	if (m->lock_surface)
		destroylocksurface(&m->destroy_lock_surface, NULL);
	m->wlr_output->data = NULL;
	wlr_output_layout_remove(output_layout, m->wlr_output);
	wlr_scene_output_destroy(m->scene_output);

	if (m->statusbar.tree)
		wlr_scene_node_destroy(&m->statusbar.tree->node);
	if (m->modal.tree)
		wlr_scene_node_destroy(&m->modal.tree->node);
	if (m->nixpkgs.tree)
		wlr_scene_node_destroy(&m->nixpkgs.tree->node);
	if (m->wifi_popup.tree)
		wlr_scene_node_destroy(&m->wifi_popup.tree->node);
	destroy_tree(m);
	closemon(m);
	wlr_scene_node_destroy(&m->fullscreen_bg->node);
	free(m);
}

void
cleanuplisteners(void)
{
	wl_list_remove(&cursor_axis.link);
	wl_list_remove(&cursor_button.link);
	wl_list_remove(&cursor_frame.link);
	wl_list_remove(&cursor_motion.link);
	wl_list_remove(&cursor_motion_absolute.link);
	wl_list_remove(&gpu_reset.link);
	wl_list_remove(&new_idle_inhibitor.link);
	wl_list_remove(&layout_change.link);
	wl_list_remove(&new_input_device.link);
	wl_list_remove(&new_virtual_keyboard.link);
	wl_list_remove(&new_virtual_pointer.link);
	wl_list_remove(&new_pointer_constraint.link);
	wl_list_remove(&new_output.link);
	wl_list_remove(&new_xdg_toplevel.link);
	wl_list_remove(&new_xdg_decoration.link);
	wl_list_remove(&new_xdg_popup.link);
	wl_list_remove(&new_layer_surface.link);
	wl_list_remove(&output_mgr_apply.link);
	wl_list_remove(&output_mgr_test.link);
	wl_list_remove(&output_power_mgr_set_mode.link);
	wl_list_remove(&request_activate.link);
	wl_list_remove(&request_cursor.link);
	wl_list_remove(&request_set_psel.link);
	wl_list_remove(&request_set_sel.link);
	wl_list_remove(&request_set_cursor_shape.link);
	wl_list_remove(&request_start_drag.link);
	wl_list_remove(&start_drag.link);
	wl_list_remove(&new_session_lock.link);
#ifdef XWAYLAND
	wl_list_remove(&new_xwayland_surface.link);
	wl_list_remove(&xwayland_ready.link);
#endif
}

void
closemon(Monitor *m)
{
	/* update selmon if needed and
	 * move closed monitor's clients to the focused one */
	Client *c;
	int i = 0, nmons = wl_list_length(&mons);
	if (!nmons) {
		selmon = NULL;
	} else if (m == selmon) {
		do /* don't switch to disabled mons */
			selmon = wl_container_of(mons.next, selmon, link);
		while (!selmon->wlr_output->enabled && i++ < nmons);

		if (!selmon->wlr_output->enabled)
			selmon = NULL;
	}

	wl_list_for_each(c, &clients, link) {
		if (c->isfloating && c->geom.x > m->m.width)
			resize(c, (struct wlr_box){.x = c->geom.x - m->w.width, .y = c->geom.y,
					.width = c->geom.width, .height = c->geom.height}, 0);
		if (c->mon == m)
			setmon(c, selmon, c->tags);
	}
	focusclient(focustop(selmon), 1);
	printstatus();
}

void
commitlayersurfacenotify(struct wl_listener *listener, void *data)
{
	LayerSurface *l = wl_container_of(listener, l, surface_commit);
	struct wlr_layer_surface_v1 *layer_surface = l->layer_surface;
	struct wlr_scene_tree *scene_layer = layers[layermap[layer_surface->current.layer]];
	struct wlr_layer_surface_v1_state old_state;

	if (l->layer_surface->initial_commit) {
		client_set_scale(layer_surface->surface, l->mon->wlr_output->scale);

		/* Temporarily set the layer's current state to pending
		 * so that we can easily arrange it */
		old_state = l->layer_surface->current;
		l->layer_surface->current = l->layer_surface->pending;
		arrangelayers(l->mon);
		l->layer_surface->current = old_state;
		return;
	}

	if (layer_surface->current.committed == 0 && l->mapped == layer_surface->surface->mapped)
		return;
	l->mapped = layer_surface->surface->mapped;

	if (scene_layer != l->scene->node.parent) {
		wlr_scene_node_reparent(&l->scene->node, scene_layer);
		wl_list_remove(&l->link);
		wl_list_insert(&l->mon->layers[layer_surface->current.layer], &l->link);
		wlr_scene_node_reparent(&l->popups->node, (layer_surface->current.layer
				< ZWLR_LAYER_SHELL_V1_LAYER_TOP ? layers[LyrTop] : scene_layer));
	}

	arrangelayers(l->mon);
}

void
commitnotify(struct wl_listener *listener, void *data)
{
	Client *c = wl_container_of(listener, c, commit);

	if (c->surface.xdg->initial_commit) {
		/*
		 * Get the monitor this client will be rendered on
		 * Note that if the user set a rule in which the client is placed on
		 * a different monitor based on its title, this will likely select
		 * a wrong monitor.
		 */
		applyrules(c);
		if (c->mon) {
			client_set_scale(client_surface(c), c->mon->wlr_output->scale);
		}
		setmon(c, NULL, 0); /* Make sure to reapply rules in mapnotify() */

		wlr_xdg_toplevel_set_wm_capabilities(c->surface.xdg->toplevel,
				WLR_XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN);
		if (c->decoration)
			requestdecorationmode(&c->set_decoration_mode, c->decoration);
		wlr_xdg_toplevel_set_size(c->surface.xdg->toplevel, 0, 0);
		return;
	}

	/* mark a pending resize as completed */
	if (c->resize && c->resize <= c->surface.xdg->current.configure_serial) {
		c->resize = 0;
		c->pending_resize_w = c->pending_resize_h = -1;
	}

	/* Track frame times for fullscreen clients (video detection) */
	if (c->isfullscreen)
		track_client_frame(c);

	/* For tiled clients in a tiling layout, use the geometry from btrtile
	 * (stored in old_geom) to ensure proper tiling. This prevents clients
	 * from appearing at their initial centered position before the layout
	 * has positioned them. */
	if (!c->isfloating && !c->isfullscreen && c->mon &&
	    c->mon->lt[c->mon->sellt]->arrange &&
	    c->old_geom.width > 0 && c->old_geom.height > 0) {
		resize(c, c->old_geom, 0);
	} else {
		resize(c, c->geom, (c->isfloating && !c->isfullscreen));
	}
}

void
commitpopup(struct wl_listener *listener, void *data)
{
	struct wlr_surface *surface = data;
	struct wlr_xdg_popup *popup = wlr_xdg_popup_try_from_wlr_surface(surface);
	LayerSurface *l = NULL;
	Client *c = NULL;
	struct wlr_box box;
	int type = -1;

	if (!popup->base->initial_commit)
		return;

	type = toplevel_from_wlr_surface(popup->base->surface, &c, &l);
	if (!popup->parent || type < 0)
		return;
	popup->base->surface->data = wlr_scene_xdg_surface_create(
			popup->parent->data, popup->base);
	if ((l && !l->mon) || (c && !c->mon)) {
		wlr_xdg_popup_destroy(popup);
		return;
	}
	box = type == LayerShell ? l->mon->m : c->mon->w;
	box.x -= (type == LayerShell ? l->scene->node.x : c->geom.x);
	box.y -= (type == LayerShell ? l->scene->node.y : c->geom.y);
	wlr_xdg_popup_unconstrain_from_box(popup, &box);
	wl_list_remove(&listener->link);
	free(listener);
}

void
createdecoration(struct wl_listener *listener, void *data)
{
	struct wlr_xdg_toplevel_decoration_v1 *deco = data;
	Client *c = deco->toplevel->base->data;
	c->decoration = deco;

	LISTEN(&deco->events.request_mode, &c->set_decoration_mode, requestdecorationmode);
	LISTEN(&deco->events.destroy, &c->destroy_decoration, destroydecoration);

	requestdecorationmode(&c->set_decoration_mode, deco);
}

void
createidleinhibitor(struct wl_listener *listener, void *data)
{
	struct wlr_idle_inhibitor_v1 *idle_inhibitor = data;
	LISTEN_STATIC(&idle_inhibitor->events.destroy, destroyidleinhibitor);

	checkidleinhibitor(NULL);
}

void
createkeyboard(struct wlr_keyboard *keyboard)
{
	/* Set the keymap to match the group keymap */
	wlr_keyboard_set_keymap(keyboard, kb_group->wlr_group->keyboard.keymap);

	/* Add the new keyboard to the group */
	wlr_keyboard_group_add_keyboard(kb_group->wlr_group, keyboard);
}

KeyboardGroup *
createkeyboardgroup(void)
{
	KeyboardGroup *group = ecalloc(1, sizeof(*group));
	struct xkb_context *context;
	struct xkb_keymap *keymap;
	struct xkb_rule_names names;

	group->wlr_group = wlr_keyboard_group_create();
	group->wlr_group->data = group;

	/* Prepare an XKB keymap and assign it to the keyboard group. */
	context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
	names = getxkbrules();
	if (!(keymap = xkb_keymap_new_from_names(context, &names,
				XKB_KEYMAP_COMPILE_NO_FLAGS)))
		die("failed to compile keymap");

	wlr_keyboard_set_keymap(&group->wlr_group->keyboard, keymap);
	xkb_keymap_unref(keymap);
	xkb_context_unref(context);

	wlr_keyboard_set_repeat_info(&group->wlr_group->keyboard, repeat_rate, repeat_delay);

	/* Set up listeners for keyboard events */
	LISTEN(&group->wlr_group->keyboard.events.key, &group->key, keypress);
	LISTEN(&group->wlr_group->keyboard.events.modifiers, &group->modifiers, keypressmod);

	group->key_repeat_source = wl_event_loop_add_timer(event_loop, keyrepeat, group);

	/* A seat can only have one keyboard, but this is a limitation of the
	 * Wayland protocol - not wlroots. We assign all connected keyboards to the
	 * same wlr_keyboard_group, which provides a single wlr_keyboard interface for
	 * all of them. Set this combined wlr_keyboard as the seat keyboard.
	 */
	wlr_seat_set_keyboard(seat, &group->wlr_group->keyboard);
	return group;
}

void
createlayersurface(struct wl_listener *listener, void *data)
{
	struct wlr_layer_surface_v1 *layer_surface = data;
	LayerSurface *l;
	struct wlr_surface *surface = layer_surface->surface;
	struct wlr_scene_tree *scene_layer = layers[layermap[layer_surface->pending.layer]];

	if (!layer_surface->output
			&& !(layer_surface->output = selmon ? selmon->wlr_output : NULL)) {
		wlr_layer_surface_v1_destroy(layer_surface);
		return;
	}

	l = layer_surface->data = ecalloc(1, sizeof(*l));
	l->type = LayerShell;
	LISTEN(&surface->events.commit, &l->surface_commit, commitlayersurfacenotify);
	LISTEN(&surface->events.unmap, &l->unmap, unmaplayersurfacenotify);
	LISTEN(&layer_surface->events.destroy, &l->destroy, destroylayersurfacenotify);

	l->layer_surface = layer_surface;
	l->mon = layer_surface->output->data;
	l->scene_layer = wlr_scene_layer_surface_v1_create(scene_layer, layer_surface);
	l->scene = l->scene_layer->tree;
	l->popups = surface->data = wlr_scene_tree_create(layer_surface->current.layer
			< ZWLR_LAYER_SHELL_V1_LAYER_TOP ? layers[LyrTop] : scene_layer);
	l->scene->node.data = l->popups->node.data = l;

	wl_list_insert(&l->mon->layers[layer_surface->pending.layer],&l->link);
	wlr_surface_send_enter(surface, layer_surface->output);
}

void
createlocksurface(struct wl_listener *listener, void *data)
{
	SessionLock *lock = wl_container_of(listener, lock, new_surface);
	struct wlr_session_lock_surface_v1 *lock_surface = data;
	Monitor *m = lock_surface->output->data;
	struct wlr_scene_tree *scene_tree = lock_surface->surface->data
			= wlr_scene_subsurface_tree_create(lock->scene, lock_surface->surface);
	m->lock_surface = lock_surface;

	wlr_scene_node_set_position(&scene_tree->node, m->m.x, m->m.y);
	wlr_session_lock_surface_v1_configure(lock_surface, m->m.width, m->m.height);

	LISTEN(&lock_surface->events.destroy, &m->destroy_lock_surface, destroylocksurface);

	if (m == selmon)
		client_notify_enter(lock_surface->surface, wlr_seat_get_keyboard(seat));
}

static struct wlr_output_mode *
bestmode(struct wlr_output *output)
{
	struct wlr_output_mode *mode, *best = NULL;
	int best_area = 0, best_refresh = 0;

	wl_list_for_each(mode, &output->modes, link) {
		int area = mode->width * mode->height;
		if (!best || area > best_area || (area == best_area && mode->refresh > best_refresh)) {
			best = mode;
			best_area = area;
			best_refresh = mode->refresh;
		}
	}

	if (!best)
		best = wlr_output_preferred_mode(output);

	return best;
}

static void
initstatusbar(Monitor *m)
{
	if (!m)
		return;

	wl_list_init(&m->statusbar.tray_menu.entries);
	if (!wifi_networks_initialized) {
		wl_list_init(&wifi_networks);
		wifi_networks_initialized = 1;
	}
	if (!vpn_list_initialized) {
		wl_list_init(&vpn_connections);
		vpn_list_initialized = 1;
	}
	wl_list_init(&m->statusbar.net_menu.entries);
	wl_list_init(&m->statusbar.net_menu.networks);
	m->showbar = 1;
	m->statusbar.area = (struct wlr_box){0};
	m->statusbar.tree = wlr_scene_tree_create(layers[LyrTop]);
	if (m->statusbar.tree) {
		m->statusbar.tags.tree = wlr_scene_tree_create(m->statusbar.tree);
		if (m->statusbar.tags.tree) {
			m->statusbar.tags.bg = wlr_scene_tree_create(m->statusbar.tags.tree);
			m->statusbar.tags.hover_tag = -1;
			for (int i = 0; i < TAGCOUNT; i++)
				m->statusbar.tags.hover_alpha[i] = 0.0f;
		}
		m->statusbar.traylabel.tree = wlr_scene_tree_create(m->statusbar.tree);
		if (m->statusbar.traylabel.tree)
			m->statusbar.traylabel.bg = wlr_scene_tree_create(m->statusbar.traylabel.tree);
		m->statusbar.sysicons.tree = wlr_scene_tree_create(m->statusbar.tree);
		if (m->statusbar.sysicons.tree)
			m->statusbar.sysicons.bg = wlr_scene_tree_create(m->statusbar.sysicons.tree);
		m->statusbar.bluetooth.tree = wlr_scene_tree_create(m->statusbar.tree);
		if (m->statusbar.bluetooth.tree)
			m->statusbar.bluetooth.bg = wlr_scene_tree_create(m->statusbar.bluetooth.tree);
		m->statusbar.steam.tree = wlr_scene_tree_create(m->statusbar.tree);
		if (m->statusbar.steam.tree)
			m->statusbar.steam.bg = wlr_scene_tree_create(m->statusbar.steam.tree);
		m->statusbar.discord.tree = wlr_scene_tree_create(m->statusbar.tree);
		if (m->statusbar.discord.tree)
			m->statusbar.discord.bg = wlr_scene_tree_create(m->statusbar.discord.tree);
		m->statusbar.tray_menu.tree = wlr_scene_tree_create(m->statusbar.tree);
		if (m->statusbar.tray_menu.tree) {
			m->statusbar.tray_menu.bg = wlr_scene_tree_create(m->statusbar.tray_menu.tree);
			m->statusbar.tray_menu.visible = 0;
			wlr_scene_node_set_enabled(&m->statusbar.tray_menu.tree->node, 0);
		}
		m->statusbar.net_menu.tree = wlr_scene_tree_create(m->statusbar.tree);
		if (m->statusbar.net_menu.tree) {
			m->statusbar.net_menu.bg = wlr_scene_tree_create(m->statusbar.net_menu.tree);
			m->statusbar.net_menu.submenu_tree = wlr_scene_tree_create(m->statusbar.tree);
			if (m->statusbar.net_menu.submenu_tree)
				m->statusbar.net_menu.submenu_bg = wlr_scene_tree_create(m->statusbar.net_menu.submenu_tree);
			m->statusbar.net_menu.visible = 0;
			m->statusbar.net_menu.submenu_visible = 0;
			wlr_scene_node_set_enabled(&m->statusbar.net_menu.tree->node, 0);
			if (m->statusbar.net_menu.submenu_tree)
				wlr_scene_node_set_enabled(&m->statusbar.net_menu.submenu_tree->node, 0);
		}
		m->statusbar.cpu.tree = wlr_scene_tree_create(m->statusbar.tree);
		if (m->statusbar.cpu.tree)
			m->statusbar.cpu.bg = wlr_scene_tree_create(m->statusbar.cpu.tree);
	m->statusbar.net.tree = wlr_scene_tree_create(m->statusbar.tree);
	if (m->statusbar.net.tree) {
		m->statusbar.net.bg = wlr_scene_tree_create(m->statusbar.net.tree);
	}
	m->statusbar.battery.tree = wlr_scene_tree_create(m->statusbar.tree);
	if (m->statusbar.battery.tree)
		m->statusbar.battery.bg = wlr_scene_tree_create(m->statusbar.battery.tree);
	m->statusbar.light.tree = wlr_scene_tree_create(m->statusbar.tree);
	if (m->statusbar.light.tree)
		m->statusbar.light.bg = wlr_scene_tree_create(m->statusbar.light.tree);
	m->statusbar.mic.tree = wlr_scene_tree_create(m->statusbar.tree);
	if (m->statusbar.mic.tree)
		m->statusbar.mic.bg = wlr_scene_tree_create(m->statusbar.mic.tree);
	m->statusbar.volume.tree = wlr_scene_tree_create(m->statusbar.tree);
	if (m->statusbar.volume.tree)
		m->statusbar.volume.bg = wlr_scene_tree_create(m->statusbar.volume.tree);
	m->statusbar.ram.tree = wlr_scene_tree_create(m->statusbar.tree);
	if (m->statusbar.ram.tree)
		m->statusbar.ram.bg = wlr_scene_tree_create(m->statusbar.ram.tree);
	m->statusbar.clock.tree = wlr_scene_tree_create(m->statusbar.tree);
	if (m->statusbar.clock.tree)
		m->statusbar.clock.bg = wlr_scene_tree_create(m->statusbar.clock.tree);
	m->statusbar.cpu_popup.tree = wlr_scene_tree_create(m->statusbar.tree);
	if (m->statusbar.cpu_popup.tree) {
		m->statusbar.cpu_popup.bg = wlr_scene_tree_create(m->statusbar.cpu_popup.tree);
		m->statusbar.cpu_popup.visible = 0;
		m->statusbar.cpu_popup.hover_idx = -1;
		m->statusbar.cpu_popup.refresh_data = 0;
		m->statusbar.cpu_popup.last_fetch_ms = 0;
		m->statusbar.cpu_popup.suppress_refresh_until_ms = 0;
		wlr_scene_node_set_enabled(&m->statusbar.cpu_popup.tree->node, 0);
	}
	m->statusbar.ram_popup.tree = wlr_scene_tree_create(m->statusbar.tree);
	if (m->statusbar.ram_popup.tree) {
		m->statusbar.ram_popup.bg = wlr_scene_tree_create(m->statusbar.ram_popup.tree);
		m->statusbar.ram_popup.visible = 0;
		m->statusbar.ram_popup.hover_idx = -1;
		m->statusbar.ram_popup.refresh_data = 0;
		m->statusbar.ram_popup.last_fetch_ms = 0;
		m->statusbar.ram_popup.suppress_refresh_until_ms = 0;
		wlr_scene_node_set_enabled(&m->statusbar.ram_popup.tree->node, 0);
	}
	m->statusbar.battery_popup.tree = wlr_scene_tree_create(m->statusbar.tree);
	if (m->statusbar.battery_popup.tree) {
		m->statusbar.battery_popup.bg = wlr_scene_tree_create(m->statusbar.battery_popup.tree);
		m->statusbar.battery_popup.visible = 0;
		m->statusbar.battery_popup.refresh_data = 0;
		m->statusbar.battery_popup.last_fetch_ms = 0;
		m->statusbar.battery_popup.last_render_ms = 0;
		m->statusbar.battery_popup.suppress_refresh_until_ms = 0;
		wlr_scene_node_set_enabled(&m->statusbar.battery_popup.tree->node, 0);
	}
		m->statusbar.net_popup.tree = wlr_scene_tree_create(m->statusbar.tree);
		if (m->statusbar.net_popup.tree) {
			m->statusbar.net_popup.bg = wlr_scene_tree_create(m->statusbar.net_popup.tree);
			m->statusbar.net_popup.visible = 0;
			wlr_scene_node_set_enabled(&m->statusbar.net_popup.tree->node, 0);
		}
	}
	if (!m->modal.tree) {
		m->modal.tree = wlr_scene_tree_create(layers[LyrTop]);
		if (m->modal.tree) {
			m->modal.bg = wlr_scene_tree_create(m->modal.tree);
			m->modal.visible = 0;
			m->modal.active_idx = -1;
			for (int i = 0; i < 3; i++) {
				m->modal.search[i][0] = '\0';
				m->modal.search_len[i] = 0;
				m->modal.search_rendered[i][0] = '\0';
				m->modal.result_count[i] = 0;
				for (int j = 0; j < (int)LENGTH(m->modal.results[i]); j++)
					m->modal.results[i][j][0] = '\0';
				m->modal.selected[i] = -1;
				m->modal.scroll[i] = 0;
			}
			m->modal.search_field_tree = NULL;
			m->modal.render_timer = NULL;
			m->modal.render_pending = 0;
				for (int i = 0; i < (int)LENGTH(m->modal.file_results_path); i++) {
					m->modal.file_results_name[i][0] = '\0';
					m->modal.file_results_path[i][0] = '\0';
					m->modal.file_results_mtime[i] = 0;
				}
			m->modal.file_search_pid = -1;
	m->modal.file_search_fd = -1;
	m->modal.file_search_event = NULL;
	m->modal.file_search_timer = NULL;
	m->modal.file_search_len = 0;
	m->modal.file_search_buf[0] = '\0';
	m->modal.file_search_last[0] = '\0';
	m->modal.git_search_pid = -1;
	m->modal.git_search_fd = -1;
	m->modal.git_search_event = NULL;
	m->modal.git_search_len = 0;
	m->modal.git_search_buf[0] = '\0';
	m->modal.git_search_done = 0;
	m->modal.git_result_count = 0;
	m->modal.results_tree = NULL;
	m->modal.last_scroll = 0;
	m->modal.last_selected = -1;
	m->modal.row_highlight_count = 0;
	for (int i = 0; i < MODAL_MAX_RESULTS; i++)
		m->modal.row_highlights[i] = NULL;
	for (int i = 0; i < (int)LENGTH(m->modal.git_results_path); i++) {
		m->modal.git_results_name[i][0] = '\0';
		m->modal.git_results_path[i][0] = '\0';
		m->modal.git_results_mtime[i] = 0;
	}
			wlr_scene_node_set_enabled(&m->modal.tree->node, 0);
		}
	}
	if (!m->nixpkgs.tree) {
		m->nixpkgs.tree = wlr_scene_tree_create(layers[LyrTop]);
		if (m->nixpkgs.tree) {
			m->nixpkgs.bg = wlr_scene_tree_create(m->nixpkgs.tree);
			m->nixpkgs.visible = 0;
			m->nixpkgs.search[0] = '\0';
			m->nixpkgs.search_len = 0;
			m->nixpkgs.search_rendered[0] = '\0';
			m->nixpkgs.search_field_tree = NULL;
			m->nixpkgs.result_count = 0;
			m->nixpkgs.selected = -1;
			m->nixpkgs.scroll = 0;
			m->nixpkgs.results_tree = NULL;
			m->nixpkgs.last_scroll = 0;
			m->nixpkgs.last_selected = -1;
			m->nixpkgs.row_highlight_count = 0;
			for (int i = 0; i < MODAL_MAX_RESULTS; i++)
				m->nixpkgs.row_highlights[i] = NULL;
			wlr_scene_node_set_enabled(&m->nixpkgs.tree->node, 0);
		}
	}
	if (!m->wifi_popup.tree) {
		m->wifi_popup.tree = wlr_scene_tree_create(layers[LyrTop]);
		if (m->wifi_popup.tree) {
			m->wifi_popup.bg = NULL;
			m->wifi_popup.visible = 0;
			m->wifi_popup.ssid[0] = '\0';
			m->wifi_popup.password[0] = '\0';
			m->wifi_popup.password_len = 0;
			m->wifi_popup.cursor_pos = 0;
			m->wifi_popup.button_hover = 0;
			m->wifi_popup.connecting = 0;
			m->wifi_popup.error = 0;
			m->wifi_popup.try_saved = 0;
			m->wifi_popup.connect_pid = -1;
			m->wifi_popup.connect_fd = -1;
			m->wifi_popup.connect_event = NULL;
			wlr_scene_node_set_enabled(&m->wifi_popup.tree->node, 0);
		}
	}
	if (!m->sudo_popup.tree) {
		m->sudo_popup.tree = wlr_scene_tree_create(layers[LyrTop]);
		if (m->sudo_popup.tree) {
			m->sudo_popup.bg = wlr_scene_tree_create(m->sudo_popup.tree);
			m->sudo_popup.visible = 0;
			m->sudo_popup.title[0] = '\0';
			m->sudo_popup.password[0] = '\0';
			m->sudo_popup.password_len = 0;
			m->sudo_popup.cursor_pos = 0;
			m->sudo_popup.button_hover = 0;
			m->sudo_popup.running = 0;
			m->sudo_popup.error = 0;
			m->sudo_popup.pending_cmd[0] = '\0';
			m->sudo_popup.pending_pkg[0] = '\0';
			m->sudo_popup.sudo_pid = -1;
			m->sudo_popup.sudo_fd = -1;
			m->sudo_popup.sudo_event = NULL;
			m->sudo_popup.wait_timer = NULL;
			wlr_scene_node_set_enabled(&m->sudo_popup.tree->node, 0);
		}
	}
	if (!m->gamepad_menu.tree) {
		/* Use LyrBlock to ensure guide popup is always on top of fullscreen */
		m->gamepad_menu.tree = wlr_scene_tree_create(layers[LyrBlock]);
		if (m->gamepad_menu.tree) {
			m->gamepad_menu.bg = NULL;
			m->gamepad_menu.visible = 0;
			m->gamepad_menu.selected = 0;
			htpc_menu_build();
		m->gamepad_menu.item_count = htpc_menu_item_count;
			wlr_scene_node_set_enabled(&m->gamepad_menu.tree->node, 0);
		}
	}
}

/* Find a mode matching resolution and optionally refresh rate */
static struct wlr_output_mode *
find_mode(struct wlr_output *output, int width, int height, float refresh)
{
	struct wlr_output_mode *mode, *best = NULL;
	int best_refresh = 0;

	wl_list_for_each(mode, &output->modes, link) {
		if (mode->width == width && mode->height == height) {
			if (refresh > 0) {
				/* Find closest match to requested refresh rate */
				int mode_hz = mode->refresh / 1000;
				int target_hz = (int)refresh;
				if (!best || abs(mode_hz - target_hz) < abs(best_refresh - target_hz)) {
					best = mode;
					best_refresh = mode_hz;
				}
			} else {
				/* No refresh specified - pick highest */
				if (!best || mode->refresh > best->refresh) {
					best = mode;
					best_refresh = mode->refresh / 1000;
				}
			}
		}
	}
	return best;
}

void
createmon(struct wl_listener *listener, void *data)
{
	/* This event is raised by the backend when a new output (aka a display or
	 * monitor) becomes available. */
	struct wlr_output *wlr_output = data;
	const MonitorRule *r;
	RuntimeMonitorConfig *rtcfg;
	size_t i;
	struct wlr_output_state state;
	struct wlr_output_mode *mode;
	Monitor *m;
	Client *c;
	int use_runtime_config = 0;

	if (!wlr_output_init_render(wlr_output, alloc, drw))
		return;

	m = wlr_output->data = ecalloc(1, sizeof(*m));
	m->wlr_output = wlr_output;

	for (i = 0; i < LENGTH(m->layers); i++)
	wl_list_init(&m->layers[i]);
	initstatusbar(m);

	wlr_output_state_init(&state);
	/* Initialize monitor state using configured rules */
	m->gaps = gaps;

	m->tagset[0] = m->tagset[1] = 1;

	/* First check runtime monitor configuration */
	rtcfg = find_monitor_config(wlr_output->name);
	if (rtcfg) {
		use_runtime_config = 1;
		wlr_log(WLR_INFO, "Using runtime config for monitor %s", wlr_output->name);

		/* Check if monitor is disabled */
		if (!rtcfg->enabled) {
			wlr_log(WLR_INFO, "Monitor %s is disabled in config", wlr_output->name);
			wlr_output_state_set_enabled(&state, 0);
			wlr_output_commit_state(wlr_output, &state);
			wlr_output_state_finish(&state);
			free(m);
			wlr_output->data = NULL;
			return;
		}

		/* Apply runtime config */
		m->mfact = rtcfg->mfact;
		m->nmaster = rtcfg->nmaster;
		m->lt[0] = &layouts[0];
		m->lt[1] = &layouts[LENGTH(layouts) > 1 ? 1 : 0];
		strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, LENGTH(m->ltsymbol));
		wlr_output_state_set_scale(&state, rtcfg->scale);
		wlr_output_state_set_transform(&state, rtcfg->transform);

		/* Position will be calculated after mode is set */
		m->m.x = -1;
		m->m.y = -1;

		/* Find mode if resolution is specified */
		if (rtcfg->width > 0 && rtcfg->height > 0) {
			mode = find_mode(wlr_output, rtcfg->width, rtcfg->height, rtcfg->refresh);
			if (mode) {
				wlr_output_state_set_mode(&state, mode);
				wlr_log(WLR_INFO, "Set mode %dx%d@%d for %s",
					mode->width, mode->height, mode->refresh / 1000, wlr_output->name);
			} else {
				wlr_log(WLR_ERROR, "Mode %dx%d not found for %s, using auto",
					rtcfg->width, rtcfg->height, wlr_output->name);
				if ((mode = bestmode(wlr_output)))
					wlr_output_state_set_mode(&state, mode);
			}
		} else {
			/* Auto mode - pick best */
			if ((mode = bestmode(wlr_output)))
				wlr_output_state_set_mode(&state, mode);
		}
	}

	/* Fall back to compile-time monrules if no runtime config */
	if (!use_runtime_config) {
		for (r = monrules; r < END(monrules); r++) {
			if (!r->name || strstr(wlr_output->name, r->name)) {
				m->m.x = r->x;
				m->m.y = r->y;
				m->mfact = r->mfact;
				m->nmaster = r->nmaster;
				m->lt[0] = r->lt;
				m->lt[1] = &layouts[LENGTH(layouts) > 1 && r->lt != &layouts[1]];
				strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, LENGTH(m->ltsymbol));
				wlr_output_state_set_scale(&state, r->scale);
				wlr_output_state_set_transform(&state, r->rr);
				break;
			}
		}

		/* The mode is a tuple of (width, height, refresh rate), and each
		 * monitor supports only a specific set of modes. Pick the highest
		 * resolution and refresh rate available. */
		if ((mode = bestmode(wlr_output)))
			wlr_output_state_set_mode(&state, mode);
	}

	/* Set up event listeners */
	LISTEN(&wlr_output->events.frame, &m->frame, rendermon);
	LISTEN(&wlr_output->events.destroy, &m->destroy, cleanupmon);
	LISTEN(&wlr_output->events.request_state, &m->request_state, requestmonstate);
	LISTEN(&wlr_output->events.present, &m->present, outputpresent);

	wlr_output_state_set_enabled(&state, 1);
	wlr_output_commit_state(wlr_output, &state);
	wlr_output_state_finish(&state);

	/* Check VRR capability - try to enable adaptive sync to test support */
	m->vrr_capable = 0;
	m->vrr_active = 0;
	m->vrr_target_hz = 0.0f;
	/* Initialize game VRR fields */
	m->game_vrr_active = 0;
	m->game_vrr_target_fps = 0.0f;
	m->game_vrr_last_fps = 0.0f;
	m->game_vrr_last_change_ns = 0;
	m->game_vrr_stable_frames = 0;
	if (wlr_output_is_drm(wlr_output)) {
		struct wlr_output_state vrr_test;
		wlr_output_state_init(&vrr_test);
		wlr_output_state_set_adaptive_sync_enabled(&vrr_test, 1);
		if (wlr_output_test_state(wlr_output, &vrr_test)) {
			m->vrr_capable = 1;
			wlr_log(WLR_INFO, "Monitor %s supports VRR/Adaptive Sync", wlr_output->name);
		}
		wlr_output_state_finish(&vrr_test);
	}

	wl_list_insert(&mons, &m->link);
	printstatus();
	init_tree(m);
	modal_prewarm(m);

	/* The xdg-protocol specifies:
	 *
	 * If the fullscreened surface is not opaque, the compositor must make
	 * sure that other screen content not part of the same surface tree (made
	 * up of subsurfaces, popups or similarly coupled surfaces) are not
	 * visible below the fullscreened surface.
	 *
	 */
	/* updatemons() will resize and set correct position */
	m->fullscreen_bg = wlr_scene_rect_create(layers[LyrFS], 0, 0, fullscreen_bg);
	wlr_scene_node_set_enabled(&m->fullscreen_bg->node, 0);

	/* Adds this to the output layout in the order it was configured.
	 *
	 * The output layout utility automatically adds a wl_output global to the
	 * display, which Wayland clients can see to find out information about the
	 * output (such as DPI, scale factor, manufacturer, etc).
	 */
	m->scene_output = wlr_scene_output_create(scene, wlr_output);

	/* Calculate position for runtime-configured monitors */
	if (use_runtime_config && rtcfg && rtcfg->position != MON_POS_AUTO) {
		int pos_x, pos_y;
		/* Get monitor dimensions from the committed mode */
		if (wlr_output->current_mode) {
			m->m.width = wlr_output->current_mode->width;
			m->m.height = wlr_output->current_mode->height;
		}
		calculate_monitor_position(m, rtcfg, &pos_x, &pos_y);
		if (pos_x != -1 && pos_y != -1) {
			m->m.x = pos_x;
			m->m.y = pos_y;
			wlr_log(WLR_INFO, "Positioning monitor %s at %d,%d (slot: %d)",
				wlr_output->name, pos_x, pos_y, rtcfg->position);
		}
	}

	if (m->m.x == -1 && m->m.y == -1)
		wlr_output_layout_add_auto(output_layout, wlr_output);
	else
		wlr_output_layout_add(output_layout, wlr_output, m->m.x, m->m.y);

	wl_list_for_each(c, &clients, link) {
		if (c->output && strcmp(wlr_output->name, c->output) == 0)
			c->mon = m;
	}

	/* Initialize HDR and 10-bit color settings */
	init_monitor_color_settings(m);

	updatemons(NULL, NULL);
}

void
createnotify(struct wl_listener *listener, void *data)
{
	/* This event is raised when a client creates a new toplevel (application window). */
	struct wlr_xdg_toplevel *toplevel = data;
	Client *c = NULL;

	/* Allocate a Client for this surface */
	c = toplevel->base->data = ecalloc(1, sizeof(*c));
	c->surface.xdg = toplevel->base;
	c->bw = borderpx;

	LISTEN(&toplevel->base->surface->events.commit, &c->commit, commitnotify);
	LISTEN(&toplevel->base->surface->events.map, &c->map, mapnotify);
	LISTEN(&toplevel->base->surface->events.unmap, &c->unmap, unmapnotify);
	LISTEN(&toplevel->events.destroy, &c->destroy, destroynotify);
	LISTEN(&toplevel->events.request_fullscreen, &c->fullscreen, fullscreennotify);
	LISTEN(&toplevel->events.request_maximize, &c->maximize, maximizenotify);
	LISTEN(&toplevel->events.set_title, &c->set_title, updatetitle);
}

void
createpointer(struct wlr_pointer *pointer)
{
	struct libinput_device *device;
	if (wlr_input_device_is_libinput(&pointer->base)
			&& (device = wlr_libinput_get_device_handle(&pointer->base))) {

		if (libinput_device_config_tap_get_finger_count(device)) {
			libinput_device_config_tap_set_enabled(device, tap_to_click);
			libinput_device_config_tap_set_drag_enabled(device, tap_and_drag);
			libinput_device_config_tap_set_drag_lock_enabled(device, drag_lock);
			libinput_device_config_tap_set_button_map(device, button_map);
		}

		if (libinput_device_config_scroll_has_natural_scroll(device))
			libinput_device_config_scroll_set_natural_scroll_enabled(device, natural_scrolling);

		if (libinput_device_config_dwt_is_available(device))
			libinput_device_config_dwt_set_enabled(device, disable_while_typing);

		if (libinput_device_config_left_handed_is_available(device))
			libinput_device_config_left_handed_set(device, left_handed);

		if (libinput_device_config_middle_emulation_is_available(device))
			libinput_device_config_middle_emulation_set_enabled(device, middle_button_emulation);

		if (libinput_device_config_scroll_get_methods(device) != LIBINPUT_CONFIG_SCROLL_NO_SCROLL)
			libinput_device_config_scroll_set_method(device, scroll_method);

		if (libinput_device_config_click_get_methods(device) != LIBINPUT_CONFIG_CLICK_METHOD_NONE)
			libinput_device_config_click_set_method(device, click_method);

		if (libinput_device_config_send_events_get_modes(device))
			libinput_device_config_send_events_set_mode(device, send_events_mode);

		if (libinput_device_config_accel_is_available(device)) {
			libinput_device_config_accel_set_profile(device, accel_profile);
			libinput_device_config_accel_set_speed(device, accel_speed);
		}
	}

	wlr_cursor_attach_input_device(cursor, &pointer->base);
}

void
createpointerconstraint(struct wl_listener *listener, void *data)
{
	PointerConstraint *pointer_constraint = ecalloc(1, sizeof(*pointer_constraint));
	pointer_constraint->constraint = data;
	LISTEN(&pointer_constraint->constraint->events.destroy,
			&pointer_constraint->destroy, destroypointerconstraint);
}

void
createpopup(struct wl_listener *listener, void *data)
{
	/* This event is raised when a client (either xdg-shell or layer-shell)
	 * creates a new popup. */
	struct wlr_xdg_popup *popup = data;
	LISTEN_STATIC(&popup->base->surface->events.commit, commitpopup);
}

void
cursorconstrain(struct wlr_pointer_constraint_v1 *constraint)
{
	if (active_constraint == constraint)
		return;

	if (active_constraint)
		wlr_pointer_constraint_v1_send_deactivated(active_constraint);

	active_constraint = constraint;
	wlr_pointer_constraint_v1_send_activated(constraint);
}

void
cursorframe(struct wl_listener *listener, void *data)
{
	/* This event is forwarded by the cursor when a pointer emits a frame
	 * event. Frame events are sent after regular pointer events to group
	 * multiple events together. For instance, two axis events may happen at the
	 * same time, in which case a frame event won't be sent in between. */
	/* Notify the client with pointer focus of the frame event. */
	wlr_seat_pointer_notify_frame(seat);
}

void
cursorwarptohint(void)
{
	Client *c = NULL;
	double sx = active_constraint->current.cursor_hint.x;
	double sy = active_constraint->current.cursor_hint.y;

	toplevel_from_wlr_surface(active_constraint->surface, &c, NULL);
	if (c && active_constraint->current.cursor_hint.enabled) {
		wlr_cursor_warp(cursor, NULL, sx + c->geom.x + c->bw, sy + c->geom.y + c->bw);
		wlr_seat_pointer_warp(active_constraint->seat, sx, sy);
	}
}

void
destroydecoration(struct wl_listener *listener, void *data)
{
	Client *c = wl_container_of(listener, c, destroy_decoration);

	wl_list_remove(&c->destroy_decoration.link);
	wl_list_remove(&c->set_decoration_mode.link);
}

void
destroydragicon(struct wl_listener *listener, void *data)
{
	/* Focus enter isn't sent during drag, so refocus the focused node. */
	focusclient(focustop(selmon), 1);
	motionnotify(0, NULL, 0, 0, 0, 0);
	wl_list_remove(&listener->link);
	free(listener);
}

void
destroyidleinhibitor(struct wl_listener *listener, void *data)
{
	/* `data` is the wlr_surface of the idle inhibitor being destroyed,
	 * at this point the idle inhibitor is still in the list of the manager */
	checkidleinhibitor(wlr_surface_get_root_surface(data));
	wl_list_remove(&listener->link);
	free(listener);
}

void
destroylayersurfacenotify(struct wl_listener *listener, void *data)
{
	LayerSurface *l = wl_container_of(listener, l, destroy);

	wl_list_remove(&l->link);
	wl_list_remove(&l->destroy.link);
	wl_list_remove(&l->unmap.link);
	wl_list_remove(&l->surface_commit.link);
	wlr_scene_node_destroy(&l->scene->node);
	wlr_scene_node_destroy(&l->popups->node);
	free(l);
}

void
destroylock(SessionLock *lock, int unlock)
{
	wlr_seat_keyboard_notify_clear_focus(seat);
	if ((locked = !unlock))
		goto destroy;

	wlr_scene_node_set_enabled(&locked_bg->node, 0);

	focusclient(focustop(selmon), 0);
	motionnotify(0, NULL, 0, 0, 0, 0);

destroy:
	wl_list_remove(&lock->new_surface.link);
	wl_list_remove(&lock->unlock.link);
	wl_list_remove(&lock->destroy.link);

	wlr_scene_node_destroy(&lock->scene->node);
	cur_lock = NULL;
	free(lock);
}

void
destroylocksurface(struct wl_listener *listener, void *data)
{
	Monitor *m = wl_container_of(listener, m, destroy_lock_surface);
	struct wlr_session_lock_surface_v1 *surface, *lock_surface = m->lock_surface;

	m->lock_surface = NULL;
	wl_list_remove(&m->destroy_lock_surface.link);

	if (lock_surface->surface != seat->keyboard_state.focused_surface)
		return;

	if (locked && cur_lock && !wl_list_empty(&cur_lock->surfaces)) {
		surface = wl_container_of(cur_lock->surfaces.next, surface, link);
		client_notify_enter(surface->surface, wlr_seat_get_keyboard(seat));
	} else if (!locked) {
		focusclient(focustop(selmon), 1);
	} else {
		wlr_seat_keyboard_clear_focus(seat);
	}
}

void
destroynotify(struct wl_listener *listener, void *data)
{
	/* Called when the xdg_toplevel is destroyed. */
	Client *c = wl_container_of(listener, c, destroy);
	Monitor *m;
	wl_list_remove(&c->destroy.link);
	wl_list_remove(&c->set_title.link);
	wl_list_remove(&c->fullscreen.link);
	/* Remove client from all monitors' layout trees and rebalance */
	wl_list_for_each(m, &mons, link)
		remove_client(m, c);
#ifdef XWAYLAND
	if (c->type != XDGShell) {
		wl_list_remove(&c->activate.link);
		wl_list_remove(&c->associate.link);
		wl_list_remove(&c->configure.link);
		wl_list_remove(&c->minimize.link);
		wl_list_remove(&c->dissociate.link);
		wl_list_remove(&c->set_hints.link);
	} else
#endif
	{
		wl_list_remove(&c->commit.link);
		wl_list_remove(&c->map.link);
		wl_list_remove(&c->unmap.link);
		wl_list_remove(&c->maximize.link);
	}
	free(c);
}

void
destroypointerconstraint(struct wl_listener *listener, void *data)
{
	PointerConstraint *pointer_constraint = wl_container_of(listener, pointer_constraint, destroy);

	if (active_constraint == pointer_constraint->constraint) {
		cursorwarptohint();
		active_constraint = NULL;
	}

	wl_list_remove(&pointer_constraint->destroy.link);
	free(pointer_constraint);
}

void
destroysessionlock(struct wl_listener *listener, void *data)
{
	SessionLock *lock = wl_container_of(listener, lock, destroy);
	destroylock(lock, 0);
}

void
destroykeyboardgroup(struct wl_listener *listener, void *data)
{
	KeyboardGroup *group = wl_container_of(listener, group, destroy);
	wl_event_source_remove(group->key_repeat_source);
	wl_list_remove(&group->key.link);
	wl_list_remove(&group->modifiers.link);
	wl_list_remove(&group->destroy.link);
	wlr_keyboard_group_destroy(group->wlr_group);
	free(group);
}

Monitor *
dirtomon(enum wlr_direction dir)
{
	struct wlr_output *next;
	if (!wlr_output_layout_get(output_layout, selmon->wlr_output))
		return selmon;
	if ((next = wlr_output_layout_adjacent_output(output_layout,
			dir, selmon->wlr_output, selmon->m.x, selmon->m.y)))
		return next->data;
	if ((next = wlr_output_layout_farthest_output(output_layout,
			dir ^ (WLR_DIRECTION_LEFT|WLR_DIRECTION_RIGHT),
			selmon->wlr_output, selmon->m.x, selmon->m.y)))
		return next->data;
	return selmon;
}

void
focusclient(Client *c, int lift)
{
	struct wlr_surface *old = seat->keyboard_state.focused_surface;
	int unused_lx, unused_ly, old_client_type;
	Client *old_c = NULL;
	LayerSurface *old_l = NULL;

	if (locked)
		return;

	/* Warp cursor to center of client if it is outside */
	if (lift)
		warpcursor(c);

	/* Raise client in stacking order if requested */
	if (c && lift)
		wlr_scene_node_raise_to_top(&c->scene->node);

	if (c && client_surface(c) == old)
		return;

	if ((old_client_type = toplevel_from_wlr_surface(old, &old_c, &old_l)) == XDGShell) {
		struct wlr_xdg_popup *popup, *tmp;
		wl_list_for_each_safe(popup, tmp, &old_c->surface.xdg->popups, link)
			wlr_xdg_popup_destroy(popup);
	}

	/* Put the new client atop the focus stack and select its monitor */
	if (c && !client_is_unmanaged(c)) {
		wl_list_remove(&c->flink);
		wl_list_insert(&fstack, &c->flink);
		selmon = c->mon;
		c->isurgent = 0;

		/* Don't change border color if there is an exclusive focus or we are
		 * handling a drag operation */
		if (!exclusive_focus && !seat->drag)
			client_set_border_color(c, focuscolor);
	}

	/* Deactivate old client if focus is changing */
	if (old && (!c || client_surface(c) != old)) {
		/* If an overlay is focused, don't focus or activate the client,
		 * but only update its position in fstack to render its border with focuscolor
		 * and focus it after the overlay is closed. */
		if (old_client_type == LayerShell && wlr_scene_node_coords(
					&old_l->scene->node, &unused_lx, &unused_ly)
				&& old_l->layer_surface->current.layer >= ZWLR_LAYER_SHELL_V1_LAYER_TOP) {
			return;
		} else if (old_c && old_c == exclusive_focus && client_wants_focus(old_c)) {
			return;
		/* Don't deactivate old client if the new one wants focus, as this causes issues with winecfg
		 * and probably other clients */
		} else if (old_c && !client_is_unmanaged(old_c) && (!c || !client_wants_focus(c))) {
			client_set_border_color(old_c, bordercolor);

			client_activate_surface(old, 0);
		}
	}
	printstatus();

	if (!c) {
		/* With no client, all we have left is to clear focus */
		wlr_seat_keyboard_notify_clear_focus(seat);
		/* Notify text inputs about focus loss */
		text_input_focus_change(old, NULL);
		/* Hide cursor if HTPC views are visible */
		if (selmon && (selmon->pc_gaming.visible ||
		               selmon->movies_view.visible ||
		               selmon->tvshows_view.visible))
			wlr_cursor_set_surface(cursor, NULL, 0, 0);
		return;
	}

	/* Change cursor surface */
	motionnotify(0, NULL, 0, 0, 0, 0);

	/* Have a client, so focus its top-level wlr_surface */
	struct wlr_keyboard *kb = wlr_seat_get_keyboard(seat);
	wlr_log(WLR_INFO, "focusclient: giving keyboard focus to '%s', keyboard=%p",
		client_get_appid(c) ? client_get_appid(c) : "(null)", (void*)kb);
	client_notify_enter(client_surface(c), kb);

	/* Notify text inputs about focus change */
	text_input_focus_change(old, client_surface(c));

	/* Activate the new client */
	client_activate_surface(client_surface(c), 1);

	/* Update gamepad grab state - release for Steam/games, grab for HTPC views */
	gamepad_update_grab_state();
}

void
focusmon(const Arg *arg)
{
	int i = 0, nmons = wl_list_length(&mons);
	if (nmons) {
		do /* don't switch to disabled mons */
			selmon = dirtomon(arg->i);
		while (!selmon->wlr_output->enabled && i++ < nmons);
	}
	focusclient(focustop(selmon), 1);
}

/* Warp cursor to center of monitor in specified direction */
void
warptomonitor(const Arg *arg)
{
	Monitor *m;
	int i = 0, nmons = wl_list_length(&mons);

	if (!nmons)
		return;

	m = selmon;
	do
		m = dirtomon(arg->i);
	while (!m->wlr_output->enabled && i++ < nmons);

	if (m && m->wlr_output->enabled) {
		/* Transfer any open status menus to new monitor */
		transfer_status_menus(selmon, m);
		selmon = m;
		/* Warp cursor to center of monitor */
		wlr_cursor_warp(cursor, NULL,
			m->m.x + m->m.width / 2,
			m->m.y + m->m.height / 2);
		focusclient(focustop(selmon), 1);
	}
}

/* Get monitor by index (0-based) */
static Monitor *
monitorbyindex(unsigned int idx)
{
	Monitor *m;
	unsigned int i = 0;

	wl_list_for_each(m, &mons, link) {
		if (i == idx)
			return m;
		i++;
	}
	return NULL;
}

/* Move focused client to monitor by index */
void
tagtomonitornum(const Arg *arg)
{
	Client *sel = focustop(selmon);
	Monitor *target;

	if (!sel)
		return;

	target = monitorbyindex(arg->ui);
	if (!target || target == sel->mon)
		return;

	setmon(sel, target, 0);
	free(sel->output);
	if (!(sel->output = strdup(sel->mon->wlr_output->name)))
		die("oom");
}

void
focusstack(const Arg *arg)
{
	/* Focus the next or previous client (in tiling order) on selmon */
	Client *c, *sel = focustop(selmon);
	if (!sel || (sel->isfullscreen && !client_has_children(sel)))
		return;
	if (arg->i > 0) {
		wl_list_for_each(c, &sel->link, link) {
			if (&c->link == &clients)
				continue; /* wrap past the sentinel node */
			if (VISIBLEON(c, selmon))
				break; /* found it */
		}
	} else {
		wl_list_for_each_reverse(c, &sel->link, link) {
			if (&c->link == &clients)
				continue; /* wrap past the sentinel node */
			if (VISIBLEON(c, selmon))
				break; /* found it */
		}
	}
	/* If only one client is visible on selmon, then c == sel */
	focusclient(c, 1);
}

/* We probably should change the name of this: it sounds like it
 * will focus the topmost client of this mon, when actually will
 * only return that client */
Client *
focustop(Monitor *m)
{
	Client *c;
	wl_list_for_each(c, &fstack, flink) {
		if (VISIBLEON(c, m))
			return c;
	}
	return NULL;
}

void
fullscreennotify(struct wl_listener *listener, void *data)
{
	Client *c = wl_container_of(listener, c, fullscreen);
	setfullscreen(c, client_wants_fullscreen(c));
}

void
gpureset(struct wl_listener *listener, void *data)
{
	struct wlr_renderer *old_drw = drw;
	struct wlr_allocator *old_alloc = alloc;
	struct Monitor *m;
	if (!(drw = wlr_renderer_autocreate(backend)))
		die("couldn't recreate renderer");

	if (!(alloc = wlr_allocator_autocreate(backend, drw)))
		die("couldn't recreate allocator");

	wl_list_remove(&gpu_reset.link);
	wl_signal_add(&drw->events.lost, &gpu_reset);

	wlr_compositor_set_renderer(compositor, drw);

	wl_list_for_each(m, &mons, link) {
		wlr_output_init_render(m->wlr_output, alloc, drw);
	}

	wlr_allocator_destroy(old_alloc);
	wlr_renderer_destroy(old_drw);
}

void
handlesig(int signo)
{
	if (signo == SIGCHLD) {
		while (waitpid(-1, NULL, WNOHANG) > 0);
	} else if (signo == SIGINT) {
		write(STDERR_FILENO, "handlesig: SIGINT received, quitting\n", 37);
		quit(NULL);
	} else if (signo == SIGTERM) {
		write(STDERR_FILENO, "handlesig: SIGTERM received, quitting\n", 38);
		quit(NULL);
	} else if (signo == SIGPIPE) {
		write(STDERR_FILENO, "handlesig: SIGPIPE received (ignored)\n", 38);
	}
}

void
incnmaster(const Arg *arg)
{
	if (!arg || !selmon)
		return;
	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
	arrange(selmon);
}

void
inputdevice(struct wl_listener *listener, void *data)
{
	/* This event is raised by the backend when a new input device becomes
	 * available. */
	struct wlr_input_device *device = data;
	uint32_t caps;

	switch (device->type) {
	case WLR_INPUT_DEVICE_KEYBOARD:
		createkeyboard(wlr_keyboard_from_input_device(device));
		break;
	case WLR_INPUT_DEVICE_POINTER:
		createpointer(wlr_pointer_from_input_device(device));
		break;
	default:
		/* TODO handle other input device types */
		break;
	}

	/* We need to let the wlr_seat know what our capabilities are, which is
	 * communiciated to the client. In dwl we always have a cursor, even if
	 * there are no pointer devices, so we always include that capability. */
	/* TODO do we actually require a cursor? */
	caps = WL_SEAT_CAPABILITY_POINTER;
	if (!wl_list_empty(&kb_group->wlr_group->devices))
		caps |= WL_SEAT_CAPABILITY_KEYBOARD;
	wlr_seat_set_capabilities(seat, caps);
}

int
keybinding(uint32_t mods, xkb_keysym_t sym)
{
	/*
	 * Here we handle compositor keybindings. This is when the compositor is
	 * processing keys, rather than passing them on to the client for its own
	 * processing.
	 */
	size_t i;
	for (i = 0; i < keys_count; i++) {
		const Key *k = &keys[i];
		if (CLEANMASK(mods) == CLEANMASK(k->mod)
				&& sym == k->keysym && k->func) {
			k->func(&k->arg);
			return 1;
		}
	}
	return 0;
}

void
keypress(struct wl_listener *listener, void *data)
{
	int i;
	/* This event is raised when a key is pressed or released. */
	KeyboardGroup *group = wl_container_of(listener, group, key);
	struct wlr_keyboard_key_event *event = data;

	/*
	 * Track input timestamp for latency measurement.
	 * This helps measure input-to-photon latency in games.
	 */
	if (game_mode_ultra && selmon) {
		selmon->last_input_ns = get_time_ns();
	}

	/* Translate libinput keycode -> xkbcommon */
	uint32_t keycode = event->keycode + 8;
	/* Get a list of keysyms based on the keymap for this keyboard */
	const xkb_keysym_t *syms;
	int nsyms = xkb_state_key_get_syms(
			group->wlr_group->keyboard.xkb_state, keycode, &syms);
	/* Also get the base keysym (level 0, no modifiers applied) for shifted bindings */
	xkb_keysym_t base_sym = xkb_state_key_get_one_sym(
			group->wlr_group->keyboard.xkb_state, keycode);
	struct xkb_keymap *keymap = group->wlr_group->keyboard.keymap;
	xkb_layout_index_t layout = xkb_state_key_get_layout(
			group->wlr_group->keyboard.xkb_state, keycode);
	const xkb_keysym_t *level0_syms;
	int nlevel0 = xkb_keymap_key_get_syms_by_level(keymap, keycode, layout, 0, &level0_syms);

	int handled = 0;
	uint32_t mods = wlr_keyboard_get_modifiers(&group->wlr_group->keyboard);
	Monitor *modal_mon = modal_visible_monitor();
	Monitor *nixpkgs_mon = nixpkgs_visible_monitor();
	Monitor *wifi_mon = wifi_popup_visible_monitor();
	Monitor *sudo_mon = sudo_popup_visible_monitor();
	Monitor *pc_gaming_mon = pc_gaming_visible_monitor();
	Monitor *stats_mon = stats_panel_visible_monitor();

	wlr_idle_notifier_v1_notify_activity(idle_notifier, seat);

	/* On _press_ if there is no active screen locker,
	 * attempt to process a compositor keybinding. */
	if (!locked && event->state == WL_KEYBOARD_KEY_STATE_PRESSED) {
		/* Sudo password popup takes highest priority */
		if (sudo_mon) {
			for (i = 0; i < nsyms; i++) {
				if (sudo_popup_handle_key(sudo_mon, mods, syms[i]))
					handled = 1;
			}
		}
		/* WiFi password popup */
		if (wifi_mon && !handled) {
			for (i = 0; i < nsyms; i++) {
				if (wifi_popup_handle_key(wifi_mon, mods, syms[i]))
					handled = 1;
			}
		}
		/* Stats panel - handle before PC gaming so it can be used in-game */
		if (stats_mon && !handled) {
			for (i = 0; i < nsyms; i++) {
				if (stats_panel_handle_key(stats_mon, syms[i]))
					handled = 1;
			}
		}
		/* PC Gaming view */
		if (pc_gaming_mon && !handled) {
			for (i = 0; i < nsyms; i++) {
				if (pc_gaming_handle_key(pc_gaming_mon, mods, syms[i]))
					handled = 1;
			}
		}
		/* Media views (Movies/TV-shows) */
		if (!handled) {
			Monitor *media_mon = media_view_visible_monitor();
			if (media_mon) {
				for (i = 0; i < nsyms; i++) {
					/* Check which view is active */
					if (htpc_view_is_active(media_mon, media_mon->movies_view.view_tag, media_mon->movies_view.visible)) {
						if (media_view_handle_key(media_mon, MEDIA_VIEW_MOVIES, syms[i]))
							handled = 1;
					} else if (htpc_view_is_active(media_mon, media_mon->tvshows_view.view_tag, media_mon->tvshows_view.visible)) {
						if (media_view_handle_key(media_mon, MEDIA_VIEW_TVSHOWS, syms[i]))
							handled = 1;
					}
				}
			}
		}
		/* Nixpkgs popup */
		if (nixpkgs_mon && !handled) {
			int consumed = 0;
			int is_navigation = 0;
			for (i = 0; i < nsyms; i++) {
				xkb_keysym_t s = syms[i];
				if (nixpkgs_handle_key(nixpkgs_mon, mods, s)) {
					handled = 1;
					consumed = 1;
				}
				if (s == XKB_KEY_Up || s == XKB_KEY_Down)
					is_navigation = 1;
			}
			if (consumed) {
				if (is_navigation) {
					nixpkgs_update_selection(nixpkgs_mon);
				} else {
					nixpkgs_update_results(nixpkgs_mon);
					nixpkgs_render(nixpkgs_mon);
				}
			}
		}
		if (modal_mon) {
			int consumed = 0;
			int is_text_input = 0;
			for (i = 0; i < nsyms; i++) {
				xkb_keysym_t s = syms[i];
				/* Check if this is a text input key (printable or backspace) */
				if ((s >= 0x20 && s <= 0x7e) || s == XKB_KEY_BackSpace)
					is_text_input = 1;
				if (modal_handle_key(modal_mon, mods, s)) {
					handled = 1;
					consumed = 1;
				}
			}
			if (consumed) {
				int is_file_search = (modal_mon->modal.active_idx == 1);
				int is_navigation = 0;
				for (i = 0; i < nsyms; i++) {
					if (syms[i] == XKB_KEY_Up || syms[i] == XKB_KEY_Down) {
						is_navigation = 1;
						break;
					}
				}
				if (is_navigation) {
					/* Navigation keys: ultra-fast highlight toggle only */
					modal_update_selection(modal_mon);
				} else if (is_text_input && is_file_search) {
					/* File search: show text immediately, delay search 300ms */
					modal_render_search_field(modal_mon);
					/* Schedule search + full render after 300ms */
					if (!modal_mon->modal.render_timer)
						modal_mon->modal.render_timer = wl_event_loop_add_timer(
							event_loop, modal_render_timer_cb, modal_mon);
					modal_mon->modal.render_pending = 1;
					wl_event_source_timer_update(modal_mon->modal.render_timer, 300);
				} else {
					/* App launcher, git-projects, text input: full update */
					modal_update_results(modal_mon);
					modal_render(modal_mon);
				}
			}
		}
		if (!handled) {
			for (i = 0; i < nsyms; i++)
				handled = keybinding(mods, syms[i]) || handled;
		}
		/* If no binding matched, try with base keysyms (level 0) for shifted bindings */
		if (!handled && nlevel0 > 0) {
			for (i = 0; i < nlevel0; i++)
				handled = keybinding(mods, level0_syms[i]) || handled;
		}
	}

	/* Don't enable key repeat for modal/nixpkgs text input to avoid double characters.
	 * Only allow repeat for navigation keys (arrows, backspace) in modal/nixpkgs. */
	{
		int allow_repeat = 0;
		if (handled && group->wlr_group->keyboard.repeat_info.delay > 0) {
			if (!modal_mon && !nixpkgs_mon) {
				allow_repeat = 1;
			} else {
				/* In modal/nixpkgs: only allow repeat for navigation keys */
				for (i = 0; i < nsyms; i++) {
					xkb_keysym_t s = syms[i];
					if (s == XKB_KEY_Up || s == XKB_KEY_Down ||
					    s == XKB_KEY_BackSpace) {
						allow_repeat = 1;
						break;
					}
				}
			}
		}
		if (allow_repeat) {
			group->mods = mods;
			group->keysyms = syms;
			group->nsyms = nsyms;
			wl_event_source_timer_update(group->key_repeat_source,
					group->wlr_group->keyboard.repeat_info.delay);
		} else {
			group->nsyms = 0;
			wl_event_source_timer_update(group->key_repeat_source, 0);
		}
	}

	if (handled)
		return;

	wlr_seat_set_keyboard(seat, &group->wlr_group->keyboard);
	/* Pass unhandled keycodes along to the client. */
	if (event->state == WL_KEYBOARD_KEY_STATE_PRESSED) {
		struct wlr_surface *focused = seat->keyboard_state.focused_surface;
		wlr_log(WLR_DEBUG, "keypress: forwarding key %d to client, focused_surface=%p",
			event->keycode, (void*)focused);
	}
	wlr_seat_keyboard_notify_key(seat, event->time_msec,
			event->keycode, event->state);
}

void
keypressmod(struct wl_listener *listener, void *data)
{
	/* This event is raised when a modifier key, such as shift or alt, is
	 * pressed. We simply communicate this to the client. */
	KeyboardGroup *group = wl_container_of(listener, group, modifiers);

	wlr_seat_set_keyboard(seat, &group->wlr_group->keyboard);
	/* Send modifiers to the client. */
	wlr_seat_keyboard_notify_modifiers(seat,
			&group->wlr_group->keyboard.modifiers);
}

int
keyrepeat(void *data)
{
	KeyboardGroup *group = data;
	Monitor *modal_mon = modal_visible_monitor();
	Monitor *nixpkgs_mon = nixpkgs_visible_monitor();
	int modal_consumed = 0;
	int nixpkgs_consumed = 0;
	int i;
	if (!group->nsyms || group->wlr_group->keyboard.repeat_info.rate <= 0)
		return 0;

	wl_event_source_timer_update(group->key_repeat_source,
			1000 / group->wlr_group->keyboard.repeat_info.rate);

	for (i = 0; i < group->nsyms; i++) {
		if (nixpkgs_mon && nixpkgs_handle_key(nixpkgs_mon, group->mods, group->keysyms[i]))
			nixpkgs_consumed = 1;
		else if (modal_mon && modal_handle_key(modal_mon, group->mods, group->keysyms[i]))
			modal_consumed = 1;
		else
			keybinding(group->mods, group->keysyms[i]);
	}

	if (nixpkgs_consumed && nixpkgs_mon) {
		/* Check if this is navigation - use fast path */
		int is_nav = 0;
		for (i = 0; i < group->nsyms; i++) {
			if (group->keysyms[i] == XKB_KEY_Up || group->keysyms[i] == XKB_KEY_Down) {
				is_nav = 1;
				break;
			}
		}
		if (is_nav) {
			/* Ultra-fast: just toggle highlights */
			nixpkgs_update_selection(nixpkgs_mon);
		} else {
			/* Other keys (backspace): full update */
			nixpkgs_update_results(nixpkgs_mon);
			nixpkgs_render(nixpkgs_mon);
		}
	}

	if (modal_consumed && modal_mon) {
		/* Check if this is navigation - use fast path */
		int is_nav = 0;
		for (i = 0; i < group->nsyms; i++) {
			if (group->keysyms[i] == XKB_KEY_Up || group->keysyms[i] == XKB_KEY_Down) {
				is_nav = 1;
				break;
			}
		}
		if (is_nav) {
			/* Ultra-fast: just toggle highlights */
			modal_update_selection(modal_mon);
		} else {
			/* Other keys (backspace): full update */
			modal_update_results(modal_mon);
			modal_render(modal_mon);
		}
	}

	return 0;
}

void
killclient(const Arg *arg)
{
	Client *sel = focustop(selmon);
	if (sel)
		client_send_close(sel);
}

void
locksession(struct wl_listener *listener, void *data)
{
	struct wlr_session_lock_v1 *session_lock = data;
	SessionLock *lock;
	wlr_scene_node_set_enabled(&locked_bg->node, 1);
	if (cur_lock) {
		wlr_session_lock_v1_destroy(session_lock);
		return;
	}
	lock = session_lock->data = ecalloc(1, sizeof(*lock));
	focusclient(NULL, 0);

	lock->scene = wlr_scene_tree_create(layers[LyrBlock]);
	cur_lock = lock->lock = session_lock;
	locked = 1;

	LISTEN(&session_lock->events.new_surface, &lock->new_surface, createlocksurface);
	LISTEN(&session_lock->events.destroy, &lock->destroy, destroysessionlock);
	LISTEN(&session_lock->events.unlock, &lock->unlock, unlocksession);

	wlr_session_lock_v1_send_locked(session_lock);
}

void
mapnotify(struct wl_listener *listener, void *data)
{
	/* Called when the surface is mapped, or ready to display on-screen. */
	Client *p = NULL;
	Client *w, *c = wl_container_of(listener, c, map);
	Monitor *m;
	int i;

	/* Create scene tree for this client and its border */
	c->scene = client_surface(c)->data = wlr_scene_tree_create(layers[LyrTile]);
	/* Enabled later by a call to arrange() */
	wlr_scene_node_set_enabled(&c->scene->node, client_is_unmanaged(c));
	c->scene_surface = c->type == XDGShell
			? wlr_scene_xdg_surface_create(c->scene, c->surface.xdg)
			: wlr_scene_subsurface_tree_create(c->scene, client_surface(c));
	c->scene->node.data = c->scene_surface->node.data = c;

	client_get_geometry(c, &c->geom);

	/* Handle unmanaged clients first so we can return prior create borders */
	if (client_is_unmanaged(c)) {
		/* Unmanaged clients always are floating */
		wlr_scene_node_reparent(&c->scene->node, layers[LyrFloat]);
		wlr_scene_node_set_position(&c->scene->node, c->geom.x, c->geom.y);
		client_set_size(c, c->geom.width, c->geom.height);
		if (client_wants_focus(c)) {
			wlr_log(WLR_INFO, "mapnotify: unmanaged client wants focus, setting exclusive_focus");
			focusclient(c, 1);
			exclusive_focus = c;
		} else {
			wlr_log(WLR_INFO, "mapnotify: unmanaged client mapped but doesn't want focus");
		}
		goto unset_fullscreen;
	}

	for (i = 0; i < 4; i++) {
		c->border[i] = wlr_scene_rect_create(c->scene, 0, 0,
				c->isurgent ? urgentcolor : bordercolor);
		c->border[i]->node.data = c;
	}

	/* Initialize client geometry with room for border */
	client_set_tiled(c, WLR_EDGE_TOP | WLR_EDGE_BOTTOM | WLR_EDGE_LEFT | WLR_EDGE_RIGHT);
	c->geom.width += 2 * c->bw;
	c->geom.height += 2 * c->bw;

	/* Insert this client into client lists. */
	wl_list_insert(&clients, &c->link);
	wl_list_insert(&fstack, &c->flink);

	/* Debug: log client app_id */
	if (c->type == XDGShell && c->surface.xdg && c->surface.xdg->toplevel) {
		const char *aid = c->surface.xdg->toplevel->app_id;
		wlr_log(WLR_INFO, "mapnotify: XDG client mapped, app_id='%s'", aid ? aid : "(null)");
	}
#ifdef XWAYLAND
	if (c->type == X11 && c->surface.xwayland) {
		const char *cls = c->surface.xwayland->class;
		wlr_log(WLR_INFO, "mapnotify: X11 client mapped, class='%s'", cls ? cls : "(null)");
	}
#endif

	/* Set initial monitor, tags, floating status, and focus:
	 * we always consider floating, clients that have parent and thus
	 * we set the same tags and monitor as its parent.
	 * If there is no parent, apply rules */
	if ((p = client_get_parent(c))) {
		c->isfloating = 1;
		if (tray_anchor_time_ms && monotonic_msec() - tray_anchor_time_ms <= 1000) {
			c->geom.x = tray_anchor_x - c->geom.width / 2;
			c->geom.y = tray_anchor_y;
		} else if (p->mon) {
			c->geom.x = (p->mon->w.width - c->geom.width) / 2 + p->mon->m.x;
			c->geom.y = (p->mon->w.height - c->geom.height) / 2 + p->mon->m.y;
		}
		setmon(c, p->mon, p->tags);
	} else {
		applyrules(c);
		if (tray_anchor_time_ms && monotonic_msec() - tray_anchor_time_ms <= 1000) {
			Monitor *am = xytomon(tray_anchor_x, tray_anchor_y);
			if (!am)
				am = selmon;
			if (am) {
				c->isfloating = 1;
				c->geom.x = tray_anchor_x - c->geom.width / 2;
				c->geom.y = tray_anchor_y;
				setmon(c, am, c->tags);
			}
		}
	}
	free(c->output);
	c->output = strdup(c->mon->wlr_output->name);
	if (c->output == NULL)
		die("oom");

	/*
	 * HTPC mode Steam handling:
	 * - Force Steam main window to fullscreen on tag 4
	 * - Steam popups/dialogs stay floating but get focus and raised to top
	 */
	if (htpc_mode_active) {
		if (is_steam_client(c) && !c->isfloating) {
			/* Steam main window - place on tag 4 and fullscreen */
			wlr_log(WLR_INFO, "HTPC: Placing Steam on tag 4 and fullscreen");
			c->tags = 1 << 3; /* Tag 4 = bit 3 */
			setfullscreen(c, 1);
		} else if (is_steam_popup(c) || (p && is_steam_popup(p))) {
			/* Steam popup/dialog - ensure it's floating, centered, and focused */
			c->isfloating = 1;
			if (c->mon) {
				c->geom.x = (c->mon->w.width - c->geom.width) / 2 + c->mon->m.x;
				c->geom.y = (c->mon->w.height - c->geom.height) / 2 + c->mon->m.y;
			}
			/* Raise to top and focus */
			wlr_scene_node_raise_to_top(&c->scene->node);
			focusclient(c, 1);
			wlr_log(WLR_INFO, "HTPC: Steam popup raised and focused");
			/* Show cursor for popup interaction */
			wlr_cursor_set_xcursor(cursor, cursor_mgr, "default");
		}
	}

	/*
	 * AUTO-FULLSCREEN FOR GAMES
	 *
	 * Steam games often start in windowed mode and then request fullscreen
	 * after a delay (sometimes several seconds). This causes an annoying
	 * flash where the game appears windowed before going fullscreen.
	 *
	 * To fix this, we detect games at map time and immediately set them
	 * to fullscreen, skipping the windowed phase entirely.
	 *
	 * Detection criteria:
	 * - Client is a child process of Steam (game launcher)
	 * - Client uses content-type=game protocol hint
	 * - Client requests tearing (low-latency mode used by games)
	 */
	if (!c->isfloating && !c->isfullscreen && looks_like_game(c)) {
		wlr_log(WLR_INFO, "Auto-fullscreen: detected game '%s', setting fullscreen immediately",
			client_get_appid(c) ? client_get_appid(c) : "(unknown)");
		setfullscreen(c, 1);
		/* Immediately focus the game */
		exclusive_focus = NULL;
		focusclient(c, 1);
		/*
		 * Schedule a delayed refocus for XWayland games.
		 * Wine/Proton games often need extra time after mapping before
		 * they properly accept keyboard input. Without this, users
		 * can't skip intros until they switch tags and back.
		 */
#ifdef XWAYLAND
		if (c->type == X11)
			schedule_game_refocus(c, 150);
#endif
		printstatus();
		return; /* Skip unset_fullscreen logic - we just set fullscreen */
	}

	printstatus();

unset_fullscreen:
	m = c->mon ? c->mon : xytomon(c->geom.x, c->geom.y);
	/* In HTPC mode, don't unset fullscreen for Steam popups appearing */
	if (htpc_mode_active && (is_steam_popup(c) || (p && is_steam_client(p))))
		return;
	wl_list_for_each(w, &clients, link) {
		if (w != c && w != p && w->isfullscreen && m == w->mon && (w->tags & c->tags))
			setfullscreen(w, 0);
	}
}

void
maximizenotify(struct wl_listener *listener, void *data)
{
	/* This event is raised when a client would like to maximize itself,
	 * typically because the user clicked on the maximize button on
	 * client-side decorations. dwl doesn't support maximization, but
	 * to conform to xdg-shell protocol we still must send a configure.
	 * Since xdg-shell protocol v5 we should ignore request of unsupported
	 * capabilities, just schedule a empty configure when the client uses <5
	 * protocol version
	 * wlr_xdg_surface_schedule_configure() is used to send an empty reply. */
	Client *c = wl_container_of(listener, c, maximize);
	if (c->surface.xdg->initialized
			&& wl_resource_get_version(c->surface.xdg->toplevel->resource)
					< XDG_TOPLEVEL_WM_CAPABILITIES_SINCE_VERSION)
		wlr_xdg_surface_schedule_configure(c->surface.xdg);
}

void
monocle(Monitor *m)
{
	Client *c;
	int n = 0;

	wl_list_for_each(c, &clients, link) {
		if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
			continue;
		resize(c, m->w, 0);
		n++;
	}
	if (n)
		snprintf(m->ltsymbol, LENGTH(m->ltsymbol), "[%d]", n);
	if ((c = focustop(m)))
		wlr_scene_node_raise_to_top(&c->scene->node);
}

void
motionabsolute(struct wl_listener *listener, void *data)
{
	/* This event is forwarded by the cursor when a pointer emits an _absolute_
	 * motion event, from 0..1 on each axis. This happens, for example, when
	 * wlroots is running under a Wayland window rather than KMS+DRM, and you
	 * move the mouse over the window. You could enter the window from any edge,
	 * so we have to warp the mouse there. Also, some hardware emits these events. */
	struct wlr_pointer_motion_absolute_event *event = data;
	double lx, ly, dx, dy;

	if (!event->time_msec) /* this is 0 with virtual pointers */
		wlr_cursor_warp_absolute(cursor, &event->pointer->base, event->x, event->y);

	wlr_cursor_absolute_to_layout_coords(cursor, &event->pointer->base, event->x, event->y, &lx, &ly);
	dx = lx - cursor->x;
	dy = ly - cursor->y;
	last_pointer_motion_ms = monotonic_msec();
	motionnotify(event->time_msec, &event->pointer->base, dx, dy, dx, dy);
}

static int __attribute__((unused))
node_contains_client(LayoutNode *node, Client *c)
{
	if (!node)
		return 0;
	if (node->is_client_node)
		return node->client == c;
	return node_contains_client(node->left, c) || node_contains_client(node->right, c);
}

static int
subtree_bounds(LayoutNode *node, Monitor *m, struct wlr_box *out)
{
	struct wlr_box lbox, rbox;
	int hasl, hasr, right, bottom;
	struct wlr_box tmp;

	if (!out)
		out = &tmp;
	if (!node)
		return 0;
	if (node->is_client_node) {
		Client *c = node->client;
		if (!c || !VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
			return 0;
		*out = c->geom;
		return 1;
	}

	hasl = subtree_bounds(node->left, m, &lbox);
	hasr = subtree_bounds(node->right, m, &rbox);
	if (!hasl && !hasr)
		return 0;
	if (hasl && !hasr) {
		*out = lbox;
		return 1;
	}
	if (!hasl && hasr) {
		*out = rbox;
		return 1;
	}

	out->x = MIN(lbox.x, rbox.x);
	out->y = MIN(lbox.y, rbox.y);
	right = MAX(lbox.x + lbox.width, rbox.x + rbox.width);
	bottom = MAX(lbox.y + lbox.height, rbox.y + rbox.height);
	out->width = right - out->x;
	out->height = bottom - out->y;
	return 1;
}

static __attribute__((unused)) LayoutNode *
ancestor_split(LayoutNode *node, int want_vert)
{
	if (!node)
		return NULL;
	node = node->split_node;
	while (node) {
		if (!node->is_client_node && node->is_split_vertically == (unsigned int)want_vert)
			return node;
		node = node->split_node;
	}
	return NULL;
}

static LayoutNode *
closest_split_node(LayoutNode *client_node, int want_vert, double pointer,
		double *out_ratio, struct wlr_box *out_box, double *out_dist)
{
	LayoutNode *n = client_node ? client_node->split_node : NULL;
	LayoutNode *best = NULL;
	double best_dist = HUGE_VAL;
	struct wlr_box box;

	while (n) {
		if (!n->is_client_node && n->is_split_vertically == (unsigned int)want_vert) {
			if (subtree_bounds(n, selmon, &box)) {
				double ratio = n->split_ratio;
				double div = want_vert ? box.x + box.width * ratio
						: box.y + box.height * ratio;
				double dist = fabs(pointer - div);

				if (dist < best_dist) {
					best_dist = dist;
					best = n;
					if (out_ratio)
						*out_ratio = ratio;
					if (out_box)
						*out_box = box;
				}
			}
		}
		n = n->split_node;
	}

	if (out_dist)
		*out_dist = best ? best_dist : HUGE_VAL;
	return best;
}

static void
apply_resize_axis_choice(void)
{
	resize_use_v = resize_split_node != NULL;
	resize_use_h = resize_split_node_h != NULL;
}

static int
resize_should_update(uint32_t time)
{
	uint32_t elapsed;
	double dist;

	if (!resizing_from_mouse || time == 0 || resize_interval_ms == 0)
		return 1;

	if (resize_last_time == 0) {
		resize_last_time = time;
		resize_last_x = cursor->x;
		resize_last_y = cursor->y;
		return 1;
	}

	elapsed = time - resize_last_time;
	dist = fabs(cursor->x - resize_last_x) + fabs(cursor->y - resize_last_y);

	if (elapsed < resize_interval_ms && dist < resize_min_pixels)
		return 0;

	resize_last_time = time;
	resize_last_x = cursor->x;
	resize_last_y = cursor->y;
	return 1;
}

static const char *
resize_cursor_from_dirs(int dx, int dy)
{
	if (dx == 0 && dy == -1)
		return "n-resize";
	if (dx == 0 && dy == 1)
		return "s-resize";
	if (dx == -1 && dy == 0)
		return "w-resize";
	if (dx == 1 && dy == 0)
		return "e-resize";
	if (dx == -1 && dy == -1)
		return "nw-resize";
	if (dx == 1 && dy == -1)
		return "ne-resize";
	if (dx == -1 && dy == 1)
		return "sw-resize";
	if (dx == 1 && dy == 1)
		return "se-resize";
	return "default";
}

static const char *
pick_resize_handle(const Client *c, double cx, double cy)
{
	double left = cx - c->geom.x;
	double right = c->geom.x + c->geom.width - cx;
	double top = cy - c->geom.y;
	double bottom = c->geom.y + c->geom.height - cy;
	double corner_thresh = MIN(24.0, MIN(c->geom.width, c->geom.height) / 3.0);
	int hx = (left <= right) ? -1 : 1;
	int hy = (top <= bottom) ? -1 : 1;

	resize_dir_x = 0;
	resize_dir_y = 0;
	resize_use_v = resize_use_h = 0;

	if (MIN(left, right) <= corner_thresh && MIN(top, bottom) <= corner_thresh) {
		/* Close to a corner: resize both axes. */
		resize_dir_x = hx;
		resize_dir_y = hy;
	} else {
		if (MIN(left, right) <= corner_thresh)
			resize_dir_x = hx;
		if (MIN(top, bottom) <= corner_thresh)
			resize_dir_y = hy;
		if (!resize_dir_x && !resize_dir_y) {
			/* Otherwise pick the nearest axis so resize still happens. */
			if (MIN(left, right) <= MIN(top, bottom))
				resize_dir_x = hx;
			else
				resize_dir_y = hy;
		}
	}

	return resize_cursor_from_dirs(resize_dir_x, resize_dir_y);
}

void
motionnotify(uint32_t time, struct wlr_input_device *device, double dx, double dy,
		double dx_unaccel, double dy_unaccel)
{
	int tiled = 0;
	double sx = 0, sy = 0, sx_confined, sy_confined;
	Client *c = NULL, *w = NULL;
	LayerSurface *l = NULL;
	struct wlr_surface *surface = NULL;
	struct wlr_pointer_constraint_v1 *constraint;

	/*
	 * Track input timestamp for mouse motion latency measurement.
	 * Mouse input is most critical for competitive gaming.
	 */
	if (game_mode_ultra && selmon && time > 0) {
		selmon->last_input_ns = get_time_ns();
	}

	/* Find the client under the pointer and send the event along. */
	xytonode(cursor->x, cursor->y, &surface, &c, NULL, &sx, &sy);

	if (cursor_mode == CurPressed && !seat->drag
			&& surface != seat->pointer_state.focused_surface
			&& toplevel_from_wlr_surface(seat->pointer_state.focused_surface, &w, &l) >= 0) {
		c = w;
		surface = seat->pointer_state.focused_surface;
		sx = cursor->x - (l ? l->scene->node.x : w->geom.x);
		sy = cursor->y - (l ? l->scene->node.y : w->geom.y);
	}

	/* time is 0 in internal calls meant to restore pointer focus. */
	if (time) {
		wlr_relative_pointer_manager_v1_send_relative_motion(
				relative_pointer_mgr, seat, (uint64_t)time * 1000,
				dx, dy, dx_unaccel, dy_unaccel);

		wl_list_for_each(constraint, &pointer_constraints->constraints, link)
			cursorconstrain(constraint);

		if (active_constraint && cursor_mode != CurResize && cursor_mode != CurMove) {
			toplevel_from_wlr_surface(active_constraint->surface, &c, NULL);
			if (c && active_constraint->surface == seat->pointer_state.focused_surface) {
				sx = cursor->x - c->geom.x - c->bw;
				sy = cursor->y - c->geom.y - c->bw;
				if (wlr_region_confine(&active_constraint->region, sx, sy,
						sx + dx, sy + dy, &sx_confined, &sy_confined)) {
					dx = sx_confined - sx;
					dy = sy_confined - sy;
				}

				if (active_constraint->type == WLR_POINTER_CONSTRAINT_V1_LOCKED)
					return;
			}
		}

		wlr_cursor_move(cursor, device, dx, dy);
		wlr_idle_notifier_v1_notify_activity(idle_notifier, seat);

		/* Update selmon (even while dragging a window) */
		if (sloppyfocus) {
			Monitor *newmon = xytomon(cursor->x, cursor->y);
			if (newmon && newmon != selmon) {
				/* Transfer any open status menus to new monitor */
				transfer_status_menus(selmon, newmon);
				selmon = newmon;
			}
		}
	}

	/* Update drag icon's position */
	wlr_scene_node_set_position(&drag_icon->node, (int)round(cursor->x), (int)round(cursor->y));

	/* Hover feedback for tag boxes */
		if (selmon && selmon->showbar) {
			updatetaghover(selmon, cursor->x, cursor->y);
			updatecpuhover(selmon, cursor->x, cursor->y);
			updateramhover(selmon, cursor->x, cursor->y);
			updatebatteryhover(selmon, cursor->x, cursor->y);
			updatenethover(selmon, cursor->x, cursor->y);
			net_menu_update_hover(selmon, cursor->x, cursor->y);
			if (!selmon->statusbar.net_menu.visible)
				net_menu_hide_all();
		}

		/* Skip if internal call or already resizing */
		if (time == 0 && resizing_from_mouse)
			goto focus;

	tiled = grabc && !grabc->isfloating && !grabc->isfullscreen;
	last_pointer_motion_ms = monotonic_msec();
	if (cursor_mode == CurMove) {
		/* Move the grabbed client to the new position. */
		if (grabc && grabc->isfloating) {
			resize(grabc, (struct wlr_box){
				.x = (int)round(cursor->x) - grabcx,
				.y = (int)round(cursor->y) - grabcy,
				.width = grabc->geom.width,
				.height = grabc->geom.height
			}, 1);
			return;
		}
	} else if (cursor_mode == CurResize) {
			if (!resize_should_update(time))
				goto focus;

			if (tiled && resizing_from_mouse) {
				double ratio, ratio_h;
				int changed = 0;
				double dx_total = cursor->x - resize_start_x;
				double dy_total = cursor->y - resize_start_y;
				LayoutNode *client_node;

				if (!resize_split_node && !resize_split_node_h) {
					LayoutNode **curr_root = get_current_root(selmon);
					client_node = curr_root ? find_client_node(*curr_root, grabc) : NULL;
					if (!client_node)
						goto focus;

					resize_use_v = resize_use_h = 0;

					resize_split_node = closest_split_node(client_node, 1, cursor->x,
							&resize_start_ratio_v, &resize_start_box_v, NULL);
					if (!resize_split_node)
						resize_start_ratio_v = 0.5;

					resize_split_node_h = closest_split_node(client_node, 0, cursor->y,
							&resize_start_ratio_h, &resize_start_box_h, NULL);
					if (!resize_split_node_h)
						resize_start_ratio_h = 0.5;

					apply_resize_axis_choice();
				}

				if (resize_use_v && resize_split_node && resize_start_box_v.width > 0) {
					double current = resize_split_node->split_ratio;
					ratio = resize_start_ratio_v + dx_total / resize_start_box_v.width;
						if (ratio < 0.05f)
							ratio = 0.05f;
						if (ratio > 0.95f)
							ratio = 0.95f;
						if (fabs(ratio - current) >= resize_ratio_epsilon) {
							resize_split_node->split_ratio = (float)ratio;
							changed = 1;
						}
					}

				if (resize_use_h && resize_split_node_h && resize_start_box_h.height > 0) {
					double current_h = resize_split_node_h->split_ratio;
					ratio_h = resize_start_ratio_h + dy_total / resize_start_box_h.height;
						if (ratio_h < 0.05f)
							ratio_h = 0.05f;
						if (ratio_h > 0.95f)
							ratio_h = 0.95f;
						if (fabs(ratio_h - current_h) >= resize_ratio_epsilon) {
							resize_split_node_h->split_ratio = (float)ratio_h;
							changed = 1;
						}
					}

			if (changed)
				arrange(selmon);

		} else if (grabc && grabc->isfloating) {
			double dx_total = cursor->x - resize_start_x;
			double dy_total = cursor->y - resize_start_y;
			int minw = 1 + 2 * (int)grabc->bw;
			int minh = 1 + 2 * (int)grabc->bw;
			int dw = (int)lround(dx_total);
			int dh = (int)lround(dy_total);
			struct wlr_box box = resize_start_box_f;

			if (resize_dir_x) {
				if (resize_dir_x > 0) {
					if (box.width + dw < minw)
						dw = minw - box.width;
					box.width += dw;
				} else {
					if (box.width - dw < minw)
						dw = box.width - minw;
					box.x += dw;
					box.width -= dw;
				}
			}

			if (resize_dir_y) {
				if (resize_dir_y > 0) {
					if (box.height + dh < minh)
						dh = minh - box.height;
					box.height += dh;
				} else {
					if (box.height - dh < minh)
						dh = box.height - minh;
					box.y += dh;
					box.height -= dh;
				}
			}

			resize(grabc, box, 1);
			return;
		}
	}

focus:
	/* If there's no client surface under the cursor, set the cursor image to a
	 * default. This is what makes the cursor image appear when you move it
	 * off of a client or over its border. */
	if (!surface && !seat->drag) {
		/* Hide cursor when HTPC media views are visible */
		if (htpc_mode_active && selmon &&
		    (selmon->movies_view.visible || selmon->tvshows_view.visible ||
		     selmon->pc_gaming.visible || selmon->retro_gaming.visible))
			wlr_cursor_set_surface(cursor, NULL, 0, 0);
		else
			wlr_cursor_set_xcursor(cursor, cursor_mgr, "default");
	}

	pointerfocus(c, surface, sx, sy, time);
}

void
motionrelative(struct wl_listener *listener, void *data)
{
	/* This event is forwarded by the cursor when a pointer emits a _relative_
	 * pointer motion event (i.e. a delta) */
	struct wlr_pointer_motion_event *event = data;
	/* The cursor doesn't move unless we tell it to. The cursor automatically
	 * handles constraining the motion to the output layout, as well as any
	 * special configuration applied for the specific input device which
	 * generated the event. You can pass NULL for the device if you want to move
	 * the cursor around without any input. */
	last_pointer_motion_ms = monotonic_msec();
	motionnotify(event->time_msec, &event->pointer->base, event->delta_x, event->delta_y,
			event->unaccel_dx, event->unaccel_dy);
}

void
moveresize(const Arg *arg)
{
	if (cursor_mode != CurNormal && cursor_mode != CurPressed)
		return;
	xytonode(cursor->x, cursor->y, NULL, &grabc, NULL, NULL, NULL);
	if (!grabc || client_is_unmanaged(grabc) || grabc->isfullscreen)
		return;

	cursor_mode = arg->ui;
	grabc->was_tiled = (!grabc->isfloating && !grabc->isfullscreen);

	if (grabc->was_tiled) {
		switch (cursor_mode) {
		case CurMove:
			{
				struct wlr_box start_geom = grabc->geom;
				/* Start drag tracking before making floating */
				start_tile_drag(selmon, grabc);
				setfloating(grabc, 1);
				/* Anchor to the original cursor offset within the window */
				grabcx = (int)round(cursor->x) - start_geom.x;
				grabcy = (int)round(cursor->y) - start_geom.y;
				/* Keep the window anchored under the cursor when leaving tiling. */
				resize(grabc, start_geom, 1);
				wlr_cursor_set_xcursor(cursor, cursor_mgr, "fleur");
				break;
			}
		case CurResize:
			{
				struct wlr_box start_geom = grabc->geom;
				const char *cursor_name = pick_resize_handle(grabc, cursor->x, cursor->y);
				double start_x = cursor->x, start_y = cursor->y;
				grabcx = (int)round(cursor->x);
				grabcy = (int)round(cursor->y);

				resize_start_box_v = (struct wlr_box){0};
				resize_start_box_h = (struct wlr_box){0};
				resize_start_box_f = start_geom;
				resize_start_x = start_x;
				resize_start_y = start_y;
				resize_start_ratio_v = resize_start_ratio_h = 0.0;
				resize_split_node = NULL;
				resize_split_node_h = NULL;
				resize_last_time = 0;
				resize_last_x = start_x;
				resize_last_y = start_y;
				resizing_from_mouse = 1;
				/* Keep geometry unchanged as we switch to floating resize. */
				resize(grabc, start_geom, 1);
				wlr_cursor_set_xcursor(cursor, cursor_mgr, cursor_name);
			}
			break;
		}
	} else {
		/* Default floating logic */
		/* Float the window and tell motionnotify to grab it */
		setfloating(grabc, 1);
		switch (cursor_mode) {
		case CurMove:
			grabcx = (int)round(cursor->x) - grabc->geom.x;
			grabcy = (int)round(cursor->y) - grabc->geom.y;
			wlr_cursor_set_xcursor(cursor, cursor_mgr, "fleur");
			break;
		case CurResize:
			{
				const char *cursor_name = pick_resize_handle(grabc, cursor->x, cursor->y);
				double start_x = cursor->x, start_y = cursor->y;
				grabcx = (int)round(cursor->x);
				grabcy = (int)round(cursor->y);

				resize_start_box_v = (struct wlr_box){0};
				resize_start_box_h = (struct wlr_box){0};
				resize_start_box_f = grabc->geom;
				resize_start_x = start_x;
				resize_start_y = start_y;
				resize_start_ratio_v = resize_start_ratio_h = 0.0;
				resize_split_node = NULL;
				resize_split_node_h = NULL;
				resize_last_time = 0;
				resize_last_x = start_x;
				resize_last_y = start_y;
				resizing_from_mouse = 1;
				wlr_cursor_set_xcursor(cursor, cursor_mgr, cursor_name);
			}
			break;
		}
	}
}

void
outputmgrapply(struct wl_listener *listener, void *data)
{
	struct wlr_output_configuration_v1 *config = data;
	outputmgrapplyortest(config, 0);
}

void
outputmgrapplyortest(struct wlr_output_configuration_v1 *config, int test)
{
	/*
	 * Called when a client such as wlr-randr requests a change in output
	 * configuration. This is only one way that the layout can be changed,
	 * so any Monitor information should be updated by updatemons() after an
	 * output_layout.change event, not here.
	 */
	struct wlr_output_configuration_head_v1 *config_head;
	int ok = 1;

	wl_list_for_each(config_head, &config->heads, link) {
		struct wlr_output *wlr_output = config_head->state.output;
		Monitor *m = wlr_output->data;
		struct wlr_output_state state;

		/* Ensure displays previously disabled by wlr-output-power-management-v1
		 * are properly handled*/
		m->asleep = 0;

		wlr_output_state_init(&state);
		wlr_output_state_set_enabled(&state, config_head->state.enabled);
		if (!config_head->state.enabled)
			goto apply_or_test;

		if (config_head->state.mode)
			wlr_output_state_set_mode(&state, config_head->state.mode);
		else
			wlr_output_state_set_custom_mode(&state,
					config_head->state.custom_mode.width,
					config_head->state.custom_mode.height,
					config_head->state.custom_mode.refresh);

		wlr_output_state_set_transform(&state, config_head->state.transform);
		wlr_output_state_set_scale(&state, config_head->state.scale);
		wlr_output_state_set_adaptive_sync_enabled(&state,
				config_head->state.adaptive_sync_enabled);

apply_or_test:
		ok &= test ? wlr_output_test_state(wlr_output, &state)
				: wlr_output_commit_state(wlr_output, &state);

		/* Don't move monitors if position wouldn't change. This avoids
		 * wlroots marking the output as manually configured.
		 * wlr_output_layout_add does not like disabled outputs */
		if (!test && wlr_output->enabled && (m->m.x != config_head->state.x || m->m.y != config_head->state.y))
			wlr_output_layout_add(output_layout, wlr_output,
					config_head->state.x, config_head->state.y);

		wlr_output_state_finish(&state);
	}

	if (ok)
		wlr_output_configuration_v1_send_succeeded(config);
	else
		wlr_output_configuration_v1_send_failed(config);
	wlr_output_configuration_v1_destroy(config);

	/* https://codeberg.org/dwl/dwl/issues/577 */
	updatemons(NULL, NULL);
}

void
outputmgrtest(struct wl_listener *listener, void *data)
{
	struct wlr_output_configuration_v1 *config = data;
	outputmgrapplyortest(config, 1);
}

void
pointerfocus(Client *c, struct wlr_surface *surface, double sx, double sy,
		uint32_t time)
{
	struct timespec now;
	static int in_pointerfocus = 0;

	/* Focus follows mouse: focus client under cursor.
	 * Also update focus on internal calls (time==0) after layout changes
	 * so the tile under the cursor gets focus after rebalancing.
	 * Use re-entry guard to prevent infinite recursion since focusclient
	 * can trigger motionnotify which calls pointerfocus again. */
	if (!in_pointerfocus && surface != seat->pointer_state.focused_surface &&
			sloppyfocus && c && !client_is_unmanaged(c)) {
		in_pointerfocus = 1;
		focusclient(c, 0);
		in_pointerfocus = 0;
	}

	/* If surface is NULL, clear pointer focus */
	if (!surface) {
		wlr_seat_pointer_notify_clear_focus(seat);
		return;
	}

	if (!time) {
		clock_gettime(CLOCK_MONOTONIC, &now);
		time = now.tv_sec * 1000 + now.tv_nsec / 1000000;
	}

	/* Let the client know that the mouse cursor has entered one
	 * of its surfaces, and make keyboard focus follow if desired.
	 * wlroots makes this a no-op if surface is already focused */
	wlr_seat_pointer_notify_enter(seat, surface, sx, sy);
	wlr_seat_pointer_notify_motion(seat, time, sx, sy);
}

static void
updatetaghover(Monitor *m, double cx, double cy)
{
	StatusModule *tags;
	int lx, ly, hover = -1;
	int bar_h;

	if (!m || !m->showbar)
		return;

	tags = &m->statusbar.tags;
	if (!tags->tree || m->statusbar.area.width <= 0 || m->statusbar.area.height <= 0)
		return;

	lx = (int)floor(cx) - m->statusbar.area.x;
	ly = (int)floor(cy) - m->statusbar.area.y;
	if (lx >= 0 && ly >= 0 && lx < m->statusbar.area.width && ly < m->statusbar.area.height
			&& lx < tags->width) {
		for (int i = 0; i < tags->box_count; i++) {
			if (lx >= tags->box_x[i] && lx < tags->box_x[i] + tags->box_w[i]) {
				hover = tags->box_tag[i];
				break;
			}
		}
	}

	if (hover == tags->hover_tag)
		return;

	tags->hover_tag = hover;
	bar_h = m->statusbar.area.height ? m->statusbar.area.height : (int)statusbar_height;
	if (statusbar_hover_fade_ms <= 0) {
		for (int i = 0; i < TAGCOUNT; i++)
			tags->hover_alpha[i] = (tags->hover_tag == i) ? 1.0f : 0.0f;
		renderworkspaces(m, tags, bar_h);
		positionstatusmodules(m);
		return;
	}

	renderworkspaces(m, tags, bar_h);
	positionstatusmodules(m);
	if (status_hover_timer)
		wl_event_source_timer_update(status_hover_timer, 0);
	else
		schedule_hover_timer();
}

static void
schedule_hover_timer(void)
{
	Monitor *mon;

	if (!status_hover_timer)
		return;

	wl_list_for_each(mon, &mons, link) {
		Monitor *m = mon;
		int active = (m->statusbar.tags.hover_tag >= 0);
		for (int i = 0; i < TAGCOUNT && !active; i++) {
			if (m->statusbar.tags.hover_alpha[i] > 0.0f) {
				active = 1;
				break;
			}
		}
		if (active) {
			wl_event_source_timer_update(status_hover_timer, 16);
			return;
		}
	}
}

void
printstatus(void)
{
	Monitor *m = NULL;
	Client *c;
	uint32_t occ, urg, sel;

	wl_list_for_each(m, &mons, link) {
		occ = urg = 0;
		wl_list_for_each(c, &clients, link) {
			if (c->mon != m)
				continue;
			occ |= c->tags;
			if (c->isurgent)
				urg |= c->tags;
		}
		if ((c = focustop(m))) {
			printf("%s title %s\n", m->wlr_output->name, client_get_title(c));
			printf("%s appid %s\n", m->wlr_output->name, client_get_appid(c));
			printf("%s fullscreen %d\n", m->wlr_output->name, c->isfullscreen);
			printf("%s floating %d\n", m->wlr_output->name, c->isfloating);
			sel = c->tags;
		} else {
			printf("%s title \n", m->wlr_output->name);
			printf("%s appid \n", m->wlr_output->name);
			printf("%s fullscreen \n", m->wlr_output->name);
			printf("%s floating \n", m->wlr_output->name);
			sel = 0;
		}

		printf("%s selmon %u\n", m->wlr_output->name, m == selmon);
		printf("%s tags %"PRIu32" %"PRIu32" %"PRIu32" %"PRIu32"\n",
			m->wlr_output->name, occ, m->tagset[m->seltags], sel, urg);
		printf("%s layout %s\n", m->wlr_output->name, m->ltsymbol);
	}
	fflush(stdout);
}

void
powermgrsetmode(struct wl_listener *listener, void *data)
{
	struct wlr_output_power_v1_set_mode_event *event = data;
	struct wlr_output_state state = {0};
	Monitor *m = event->output->data;

	if (!m)
		return;

	m->gamma_lut_changed = 1; /* Reapply gamma LUT when re-enabling the ouput */
	wlr_output_state_set_enabled(&state, event->mode);
	wlr_output_commit_state(m->wlr_output, &state);

	m->asleep = !event->mode;
	updatemons(NULL, NULL);
}

void
setsticky(Client *c, int sticky)
{
	if (sticky && !c->issticky) {
		c->issticky = 1;
	} else if (!sticky && c->issticky) {
		c->issticky = 0;
		arrange(c->mon);
	}
}

void
quit(const Arg *arg)
{
	wlr_log(WLR_ERROR, "quit() called - terminating display");
	wl_display_terminate(dpy);
}

/*
 * Get current time in nanoseconds (monotonic clock).
 * Used for precise frame timing measurements.
 */
static uint64_t
get_time_ns(void)
{
	struct timespec ts;
	clock_gettime(CLOCK_MONOTONIC, &ts);
	return (uint64_t)ts.tv_sec * 1000000000ULL + (uint64_t)ts.tv_nsec;
}

/*
 * Render a monitor frame with optimal frame pacing.
 *
 * Frame pacing strategy (inspired by Gamescope):
 *
 * For GAMES (content-type=game or tearing hint):
 *   - Use async page flips (tearing) for minimum input latency
 *   - Frame is displayed immediately when GPU finishes
 *   - Best for competitive/fast-paced games
 *
 * For VIDEO (content-type=video or detected video framerate):
 *   - Use VRR if available for judder-free playback
 *   - Otherwise use vsync with matched refresh rate
 *   - Critical: consistent frame timing is more important than latency
 *
 * For NORMAL content:
 *   - Standard vsync'd commits
 *   - Balance between latency and smoothness
 *
 * Frame timing tracking:
 *   - Track commit duration for predicting future commits
 *   - Use rolling average to handle spikes gracefully
 *   - Skip unnecessary commits when nothing has changed
 *   - Compositor-controlled frame pacing for optimal display timing
 */
void
rendermon(struct wl_listener *listener, void *data)
{
	Monitor *m = wl_container_of(listener, m, frame);
	struct wlr_scene_output_state_options opts = {0};
	struct wlr_output_state state;
	struct timespec now;
	uint64_t frame_start_ns, commit_end_ns;
	int needs_frame = 0;
	Client *fullscreen_client = NULL;
	int allow_tearing = 0;
	int is_video = 0;
	int is_game = 0;
	int is_direct_scanout = 0;
	int use_frame_pacing = 0;

	frame_start_ns = get_time_ns();

	/*
	 * Check for fullscreen client and determine content type for optimal handling.
	 */
	fullscreen_client = focustop(m);
	if (fullscreen_client && fullscreen_client->isfullscreen) {
		is_game = client_wants_tearing(fullscreen_client) || is_game_content(fullscreen_client);
		is_video = is_video_content(fullscreen_client) || fullscreen_client->detected_video_hz > 0.0f;

		/* Games get tearing for lowest latency, unless it's video content */
		if (is_game && !is_video) {
			allow_tearing = 1;
		}
	}

	/*
	 * Build output state. This determines if we actually need to render.
	 * wlr_scene handles damage tracking and direct scanout optimization.
	 *
	 * When a fullscreen window covers the entire output and its buffer
	 * is compatible (DMA-BUF, correct size/format), wlroots will
	 * automatically use direct scanout - bypassing GPU composition entirely.
	 * This gives optimal frame pacing for games and video.
	 */
	wlr_output_state_init(&state);
	needs_frame = wlr_scene_output_build_state(m->scene_output, &state, &opts);

	/*
	 * Detect direct scanout: if the output buffer is a client buffer
	 * (not from the compositor's swapchain), direct scanout is active.
	 * wlr_client_buffer_get() returns non-NULL only for client buffers.
	 */
	if (needs_frame && state.buffer && wlr_client_buffer_get(state.buffer)) {
		is_direct_scanout = 1;
	}

	/* Track scanout state transitions and show notification */
	if (is_direct_scanout && !m->direct_scanout_active) {
		m->direct_scanout_active = 1;
		m->frame_pacing_active = 1; /* Enable frame pacing for direct scanout */
		if (!m->direct_scanout_notified) {
			show_hz_osd(m, "Direct Scanout");
			m->direct_scanout_notified = 1;
		}
		wlr_log(WLR_INFO, "Direct scanout activated on %s - frame pacing enabled",
			m->wlr_output->name);
	} else if (!is_direct_scanout && m->direct_scanout_active) {
		m->direct_scanout_active = 0;
		m->frame_pacing_active = 0;
		m->direct_scanout_notified = 0; /* Reset so next scanout shows OSD again */
		/* Reset frame pacing statistics on exit */
		m->pending_game_frame = 0;
		m->estimated_game_fps = 0.0f;
		wlr_log(WLR_INFO, "Direct scanout deactivated on %s - stats: %lu presented, %lu dropped, %lu held",
			m->wlr_output->name, m->frames_presented, m->frames_dropped, m->frames_held);
	}

	/*
	 * Frame pacing logic for games in direct scanout mode.
	 *
	 * When we have direct scanout with a game, we can optimize frame timing:
	 * 1. Track the game's frame submission rate
	 * 2. Hold frames that arrive too early (would cause judder)
	 * 3. Release frames at optimal vblank timing
	 *
	 * This is similar to Gamescope's frame pacing but integrated into
	 * the compositor for seamless operation.
	 */
	if (is_direct_scanout && is_game && !allow_tearing && m->frame_pacing_active) {
		use_frame_pacing = 1;

		/* Track game's frame submission interval */
		if (m->game_frame_submit_ns > 0 && frame_start_ns > m->game_frame_submit_ns) {
			uint64_t game_interval = frame_start_ns - m->game_frame_submit_ns;

			/* Only track reasonable intervals (8ms - 100ms = ~10-120fps) */
			if (game_interval > 8000000 && game_interval < 100000000) {
				m->game_frame_intervals[m->game_frame_interval_idx] = game_interval;
				m->game_frame_interval_idx = (m->game_frame_interval_idx + 1) % 8;
				if (m->game_frame_interval_count < 8)
					m->game_frame_interval_count++;

				/* Calculate estimated game FPS from rolling average */
				if (m->game_frame_interval_count >= 4) {
					uint64_t avg_interval = 0;
					uint64_t variance_sum = 0;
					for (int i = 0; i < m->game_frame_interval_count; i++)
						avg_interval += m->game_frame_intervals[i];
					avg_interval /= m->game_frame_interval_count;
					m->estimated_game_fps = 1000000000.0f / (float)avg_interval;

					/*
					 * Calculate frame time variance (jitter).
					 * Low variance = consistent frame times = smooth gameplay.
					 * High variance = inconsistent = potential stutter.
					 */
					for (int i = 0; i < m->game_frame_interval_count; i++) {
						int64_t diff = (int64_t)m->game_frame_intervals[i] - (int64_t)avg_interval;
						variance_sum += (uint64_t)(diff * diff);
					}
					m->frame_variance_ns = variance_sum / m->game_frame_interval_count;

					/*
					 * PREDICTIVE FRAME TIMING
					 *
					 * Predict when the next frame will arrive based on:
					 * 1. Average frame interval
					 * 2. Recent trend (acceleration/deceleration)
					 * 3. Variance (add margin for high-jitter games)
					 *
					 * This allows the compositor to prepare for the frame
					 * and commit at optimal vblank timing.
					 */
					m->predicted_next_frame_ns = frame_start_ns + avg_interval;

					/* Add margin based on variance (higher jitter = more margin) */
					if (m->frame_variance_ns > 0) {
						/* sqrt approximation for margin: variance^0.5 */
						uint64_t margin = 0;
						uint64_t v = m->frame_variance_ns;
						while (v > margin * margin)
							margin += 100000; /* 0.1ms steps */
						m->predicted_next_frame_ns += margin;
					}

					/* Track prediction accuracy */
					if (m->predicted_next_frame_ns > 0) {
						int64_t prediction_error = (int64_t)frame_start_ns - (int64_t)(m->predicted_next_frame_ns - avg_interval);
						if (prediction_error < 0) prediction_error = -prediction_error;

						/* Frame is "on time" if within 2ms of prediction */
						if (prediction_error < 2000000) {
							/* Good prediction */
							m->prediction_accuracy = m->prediction_accuracy * 0.9f + 10.0f;
						} else if (prediction_error < (int64_t)avg_interval / 4) {
							/* Acceptable prediction */
							m->prediction_accuracy = m->prediction_accuracy * 0.9f + 5.0f;
							if (frame_start_ns < m->predicted_next_frame_ns - avg_interval)
								m->frames_early++;
							else
								m->frames_late++;
						} else {
							/* Poor prediction */
							m->prediction_accuracy = m->prediction_accuracy * 0.9f;
							m->frames_late++;
						}
						if (m->prediction_accuracy > 100.0f) m->prediction_accuracy = 100.0f;
					}

					/*
					 * Update dynamic game VRR.
					 * This adjusts the display to match the game's framerate,
					 * eliminating judder when games run below native refresh.
					 */
					if (m->game_vrr_active) {
						update_game_vrr(m, m->estimated_game_fps);
					}
				}
			}
		}
		m->game_frame_submit_ns = frame_start_ns;
		m->pending_game_frame = 1;

		/*
		 * Frame hold/release decision:
		 *
		 * If the game is running slower than display refresh, present immediately.
		 * If the game is running faster, we may want to hold frames to prevent
		 * judder from uneven frame presentation.
		 *
		 * Key insight: With direct scanout, the display directly shows the
		 * game's buffer. We control WHEN it flips via the commit timing.
		 */
		if (m->present_interval_ns > 0 && m->target_present_ns > 0) {
			uint64_t time_to_target = 0;
			if (frame_start_ns < m->target_present_ns)
				time_to_target = m->target_present_ns - frame_start_ns;

			/*
			 * If we're more than 2ms early, the frame arrived too soon.
			 * In a perfect world we'd hold it, but that requires async
			 * frame scheduling which is complex. For now, just track it.
			 */
			if (time_to_target > 2000000) {
				m->frames_held++;
				/*
				 * Note: True frame holding would require:
				 * 1. Storing the buffer
				 * 2. Setting up a timer for optimal commit time
				 * 3. Committing at the right moment
				 *
				 * wlroots doesn't easily support this, so we commit
				 * immediately but track that we could have held it.
				 */
			}
		}
	}

	/*
	 * ============ FRAME DOUBLING/TRIPLING FOR SMOOTH LOW-FPS PLAYBACK ============
	 *
	 * When a game runs at a framerate that doesn't divide evenly into the
	 * display refresh rate, you get "judder" - uneven frame presentation times.
	 *
	 * Example: 30 FPS game on 60 Hz display
	 *   Without frame doubling: frame times are 16.6ms, 16.6ms (uneven feel)
	 *   With frame doubling: each game frame shown 2x = perfect 33.3ms cadence
	 *
	 * Example: 24 FPS video on 120 Hz display
	 *   Without: judder from 5:5:5:5:5 pattern not matching 24fps
	 *   With frame 5x repeat: each frame shown 5 times = perfect 41.6ms cadence
	 *
	 * This technique is used by:
	 * - Gamescope (Steam Deck compositor)
	 * - High-end TVs (motion interpolation alternative)
	 * - Professional video players
	 *
	 * We ONLY use this when VRR is NOT available or disabled, as VRR solves
	 * this problem by adjusting the display refresh to match content.
	 */
	if (is_game && m->frame_pacing_active && !m->game_vrr_active && !allow_tearing) {
		float display_hz = 0.0f;
		float game_fps = m->estimated_game_fps;
		int optimal_repeat = 1;

		/* Get current display refresh rate */
		if (m->present_interval_ns > 0) {
			display_hz = 1000000000.0f / (float)m->present_interval_ns;
		} else if (m->wlr_output->current_mode) {
			display_hz = (float)m->wlr_output->current_mode->refresh / 1000.0f;
		}

		/*
		 * Calculate optimal frame repeat count.
		 * We want to find integer N where: display_hz / N  game_fps
		 *
		 * This gives perfectly even frame timing without interpolation.
		 */
		if (game_fps > 5.0f && display_hz > 30.0f) {
			float ratio = display_hz / game_fps;

			/*
			 * Find the best integer repeat count (1-6x).
			 * We check which integer gives the smallest error.
			 */
			float min_error = 9999.0f;
			for (int n = 1; n <= 6; n++) {
				float effective_fps = display_hz / (float)n;
				float error = fabsf(effective_fps - game_fps);
				/* Also check if game fps is close to a fraction */
				float frac_error = fabsf(ratio - (float)n);

				if (frac_error < 0.15f && error < min_error) {
					min_error = error;
					optimal_repeat = n;
				}
			}

			/*
			 * Common patterns we optimize for:
			 *
			 * 60Hz display:
			 *   30 FPS  2x repeat (60/2=30) 
			 *   20 FPS  3x repeat (60/3=20) 
			 *   15 FPS  4x repeat (60/4=15) 
			 *
			 * 120Hz display:
			 *   60 FPS  2x repeat (120/2=60) 
			 *   40 FPS  3x repeat (120/3=40) 
			 *   30 FPS  4x repeat (120/4=30) 
			 *   24 FPS  5x repeat (120/5=24)  (perfect for film content)
			 *
			 * 144Hz display:
			 *   72 FPS  2x repeat (144/2=72) 
			 *   48 FPS  3x repeat (144/3=48) 
			 *   36 FPS  4x repeat (144/4=36) 
			 */

			/* Only enable repeat if we have a good match (within 10%) */
			if (optimal_repeat > 1) {
				float target_fps = display_hz / (float)optimal_repeat;
				float match_quality = fabsf(game_fps - target_fps) / target_fps;

				if (match_quality > 0.10f) {
					/* Not a good match, disable repeat */
					optimal_repeat = 1;
				}
			}
		}

		/* Update frame repeat state */
		if (optimal_repeat != m->frame_repeat_count) {
			if (optimal_repeat > 1 && !m->frame_repeat_enabled) {
				m->frame_repeat_enabled = 1;
				m->frame_repeat_interval_ns = m->present_interval_ns;
				wlr_log(WLR_INFO, "Frame repeat enabled: %dx (%.1f FPS  %.1f Hz display)",
					optimal_repeat, game_fps, display_hz);
			} else if (optimal_repeat == 1 && m->frame_repeat_enabled) {
				m->frame_repeat_enabled = 0;
				wlr_log(WLR_INFO, "Frame repeat disabled - game FPS matches display");
			}
			m->frame_repeat_count = optimal_repeat;
			m->frame_repeat_current = 0;
		}

		/*
		 * Calculate judder score (0-100, lower is better).
		 * This measures how well game fps matches display refresh.
		 */
		if (game_fps > 0.0f && display_hz > 0.0f) {
			float ideal_interval_ms = 1000.0f / game_fps;
			float actual_interval_ms = 1000.0f / display_hz * (float)optimal_repeat;
			float deviation_pct = fabsf(ideal_interval_ms - actual_interval_ms) / ideal_interval_ms * 100.0f;
			m->judder_score = (int)(deviation_pct * 10.0f); /* Scale to 0-100ish */
			if (m->judder_score > 100) m->judder_score = 100;
		}

		/* Enable adaptive pacing for smoother non-VRR playback */
		m->adaptive_pacing_enabled = 1;
		m->target_frame_time_ms = 1000.0f / game_fps;

	} else {
		/* Reset frame repeat state when not applicable */
		if (m->frame_repeat_enabled) {
			m->frame_repeat_enabled = 0;
			m->frame_repeat_count = 1;
			m->frame_repeat_current = 0;
			m->adaptive_pacing_enabled = 0;
			wlr_log(WLR_INFO, "Frame repeat disabled - VRR active or tearing enabled");
		}
	}

	if (needs_frame) {
		m->frames_since_content_change = 0;

		/*
		 * Apply tearing for games that want it - async page flips bypass vsync.
		 * This gives the lowest possible input latency at the cost of
		 * potential screen tearing (which some gamers prefer).
		 *
		 * Note: When frame pacing is active and tearing is NOT requested,
		 * we rely on vsync'd commits for smooth presentation.
		 */
		if (allow_tearing && wlr_output_is_drm(m->wlr_output)) {
			state.tearing_page_flip = true;
		}

		/* Commit the frame */
		if (!wlr_output_commit_state(m->wlr_output, &state)) {
			/* Fallback: retry without tearing if it failed */
			if (allow_tearing) {
				state.tearing_page_flip = false;
				wlr_output_commit_state(m->wlr_output, &state);
			}
		}

		/* Track commit timing for frame pacing analysis */
		commit_end_ns = get_time_ns();
		m->last_commit_duration_ns = commit_end_ns - frame_start_ns;

		/*
		 * INPUT LATENCY TRACKING
		 *
		 * Measure time from last input event to frame commit.
		 * This is a key component of "input-to-photon" latency:
		 *   Total latency = input processing + game logic + render + commit + scanout
		 *
		 * We measure: input event  frame commit (what compositor controls)
		 * The remaining latency (scanout) depends on display.
		 */
		if (game_mode_ultra && m->last_input_ns > 0) {
			uint64_t input_latency = commit_end_ns - m->last_input_ns;

			/* Only track reasonable latencies (< 500ms) */
			if (input_latency < 500000000ULL) {
				m->input_to_frame_ns = input_latency;

				/* Track min/max for statistics */
				if (m->min_input_latency_ns == 0 || input_latency < m->min_input_latency_ns)
					m->min_input_latency_ns = input_latency;
				if (input_latency > m->max_input_latency_ns)
					m->max_input_latency_ns = input_latency;
			}
		}

		/*
		 * Update rolling average of commit time (Gamescope-style).
		 * Use 98% decay rate - this means spikes are remembered but
		 * gradually fade, while sustained high times are tracked accurately.
		 */
		if (m->rolling_commit_time_ns == 0) {
			m->rolling_commit_time_ns = m->last_commit_duration_ns;
		} else {
			/* Rolling average: 98% old + 2% new */
			m->rolling_commit_time_ns =
				(m->rolling_commit_time_ns * 98 + m->last_commit_duration_ns * 2) / 100;

			/* But always track upward spikes immediately */
			if (m->last_commit_duration_ns > m->rolling_commit_time_ns) {
				m->rolling_commit_time_ns = m->last_commit_duration_ns;
			}
		}
	} else {
		m->frames_since_content_change++;

		/*
		 * If frame pacing is active but no new frame, track potential drop.
		 * This happens when the game misses a vblank deadline.
		 */
		if (use_frame_pacing && m->pending_game_frame) {
			/* Game didn't submit a new frame - previous one will be shown again */
			m->frames_dropped++;
			m->pending_game_frame = 0;
		}
	}

	wlr_output_state_finish(&state);
	m->last_frame_ns = frame_start_ns;

	/*
	 * FPS Limiter - controls when we send frame_done to clients.
	 *
	 * By delaying frame_done, we effectively limit how fast games can
	 * render. The game waits for frame_done before starting the next
	 * frame, so controlling this signal controls the framerate.
	 */
	if (fps_limit_enabled && fps_limit_value > 0 && is_game) {
		uint64_t target_interval_ns = 1000000000ULL / (uint64_t)fps_limit_value;
		uint64_t now_ns = get_time_ns();
		uint64_t elapsed_ns = 0;

		if (m->fps_limit_last_frame_ns > 0)
			elapsed_ns = now_ns - m->fps_limit_last_frame_ns;

		m->fps_limit_interval_ns = target_interval_ns;

		/*
		 * If not enough time has passed since last frame_done,
		 * skip sending frame_done this vblank. The game will
		 * continue to wait, effectively limiting its framerate.
		 */
		if (elapsed_ns < target_interval_ns) {
			/* Don't send frame_done yet - limiter is active */
			return;
		}

		m->fps_limit_last_frame_ns = now_ns;
	}

	/*
	 * ============ FRAME REPEAT MECHANISM ============
	 *
	 * When frame doubling/tripling is active, we control the frame_done
	 * signal to make the game render at a rate that divides evenly into
	 * the display refresh rate.
	 *
	 * For example, on a 120Hz display with a game targeting 30 FPS:
	 * - We want frame_done sent every 4th vblank (120/4=30)
	 * - Each game frame is displayed for exactly 4 vblanks
	 * - Result: perfectly even 33.33ms frame times, zero judder
	 *
	 * This is the KEY to smooth low-FPS gaming without VRR:
	 * Instead of uneven frame times (16-17-16-17-16ms), we get
	 * perfectly consistent frame times (33-33-33-33-33ms for 30fps).
	 */
	if (m->frame_repeat_enabled && m->frame_repeat_count > 1 && is_game) {
		m->frame_repeat_current++;

		/*
		 * Only send frame_done when we've shown the current frame
		 * for the required number of vblanks.
		 */
		if (m->frame_repeat_current < m->frame_repeat_count) {
			/*
			 * Not time for a new frame yet - skip frame_done.
			 * The game will wait, and we'll show the same frame again
			 * on the next vblank. This is frame "doubling" or "tripling".
			 */
			m->frames_repeated++;

			/*
			 * We still need to acknowledge this vblank for timing,
			 * but we DON'T tell the game to render a new frame.
			 * The display will simply show the previous frame again.
			 *
			 * This creates perfect frame cadence:
			 * - 2x repeat: frame shown at vblank 0 and 1, new frame at 2
			 * - 3x repeat: frame shown at vblank 0, 1, 2, new frame at 3
			 * - etc.
			 */
			return;
		}

		/* Time for new frame - reset counter and continue to frame_done */
		m->frame_repeat_current = 0;
	}

	/*
	 * Send frame_done to clients.
	 *
	 * This is critical for proper frame pacing:
	 * - Video players use this to time their next frame submission
	 * - Games use this to know when to start rendering the next frame
	 * - The timestamp should reflect when the frame opportunity occurred
	 *
	 * We always send this, even if we didn't commit, because clients
	 * need to know a vblank occurred for proper timing.
	 */
	clock_gettime(CLOCK_MONOTONIC, &now);
	wlr_scene_output_send_frame_done(m->scene_output, &now);
}

/*
 * Presentation feedback callback - called when a frame is actually displayed.
 * This gives us precise vblank timing for optimal frame pacing.
 */
static void
outputpresent(struct wl_listener *listener, void *data)
{
	Monitor *m = wl_container_of(listener, m, present);
	struct wlr_output_event_present *event = data;
	uint64_t present_ns;

	if (!event || !event->presented)
		return;

	/* Convert timespec to nanoseconds */
	present_ns = (uint64_t)event->when.tv_sec * 1000000000ULL +
		     (uint64_t)event->when.tv_nsec;

	/* Calculate interval between presents (vblank interval) */
	if (m->last_present_ns > 0 && present_ns > m->last_present_ns) {
		uint64_t interval = present_ns - m->last_present_ns;
		/* Sanity check: interval should be reasonable (1ms - 100ms) */
		if (interval > 1000000 && interval < 100000000) {
			/* Rolling average with 90% old, 10% new */
			if (m->present_interval_ns == 0) {
				m->present_interval_ns = interval;
			} else {
				m->present_interval_ns =
					(m->present_interval_ns * 90 + interval * 10) / 100;
			}
		}
	}

	m->last_present_ns = present_ns;
	m->frames_presented++;

	/*
	 * If we're in frame pacing mode and have a pending game frame,
	 * calculate latency statistics.
	 */
	if (m->frame_pacing_active && m->pending_game_frame && m->game_frame_submit_ns > 0) {
		uint64_t latency = present_ns - m->game_frame_submit_ns;
		m->total_latency_ns += latency;
		m->pending_game_frame = 0;
	}

	/*
	 * Calculate target time for next frame presentation.
	 * We want to present at the next vblank, minus a small margin
	 * for compositor overhead (1ms).
	 */
	if (m->present_interval_ns > 0) {
		m->target_present_ns = present_ns + m->present_interval_ns - 1000000;
	}
}

void
requestdecorationmode(struct wl_listener *listener, void *data)
{
	Client *c = wl_container_of(listener, c, set_decoration_mode);
	if (c->surface.xdg->initialized)
		wlr_xdg_toplevel_decoration_v1_set_mode(c->decoration,
				WLR_XDG_TOPLEVEL_DECORATION_V1_MODE_SERVER_SIDE);
}

void
requeststartdrag(struct wl_listener *listener, void *data)
{
	struct wlr_seat_request_start_drag_event *event = data;

	if (wlr_seat_validate_pointer_grab_serial(seat, event->origin,
			event->serial))
		wlr_seat_start_pointer_drag(seat, event->drag, event->serial);
	else
		wlr_data_source_destroy(event->drag->source);
}

void
requestmonstate(struct wl_listener *listener, void *data)
{
	struct wlr_output_event_request_state *event = data;
	wlr_output_commit_state(event->output, event->state);
	updatemons(NULL, NULL);
}

void
resize(Client *c, struct wlr_box geo, int interact)
{
	struct wlr_box *bbox;
	struct wlr_box clip;
	int reqw, reqh;

	if (!c->mon || !client_surface(c)->mapped)
		return;

	bbox = interact ? &sgeom : &c->mon->w;

	client_set_bounds(c, geo.width, geo.height);
	c->geom = geo;
	applybounds(c, bbox);

	/* Update scene-graph, including borders */
	wlr_scene_node_set_position(&c->scene->node, c->geom.x, c->geom.y);
	wlr_scene_node_set_position(&c->scene_surface->node, c->bw, c->bw);
	wlr_scene_rect_set_size(c->border[0], c->geom.width, c->bw);
	wlr_scene_rect_set_size(c->border[1], c->geom.width, c->bw);
	wlr_scene_rect_set_size(c->border[2], c->bw, c->geom.height - 2 * c->bw);
	wlr_scene_rect_set_size(c->border[3], c->bw, c->geom.height - 2 * c->bw);
	wlr_scene_node_set_position(&c->border[1]->node, 0, c->geom.height - c->bw);
	wlr_scene_node_set_position(&c->border[2]->node, 0, c->bw);
	wlr_scene_node_set_position(&c->border[3]->node, c->geom.width - c->bw, c->bw);

	reqw = c->geom.width - 2 * c->bw;
	reqh = c->geom.height - 2 * c->bw;

	/*
	 * Avoid flooding heavy clients: only send a new configure when there isn't
	 * already one pending. While waiting for an ack we just remember the
	 * latest requested size.
	 */
	if (!c->resize)
		c->resize = client_set_size(c, reqw, reqh);
	c->pending_resize_w = reqw;
	c->pending_resize_h = reqh;

	client_get_clip(c, &clip);
	wlr_scene_subsurface_tree_set_clip(&c->scene_surface->node, &clip);
}

void
run(const char *startup_cmd)
{
	/* Add a Unix socket to the Wayland display. */
	const char *socket = wl_display_add_socket_auto(dpy);
	if (!socket)
		die("startup: display_add_socket_auto");
	setenv("WAYLAND_DISPLAY", socket, 1);

	/* Start the backend. This will enumerate outputs and inputs, become the DRM
	 * master, etc */
	if (!wlr_backend_start(backend))
		die("startup: backend_start");

	/* Now that the socket exists and the backend is started, run the startup command */
	if (startup_cmd) {
		int piperw[2];
		if (pipe(piperw) < 0)
			die("startup: pipe:");
		if ((child_pid = fork()) < 0)
			die("startup: fork:");
		if (child_pid == 0) {
			setsid();
			dup2(piperw[0], STDIN_FILENO);
			close(piperw[0]);
			close(piperw[1]);
			execl("/bin/sh", "/bin/sh", "-c", startup_cmd, NULL);
			die("startup: execl:");
		}
		dup2(piperw[1], STDOUT_FILENO);
		close(piperw[1]);
		close(piperw[0]);
	}

	/* Import environment variables then start systemd target */
	if (fork() == 0) {
		pid_t import_pid;
		setsid();

		/* First: import environment variables */
		import_pid = fork();
		if (import_pid == 0) {
			execvp("systemctl", (char *const[]) {
				"systemctl", "--user", "import-environment",
				"DISPLAY", "WAYLAND_DISPLAY", NULL
			});
			exit(1);
		}

		/* Wait for import to complete */
		waitpid(import_pid, NULL, 0);

		/* Second: start target */
		if (has_nixlytile_session_target()) {
			execvp("systemctl", (char *const[]) {
				"systemctl", "--user", "start", "nixlytile-session.target", NULL
			});
		}

		exit(1);
	}

	/* Mark stdout as non-blocking to avoid the startup script
	 * causing dwl to freeze when a user neither closes stdin
	 * nor consumes standard input in his startup script */

	if (fd_set_nonblock(STDOUT_FILENO) < 0)
		close(STDOUT_FILENO);

	printstatus();

	/* At this point the outputs are initialized, choose initial selmon based on
	 * cursor position, and set default cursor image */
	selmon = xytomon(cursor->x, cursor->y);

	/* TODO hack to get cursor to display in its initial location (100, 100)
	 * instead of (0, 0) and then jumping. Still may not be fully
	 * initialized, as the image/coordinates are not transformed for the
	 * monitor when displayed here */
	wlr_cursor_warp_closest(cursor, NULL, cursor->x, cursor->y);
	wlr_cursor_set_xcursor(cursor, cursor_mgr, "default");

	/* Run the Wayland event loop. This does not return until you exit the
	 * compositor. Starting the backend rigged up all of the necessary event
	 * loop configuration to listen to libinput events, DRM events, generate
	 * frame events at the refresh rate, and so on. */
	wl_display_run(dpy);
}

void
set_adaptive_sync(Monitor *m, int enable)
{
	struct wlr_output_state state;
	struct wlr_output_configuration_v1 *config;
	struct wlr_output_configuration_head_v1 *config_head;

	if (!m || !m->wlr_output || !m->wlr_output->enabled
			|| !fullscreen_adaptive_sync_enabled)
		return;

	config = wlr_output_configuration_v1_create();
	config_head = wlr_output_configuration_head_v1_create(config, m->wlr_output);

	/* Set and commit the adaptive sync state change */
	wlr_output_state_init(&state);
	wlr_output_state_set_adaptive_sync_enabled(&state, enable);
	wlr_output_commit_state(m->wlr_output, &state);
	wlr_output_state_finish(&state);

	/* Broadcast the adaptive sync state change to output_mgr */
	config_head->state.adaptive_sync_enabled = enable;
	wlr_output_manager_v1_set_configuration(output_mgr, config);
}

/*
 * Dynamic Game VRR - Matches display refresh rate to game framerate.
 *
 * When VRR is enabled and a game is running fullscreen, the compositor
 * dynamically adjusts the display's refresh rate to match the game's
 * actual framerate. This eliminates judder when games run below the
 * monitor's native refresh rate.
 *
 * Key features:
 * - Hysteresis: Requires stable FPS for 30+ frames before adjusting
 * - Deadband: Ignores FPS changes < 3 FPS to avoid jitter
 * - Rate limiting: No more than one adjustment per 500ms
 * - Smooth transitions: VRR handles the actual rate change smoothly
 */

/* Minimum time between VRR adjustments (500ms) */
#define GAME_VRR_MIN_INTERVAL_NS (500ULL * 1000000ULL)
/* Frames needed at stable FPS before adjusting */
#define GAME_VRR_STABLE_FRAMES 30
/* FPS change threshold to trigger adjustment (3 FPS) */
#define GAME_VRR_FPS_DEADBAND 3.0f
/* Minimum FPS to track (below this, don't adjust) */
#define GAME_VRR_MIN_FPS 20.0f
/* Maximum FPS to track (above this, use native refresh) */
#define GAME_VRR_MAX_FPS 165.0f

/*
 * Enable game VRR mode - activates adaptive sync for game framerate matching.
 */
static void
enable_game_vrr(Monitor *m)
{
	struct wlr_output_state state;
	char osd_msg[64];

	if (!m || !m->vrr_capable || m->game_vrr_active)
		return;

	if (!fullscreen_adaptive_sync_enabled) {
		wlr_log(WLR_INFO, "Game VRR: disabled by user setting");
		return;
	}

	wlr_output_state_init(&state);
	wlr_output_state_set_adaptive_sync_enabled(&state, 1);

	if (wlr_output_commit_state(m->wlr_output, &state)) {
		m->game_vrr_active = 1;
		m->game_vrr_target_fps = 0.0f;
		m->game_vrr_last_fps = 0.0f;
		m->game_vrr_last_change_ns = get_time_ns();
		m->game_vrr_stable_frames = 0;

		snprintf(osd_msg, sizeof(osd_msg), "Game VRR Enabled");
		show_hz_osd(m, osd_msg);
		wlr_log(WLR_INFO, "Game VRR enabled on %s", m->wlr_output->name);
	}

	wlr_output_state_finish(&state);
}

/*
 * Disable game VRR mode - returns to fixed refresh rate.
 */
static void
disable_game_vrr(Monitor *m)
{
	struct wlr_output_state state;

	if (!m || !m->game_vrr_active)
		return;

	wlr_output_state_init(&state);
	wlr_output_state_set_adaptive_sync_enabled(&state, 0);

	if (wlr_output_commit_state(m->wlr_output, &state)) {
		wlr_log(WLR_INFO, "Game VRR disabled on %s (was targeting %.1f FPS)",
			m->wlr_output->name, m->game_vrr_target_fps);
	}

	wlr_output_state_finish(&state);

	m->game_vrr_active = 0;
	m->game_vrr_target_fps = 0.0f;
	m->game_vrr_last_fps = 0.0f;
	m->game_vrr_stable_frames = 0;
}

/*
 * Update game VRR based on current measured FPS.
 *
 * This is called from rendermon() when a game is running fullscreen.
 * It implements hysteresis and rate-limiting to avoid jittery behavior.
 */
static void
update_game_vrr(Monitor *m, float current_fps)
{
	uint64_t now_ns;
	float fps_diff;
	float display_max_hz;
	char osd_msg[64];

	if (!m || !m->game_vrr_active)
		return;

	/* Sanity check FPS range */
	if (current_fps < GAME_VRR_MIN_FPS || current_fps > GAME_VRR_MAX_FPS)
		return;

	now_ns = get_time_ns();

	/* Get display's maximum refresh rate */
	if (m->wlr_output->current_mode) {
		display_max_hz = (float)m->wlr_output->current_mode->refresh / 1000.0f;
	} else {
		display_max_hz = 60.0f;
	}

	/* If game is running at or above display refresh, no adjustment needed */
	if (current_fps >= display_max_hz - 2.0f) {
		if (m->game_vrr_target_fps > 0.0f && m->game_vrr_target_fps < display_max_hz - 2.0f) {
			/* Was running slower, now at full speed */
			m->game_vrr_target_fps = display_max_hz;
			m->game_vrr_stable_frames = 0;
			snprintf(osd_msg, sizeof(osd_msg), "VRR: %.0f Hz (full)", display_max_hz);
			show_hz_osd(m, osd_msg);
			wlr_log(WLR_INFO, "Game VRR: back to full refresh %.1f Hz", display_max_hz);
		}
		return;
	}

	/* Calculate difference from current target */
	fps_diff = fabsf(current_fps - m->game_vrr_last_fps);

	/* Check if FPS is stable (within deadband of last reading) */
	if (fps_diff < GAME_VRR_FPS_DEADBAND) {
		m->game_vrr_stable_frames++;
	} else {
		/* FPS changed significantly, reset stability counter */
		m->game_vrr_stable_frames = 0;
		m->game_vrr_last_fps = current_fps;
	}

	/* Only adjust if FPS has been stable for enough frames */
	if (m->game_vrr_stable_frames < GAME_VRR_STABLE_FRAMES)
		return;

	/* Rate limit: don't adjust more than once per interval */
	if (now_ns - m->game_vrr_last_change_ns < GAME_VRR_MIN_INTERVAL_NS)
		return;

	/* Check if we actually need to change the target */
	fps_diff = fabsf(current_fps - m->game_vrr_target_fps);
	if (fps_diff < GAME_VRR_FPS_DEADBAND)
		return;

	/* Update target FPS */
	m->game_vrr_target_fps = current_fps;
	m->game_vrr_last_change_ns = now_ns;
	m->game_vrr_stable_frames = 0;

	/*
	 * With VRR/FreeSync/G-Sync, the display automatically syncs to
	 * the incoming frame rate. We don't need to do anything special
	 * here - just having adaptive sync enabled is enough.
	 *
	 * The key insight is that VRR displays wait for each frame,
	 * so if the game is running at 45 FPS, the display will show
	 * frames at 45 Hz without judder.
	 *
	 * We track the target FPS for:
	 * 1. OSD display feedback to the user
	 * 2. Statistics and debugging
	 * 3. Detecting when to disable VRR (e.g., game exits)
	 */

	snprintf(osd_msg, sizeof(osd_msg), "VRR: %.0f Hz", current_fps);
	show_hz_osd(m, osd_msg);
	wlr_log(WLR_INFO, "Game VRR: adjusted to %.1f FPS on %s",
		current_fps, m->wlr_output->name);
}

/* Check if a client's surface has video content type */
static int
is_video_content(Client *c)
{
	struct wlr_surface *surface;
	enum wp_content_type_v1_type content_type;

	if (!c || !content_type_mgr)
		return 0;

	surface = client_surface(c);
	if (!surface)
		return 0;

	content_type = wlr_surface_get_content_type_v1(content_type_mgr, surface);

	/* Debug: log content type for fullscreen clients */
	static int last_logged_type = -1;
	if (c->isfullscreen && (int)content_type != last_logged_type) {
		const char *type_str = "unknown";
		switch (content_type) {
		case WP_CONTENT_TYPE_V1_TYPE_NONE: type_str = "none"; break;
		case WP_CONTENT_TYPE_V1_TYPE_PHOTO: type_str = "photo"; break;
		case WP_CONTENT_TYPE_V1_TYPE_VIDEO: type_str = "video"; break;
		case WP_CONTENT_TYPE_V1_TYPE_GAME: type_str = "game"; break;
		}
		wlr_log(WLR_DEBUG, "Fullscreen client content-type: %s", type_str);
		last_logged_type = (int)content_type;
	}

	return content_type == WP_CONTENT_TYPE_V1_TYPE_VIDEO;
}

/* Check if a client's surface has game content type */
static int
is_game_content(Client *c)
{
	struct wlr_surface *surface;
	enum wp_content_type_v1_type content_type;

	if (!c || !content_type_mgr)
		return 0;

	surface = client_surface(c);
	if (!surface)
		return 0;

	content_type = wlr_surface_get_content_type_v1(content_type_mgr, surface);
	return content_type == WP_CONTENT_TYPE_V1_TYPE_GAME;
}

/*
 * Check if a client wants tearing (async page flips).
 * Games may request this for lowest latency.
 */
static int
client_wants_tearing(Client *c)
{
	struct wlr_surface *surface;
	enum wp_tearing_control_v1_presentation_hint hint;

	if (!c || !tearing_control_mgr)
		return 0;

	surface = client_surface(c);
	if (!surface)
		return 0;

	hint = wlr_tearing_control_manager_v1_surface_hint_from_surface(
			tearing_control_mgr, surface);

	return hint == WP_TEARING_CONTROL_V1_PRESENTATION_HINT_ASYNC;
}

/*
 * Set output to a refresh rate optimized for video playback.
 * For content-type based detection, we start frame tracking to determine
 * the actual fps, then set custom mode.
 */
static void
set_video_refresh_rate(Monitor *m, Client *c)
{
	if (!m || !m->wlr_output || !m->wlr_output->enabled || !c)
		return;

	/* Don't switch if already in video mode */
	if (m->video_mode_active)
		return;

	/* Check if content type is video */
	if (!is_video_content(c))
		return;

	/* Reset frame tracking to detect actual video Hz */
	c->frame_time_idx = 0;
	c->frame_time_count = 0;
	c->detected_video_hz = 0.0f;

	wlr_log(WLR_INFO, "Video content detected on %s, starting frame rate detection",
			m->wlr_output->name);

	/* Schedule video check to detect fps and set appropriate mode */
	schedule_video_check(500);
}

/* Restore output to maximum refresh rate and disable VRR */
static void
restore_max_refresh_rate(Monitor *m)
{
	struct wlr_output_mode *max_mode;
	struct wlr_output_state state;
	struct wlr_output_configuration_v1 *config;
	struct wlr_output_configuration_head_v1 *config_head;

	if (!m || !m->wlr_output || !m->wlr_output->enabled)
		return;

	/* Disable VRR if active */
	if (m->vrr_active)
		disable_vrr_video_mode(m);

	/* Only restore mode if we're in video mode */
	if (!m->video_mode_active)
		return;

	/* Find best (highest refresh) mode */
	max_mode = bestmode(m->wlr_output);
	if (!max_mode)
		return;

	wlr_log(WLR_INFO, "Restoring %s to max mode: %dx%d@%dmHz",
			m->wlr_output->name, max_mode->width, max_mode->height,
			max_mode->refresh);

	/* Apply the mode */
	wlr_output_state_init(&state);
	wlr_output_state_set_mode(&state, max_mode);
	if (wlr_output_commit_state(m->wlr_output, &state)) {
		m->video_mode_active = 0;
		m->original_mode = NULL;

		/* Broadcast change to output manager */
		config = wlr_output_configuration_v1_create();
		config_head = wlr_output_configuration_head_v1_create(config, m->wlr_output);
		config_head->state.mode = max_mode;
		wlr_output_manager_v1_set_configuration(output_mgr, config);

		/* Show OSD notification */
		{
			char osd_msg[64];
			snprintf(osd_msg, sizeof(osd_msg), "%d.%03d Hz",
					max_mode->refresh / 1000, max_mode->refresh % 1000);
			show_hz_osd(m, osd_msg);
		}
	}
	wlr_output_state_finish(&state);
}

/*
 * ============================================================================
 * HDR AND 10-BIT COLOR SUPPORT
 * ============================================================================
 *
 * This section handles:
 * - Detection of 10-bit and HDR capable monitors
 * - Setting optimal render format (XRGB2101010 for 10-bit, XRGB8888 for 8-bit)
 * - Configuring DRM connector properties for best color output:
 *   - max bpc: Maximum bits per channel (typically 8, 10, 12, or 16)
 *   - Colorspace/output_color_format: RGB 4:4:4 vs YCbCr 4:2:2/4:2:0
 *
 * Note: Full HDR (PQ/BT.2020) requires wlroots with HDR10 support which is
 * still pending merge (MR !5002). This code prepares the infrastructure.
 */

/*
 * Check if an output supports 10-bit or higher color depth.
 * This queries the DRM connector's max bpc property and supported formats.
 */
static int
detect_10bit_support(Monitor *m)
{
	const struct wlr_drm_format_set *formats;
	const struct wlr_drm_format *fmt;
	int has_10bit = 0;

	if (!m || !m->wlr_output)
		return 0;

	/* Check primary plane formats for 10-bit support */
	formats = wlr_output_get_primary_formats(m->wlr_output, WLR_BUFFER_CAP_DMABUF);
	if (formats) {
		/* Look for XRGB2101010 or XBGR2101010 (10-bit RGB formats) */
		fmt = wlr_drm_format_set_get(formats, DRM_FORMAT_XRGB2101010);
		if (fmt) {
			has_10bit = 1;
			wlr_log(WLR_INFO, "Monitor %s supports DRM_FORMAT_XRGB2101010 (10-bit)",
				m->wlr_output->name);
		}

		fmt = wlr_drm_format_set_get(formats, DRM_FORMAT_XBGR2101010);
		if (fmt) {
			has_10bit = 1;
			wlr_log(WLR_INFO, "Monitor %s supports DRM_FORMAT_XBGR2101010 (10-bit)",
				m->wlr_output->name);
		}

		/* Also check for ARGB2101010 (10-bit with alpha) */
		fmt = wlr_drm_format_set_get(formats, DRM_FORMAT_ARGB2101010);
		if (fmt) {
			has_10bit = 1;
			wlr_log(WLR_INFO, "Monitor %s supports DRM_FORMAT_ARGB2101010 (10-bit+alpha)",
				m->wlr_output->name);
		}
	}

	return has_10bit;
}

/*
 * Set DRM connector properties for optimal color output.
 * This sets:
 * - max bpc: Maximum bits per channel (10 for 10-bit, 12 for HDR, etc.)
 * - Colorspace: BT709/BT2020 (for HDR)
 *
 * Note: These are low-level DRM properties, accessed via libdrm.
 */
static int
set_drm_color_properties(Monitor *m, int max_bpc)
{
	int drm_fd;
	uint32_t conn_id;
	drmModeConnector *conn = NULL;
	drmModePropertyRes *prop = NULL;
	int i;
	int success = 0;

	if (!m || !m->wlr_output || !wlr_output_is_drm(m->wlr_output))
		return 0;

	/* Get DRM fd from renderer */
	drm_fd = wlr_renderer_get_drm_fd(drw);
	if (drm_fd < 0) {
		wlr_log(WLR_DEBUG, "Cannot get DRM fd for color properties");
		return 0;
	}

	/* Get connector ID from wlroots */
	conn_id = wlr_drm_connector_get_id(m->wlr_output);
	if (conn_id == 0) {
		wlr_log(WLR_DEBUG, "Cannot get DRM connector ID for %s", m->wlr_output->name);
		return 0;
	}

	/* Get connector to access properties */
	conn = drmModeGetConnector(drm_fd, conn_id);
	if (!conn) {
		wlr_log(WLR_DEBUG, "Cannot get DRM connector %u", conn_id);
		return 0;
	}

	/* Find and set max bpc property */
	for (i = 0; i < conn->count_props; i++) {
		prop = drmModeGetProperty(drm_fd, conn->props[i]);
		if (!prop)
			continue;

		if (strcmp(prop->name, "max bpc") == 0) {
			/* Check if requested bpc is within range */
			if (prop->flags & DRM_MODE_PROP_RANGE) {
				uint64_t min_bpc = prop->values[0];
				uint64_t max_supported_bpc = prop->values[1];

				if (max_bpc < (int)min_bpc)
					max_bpc = (int)min_bpc;
				if (max_bpc > (int)max_supported_bpc)
					max_bpc = (int)max_supported_bpc;

				if (drmModeConnectorSetProperty(drm_fd, conn_id,
						conn->props[i], max_bpc) == 0) {
					wlr_log(WLR_INFO, "Set max bpc to %d for %s (supports %lu-%lu)",
						max_bpc, m->wlr_output->name, min_bpc, max_supported_bpc);
					m->max_bpc = max_bpc;
					success = 1;
				} else {
					wlr_log(WLR_ERROR, "Failed to set max bpc to %d for %s",
						max_bpc, m->wlr_output->name);
				}
			}
			drmModeFreeProperty(prop);
			break;
		}
		drmModeFreeProperty(prop);
	}

	/* Also look for Colorspace or output_color_format property for RGB full */
	for (i = 0; i < conn->count_props; i++) {
		prop = drmModeGetProperty(drm_fd, conn->props[i]);
		if (!prop)
			continue;

		/* AMD uses "Colorspace", Intel uses "output_colorspace" */
		if (strcmp(prop->name, "Colorspace") == 0 ||
		    strcmp(prop->name, "output_colorspace") == 0) {
			/* Try to find RGB_Wide_Fixed or Default (RGB full range) */
			if (prop->flags & DRM_MODE_PROP_ENUM) {
				int j;
				uint64_t rgb_value = 0; /* Default is usually 0 */

				for (j = 0; j < prop->count_enums; j++) {
					/* Prefer Default or RGB_Wide_Fixed for best color */
					if (strcmp(prop->enums[j].name, "Default") == 0 ||
					    strcmp(prop->enums[j].name, "RGB_Wide_Fixed") == 0) {
						rgb_value = prop->enums[j].value;
						break;
					}
				}

				if (drmModeConnectorSetProperty(drm_fd, conn_id,
						conn->props[i], rgb_value) == 0) {
					wlr_log(WLR_INFO, "Set colorspace to RGB for %s",
						m->wlr_output->name);
				}
			}
			drmModeFreeProperty(prop);
			break;
		}
		drmModeFreeProperty(prop);
	}

	drmModeFreeConnector(conn);
	return success;
}

/*
 * Enable 10-bit rendering for a monitor.
 * This sets the render format to XRGB2101010 for better color gradients.
 */
static int
enable_10bit_rendering(Monitor *m)
{
	struct wlr_output_state state;
	int success = 0;

	if (!m || !m->wlr_output || !m->wlr_output->enabled)
		return 0;

	if (!m->supports_10bit) {
		wlr_log(WLR_DEBUG, "Monitor %s does not support 10-bit", m->wlr_output->name);
		return 0;
	}

	if (m->render_10bit_active) {
		wlr_log(WLR_DEBUG, "10-bit already active on %s", m->wlr_output->name);
		return 1;
	}

	wlr_output_state_init(&state);
	wlr_output_state_set_render_format(&state, DRM_FORMAT_XRGB2101010);

	if (wlr_output_test_state(m->wlr_output, &state)) {
		if (wlr_output_commit_state(m->wlr_output, &state)) {
			m->render_10bit_active = 1;
			success = 1;
			wlr_log(WLR_INFO, "Enabled 10-bit rendering on %s", m->wlr_output->name);

			/* Also set max bpc to 10 via DRM */
			set_drm_color_properties(m, 10);

			/* Show notification */
			toast_show(m, "10-bit color", 1500);
		} else {
			wlr_log(WLR_ERROR, "Failed to commit 10-bit state on %s", m->wlr_output->name);
		}
	} else {
		wlr_log(WLR_DEBUG, "10-bit render format not supported by backend on %s",
			m->wlr_output->name);
	}

	wlr_output_state_finish(&state);
	return success;
}

/*
 * Initialize HDR and color depth settings for a new monitor.
 * Called from createmon() after the output is initialized.
 */
static void
init_monitor_color_settings(Monitor *m)
{
	if (!m || !m->wlr_output)
		return;

	/* Detect capabilities */
	m->supports_10bit = detect_10bit_support(m);
	m->render_10bit_active = 0;
	m->max_bpc = 8;  /* Default */
	m->hdr_capable = 0;  /* Will be set when wlroots gets HDR support */
	m->hdr_active = 0;

	wlr_log(WLR_INFO, "Monitor %s: 10-bit=%s, HDR=%s",
		m->wlr_output->name,
		m->supports_10bit ? "yes" : "no",
		m->hdr_capable ? "yes" : "no");

	/*
	 * Automatically enable 10-bit rendering if supported.
	 * This provides smoother gradients and better color accuracy.
	 */
	if (m->supports_10bit) {
		/* Try to enable 10-bit - if it fails, we fall back to 8-bit automatically */
		enable_10bit_rendering(m);
	}

	/*
	 * Always try to set max bpc even if 10-bit rendering isn't available.
	 * This ensures we're using the best color depth the display link supports.
	 */
	if (wlr_output_is_drm(m->wlr_output)) {
		int target_bpc = m->supports_10bit ? 10 : 8;
		set_drm_color_properties(m, target_bpc);
	}
}

/* Track frame commit timestamp for a client (only when buffer changes) */
static void
track_client_frame(Client *c)
{
	struct wlr_surface *surface;
	struct wlr_buffer *current_buffer;
	uint64_t now;
	static int log_count = 0;

	if (!c)
		return;

	surface = client_surface(c);
	if (!surface)
		return;

	/*
	 * Only track when the buffer actually changes. On high refresh rate
	 * monitors, compositors may re-commit the same buffer multiple times
	 * per video frame. By tracking buffer changes, we measure actual
	 * content updates rather than compositor refresh rate.
	 *
	 * We use the wlr_client_buffer pointer as an opaque identifier - when
	 * a new buffer is attached, the pointer changes.
	 */
	current_buffer = (struct wlr_buffer *)surface->buffer;
	if (current_buffer == c->last_buffer)
		return;

	c->last_buffer = current_buffer;
	now = monotonic_msec();

	/* Log interval for debugging */
	if (c->frame_time_count > 0 && log_count < 20) {
		int prev_idx = (c->frame_time_idx - 1 + 32) % 32;
		uint64_t interval = now - c->frame_times[prev_idx];
		wlr_log(WLR_INFO, "Frame buffer change: interval=%lums (%.1f fps)",
				(unsigned long)interval, 1000.0 / interval);
		log_count++;
	}

	c->frame_times[c->frame_time_idx] = now;
	c->frame_time_idx = (c->frame_time_idx + 1) % 32;
	if (c->frame_time_count < 32)
		c->frame_time_count++;
}

/*
 * Analyze frame times to detect exact video framerate.
 * Returns exact Hz value (e.g., 23.976, 29.97, 59.94) or 0.0 if not video.
 * Inspired by Gamescope's approach of calculating precise frame timing.
 */
static float
detect_video_framerate(Client *c)
{
	int i, count, valid_intervals;
	uint64_t intervals[31];
	double avg_interval;
	uint64_t sum = 0;
	uint64_t variance_sum = 0;
	double variance, stddev;
	double exact_hz;

	if (!c || c->frame_time_count < 12)
		return 0.0f;

	count = c->frame_time_count;
	valid_intervals = 0;

	/* Calculate intervals between frames */
	for (i = 1; i < count; i++) {
		int prev_idx = (c->frame_time_idx - count + i - 1 + 32) % 32;
		int curr_idx = (c->frame_time_idx - count + i + 32) % 32;
		uint64_t interval = c->frame_times[curr_idx] - c->frame_times[prev_idx];

		/* Filter out unreasonable intervals (< 5ms or > 200ms) */
		if (interval >= 5 && interval <= 200) {
			intervals[valid_intervals++] = interval;
			sum += interval;
		}
	}

	if (valid_intervals < 8)
		return 0.0f;

	avg_interval = (double)sum / valid_intervals;

	/* Calculate variance to check for stable frame rate */
	for (i = 0; i < valid_intervals; i++) {
		int64_t diff = (int64_t)intervals[i] - (int64_t)(avg_interval + 0.5);
		variance_sum += (uint64_t)(diff * diff);
	}
	variance = (double)variance_sum / valid_intervals;
	stddev = sqrt(variance);

	/* If standard deviation is more than 30% of mean, not stable enough */
	if (stddev > avg_interval * 0.30) {
		wlr_log(WLR_DEBUG, "Frame rate detection: stddev=%.2f (%.1f%%) too high for avg_interval=%.2fms",
				stddev, (stddev / avg_interval) * 100.0, avg_interval);
		return 0.0f;
	}

	/* Calculate exact Hz from average interval */
	exact_hz = 1000.0 / avg_interval;

	wlr_log(WLR_DEBUG, "Frame rate detection: avg_interval=%.3fms -> %.3f Hz (stddev=%.2f)",
			avg_interval, exact_hz, stddev);

	/*
	 * Map to exact standard framerates if within tolerance.
	 * This accounts for the 1000/1001 pulldown used in NTSC standards.
	 */
	/* 23.976 Hz (24000/1001) - Film NTSC pulldown */
	if (exact_hz >= 23.5 && exact_hz <= 24.5) {
		if (exact_hz < 24.0)
			return 23.976f;
		return 24.0f;
	}
	/* 25 Hz - PAL */
	if (exact_hz >= 24.5 && exact_hz <= 25.5)
		return 25.0f;
	/* 29.97 Hz (30000/1001) - NTSC */
	if (exact_hz >= 29.5 && exact_hz <= 30.5) {
		if (exact_hz < 30.0)
			return 29.97f;
		return 30.0f;
	}
	/* 47.952 Hz (48000/1001) - 2x Film NTSC */
	if (exact_hz >= 47.5 && exact_hz <= 48.5) {
		if (exact_hz < 48.0)
			return 47.952f;
		return 48.0f;
	}
	/* 50 Hz - PAL high frame rate */
	if (exact_hz >= 49.5 && exact_hz <= 50.5)
		return 50.0f;
	/* 59.94 Hz (60000/1001) - NTSC high frame rate */
	if (exact_hz >= 59.0 && exact_hz <= 60.5) {
		if (exact_hz < 60.0)
			return 59.94f;
		return 60.0f;
	}
	/* 119.88 Hz (120000/1001) */
	if (exact_hz >= 119.0 && exact_hz <= 120.5) {
		if (exact_hz < 120.0)
			return 119.88f;
		return 120.0f;
	}

	/* If not a standard rate but stable, return the exact measured value */
	if (exact_hz >= 10.0 && exact_hz <= 240.0) {
		wlr_log(WLR_INFO, "Non-standard framerate detected: %.3f Hz", exact_hz);
		return (float)exact_hz;
	}

	return 0.0f;
}

/*
 * Video playback quality scoring system.
 * Higher score = better quality (smoother playback, less judder).
 *
 * Score components:
 * - Perfect sync (integer multiple): 100 points base
 * - VRR: 150 points (best possible - true frame-by-frame sync)
 * - Lower multiplier: bonus (2x > 3x > 4x)
 * - Precision penalty: deduct for non-exact matches
 */
typedef struct {
	int method;              /* 0=none, 1=existing_mode, 2=custom_cvt, 3=vrr */
	struct wlr_output_mode *mode;
	int multiplier;
	float target_hz;
	float actual_hz;
	float score;
	float judder_ms;         /* estimated judder per frame in ms */
} VideoModeCandidate;

/*
 * Calculate judder (frame timing error) for a given mode/video Hz combination.
 * Returns estimated judder in milliseconds per frame.
 * 0 = perfect sync (integer multiple or VRR)
 */
static float
calculate_judder_ms(float video_hz, float display_hz)
{
	if (video_hz <= 0.0f || display_hz <= 0.0f)
		return 999.0f;

	float ratio = display_hz / video_hz;
	int nearest_multiple = (int)(ratio + 0.5f);

	if (nearest_multiple < 1)
		nearest_multiple = 1;

	float perfect_hz = video_hz * nearest_multiple;
	float hz_error = fabsf(display_hz - perfect_hz);

	/* Convert Hz error to timing error per frame */
	float frame_period_ms = 1000.0f / video_hz;
	float timing_error_ratio = hz_error / display_hz;

	return frame_period_ms * timing_error_ratio;
}

/*
 * Score a video mode candidate. Higher score = better.
 */
static float
score_video_mode(int method, float video_hz, float display_hz, int multiplier)
{
	float score = 0.0f;
	float judder = calculate_judder_ms(video_hz, display_hz);

	switch (method) {
	case 3: /* VRR - best possible */
		score = 150.0f;
		break;
	case 1: /* Existing mode - good if it's a perfect multiple */
	case 2: /* Custom CVT mode */
		if (judder < 0.1f) {
			/* Near-perfect sync */
			score = 100.0f;
			/* Bonus for lower multiplier (less frame repeats) */
			score += (10 - multiplier) * 2.0f;
		} else {
			/* Imperfect sync - penalize heavily */
			score = 50.0f - judder * 10.0f;
		}
		break;
	default:
		score = 0.0f;
	}

	return score;
}

/*
 * Find the absolute best video mode for the given framerate.
 * Evaluates ALL options and returns the one with highest quality score.
 *
 * Priority (by quality):
 * 1. VRR if available - true judder-free
 * 2. Exact integer multiple mode (120Hz for 24fps, etc)
 * 3. Custom CVT mode at exact multiple
 * 4. Closest available mode
 */
static VideoModeCandidate
find_best_video_mode(Monitor *m, float video_hz)
{
	VideoModeCandidate best = {0};
	VideoModeCandidate candidate;
	struct wlr_output_mode *mode;
	int width, height;

	best.score = -1.0f;
	best.judder_ms = 999.0f;
	best.target_hz = video_hz;

	if (!m || !m->wlr_output || !m->wlr_output->current_mode || video_hz <= 0.0f)
		return best;

	width = m->wlr_output->current_mode->width;
	height = m->wlr_output->current_mode->height;

	wlr_log(WLR_INFO, "Evaluating video modes for %.3f Hz on %s:", video_hz, m->wlr_output->name);

	/* Option 1: VRR (best quality if available) */
	if (m->vrr_capable && fullscreen_adaptive_sync_enabled) {
		candidate.method = 3;
		candidate.mode = NULL;
		candidate.multiplier = 1;
		candidate.target_hz = video_hz;
		candidate.actual_hz = video_hz;
		candidate.judder_ms = 0.0f;
		candidate.score = score_video_mode(3, video_hz, video_hz, 1);

		wlr_log(WLR_INFO, "  VRR: score=%.1f (judder=0ms)", candidate.score);

		if (candidate.score > best.score) {
			best = candidate;
		}
	}

	/* Option 2: Scan existing modes for integer multiples */
	wl_list_for_each(mode, &m->wlr_output->modes, link) {
		if (mode->width != width || mode->height != height)
			continue;

		float mode_hz = mode->refresh / 1000.0f;
		float ratio = mode_hz / video_hz;
		int multiple = (int)(ratio + 0.5f);

		if (multiple < 1 || multiple > 8)
			continue;

		float expected_hz = video_hz * multiple;
		float diff = fabsf(mode_hz - expected_hz);

		/* Only consider if within 0.5% tolerance */
		if (diff > expected_hz * 0.005f)
			continue;

		candidate.method = 1;
		candidate.mode = mode;
		candidate.multiplier = multiple;
		candidate.target_hz = video_hz;
		candidate.actual_hz = mode_hz;
		candidate.judder_ms = calculate_judder_ms(video_hz, mode_hz);
		candidate.score = score_video_mode(1, video_hz, mode_hz, multiple);

		wlr_log(WLR_INFO, "  Mode %d.%03dHz: %dx mult, score=%.1f, judder=%.2fms",
				mode->refresh / 1000, mode->refresh % 1000,
				multiple, candidate.score, candidate.judder_ms);

		if (candidate.score > best.score) {
			best = candidate;
		}
	}

	/* Option 3: Check if CVT custom modes could work (score them theoretically) */
	for (int mult = 1; mult <= 5; mult++) {
		float target_display_hz = video_hz * mult;

		/* Skip if below typical panel minimum or above maximum */
		if (target_display_hz < 48.0f || target_display_hz > 240.0f)
			continue;

		/* Check if we already found this rate in existing modes */
		int found = 0;
		wl_list_for_each(mode, &m->wlr_output->modes, link) {
			if (mode->width != width || mode->height != height)
				continue;
			float mode_hz = mode->refresh / 1000.0f;
			if (fabsf(mode_hz - target_display_hz) < 0.5f) {
				found = 1;
				break;
			}
		}

		if (!found && wlr_output_is_drm(m->wlr_output)) {
			candidate.method = 2;
			candidate.mode = NULL;
			candidate.multiplier = mult;
			candidate.target_hz = video_hz;
			candidate.actual_hz = target_display_hz;
			candidate.judder_ms = 0.0f; /* Custom CVT will be exact */
			candidate.score = score_video_mode(2, video_hz, target_display_hz, mult);

			/* Slightly penalize CVT modes as they're less reliable */
			candidate.score -= 5.0f;

			wlr_log(WLR_INFO, "  CVT %.3fHz: %dx mult, score=%.1f (theoretical)",
					target_display_hz, mult, candidate.score);

			if (candidate.score > best.score) {
				best = candidate;
			}
		}
	}

	if (best.score > 0) {
		const char *method_str = "none";
		switch (best.method) {
		case 1: method_str = "existing mode"; break;
		case 2: method_str = "custom CVT"; break;
		case 3: method_str = "VRR"; break;
		}
		wlr_log(WLR_INFO, "Best option: %s at %.3f Hz (%dx), score=%.1f, judder=%.2fms",
				method_str, best.actual_hz, best.multiplier, best.score, best.judder_ms);
	}

	return best;
}

/*
 * Find a mode that is an integer multiple of the target Hz.
 * For example, 23.976 Hz video looks smooth at 47.952 Hz, 71.928 Hz, 119.88 Hz, etc.
 * Returns NULL if no suitable mode found.
 */
static struct wlr_output_mode *
find_video_friendly_mode(Monitor *m, float target_hz)
{
	struct wlr_output_mode *mode, *best = NULL;
	int width, height;
	float best_diff = 999.0f;

	if (!m || !m->wlr_output || !m->wlr_output->current_mode || target_hz <= 0.0f)
		return NULL;

	width = m->wlr_output->current_mode->width;
	height = m->wlr_output->current_mode->height;

	wl_list_for_each(mode, &m->wlr_output->modes, link) {
		/* Must match current resolution */
		if (mode->width != width || mode->height != height)
			continue;

		float mode_hz = mode->refresh / 1000.0f;

		/* Check if this refresh rate is an integer multiple of target Hz */
		float ratio = mode_hz / target_hz;
		int multiple = (int)(ratio + 0.5f);

		if (multiple >= 1 && multiple <= 8) {
			float expected_hz = target_hz * multiple;
			float diff = fabsf(mode_hz - expected_hz);

			/* Allow 0.5% tolerance for fractional rates */
			if (diff < expected_hz * 0.005f && diff < best_diff) {
				best = mode;
				best_diff = diff;
			}
		}
	}

	return best;
}

/*
 * Enable VRR mode for judder-free video playback.
 * With VRR, frames are displayed exactly when ready - no need to match refresh rate.
 * Returns 1 on success, 0 on failure.
 */
static int
enable_vrr_video_mode(Monitor *m, float video_hz)
{
	struct wlr_output_state state;
	struct wlr_output_configuration_v1 *config;
	struct wlr_output_configuration_head_v1 *config_head;
	char osd_msg[64];

	if (!m || !m->wlr_output || !m->wlr_output->enabled)
		return 0;

	if (!m->vrr_capable) {
		wlr_log(WLR_DEBUG, "Monitor %s does not support VRR", m->wlr_output->name);
		return 0;
	}

	if (!fullscreen_adaptive_sync_enabled) {
		wlr_log(WLR_DEBUG, "Adaptive sync disabled by user");
		return 0;
	}

	/* Save original mode before first switch */
	if (!m->video_mode_active && !m->vrr_active)
		m->original_mode = m->wlr_output->current_mode;

	wlr_log(WLR_INFO, "Enabling VRR for %.3f Hz video on %s",
			video_hz, m->wlr_output->name);

	/* Enable adaptive sync */
	wlr_output_state_init(&state);
	wlr_output_state_set_adaptive_sync_enabled(&state, 1);

	if (wlr_output_test_state(m->wlr_output, &state)) {
		if (wlr_output_commit_state(m->wlr_output, &state)) {
			m->vrr_active = 1;
			m->vrr_target_hz = video_hz;

			/* Broadcast state change */
			config = wlr_output_configuration_v1_create();
			config_head = wlr_output_configuration_head_v1_create(config, m->wlr_output);
			config_head->state.adaptive_sync_enabled = 1;
			wlr_output_manager_v1_set_configuration(output_mgr, config);

			wlr_log(WLR_INFO, "VRR enabled for %.3f Hz video - judder-free playback",
					video_hz);

			/* Show OSD */
			snprintf(osd_msg, sizeof(osd_msg), "VRR %.3f Hz", video_hz);
			show_hz_osd(m, osd_msg);

			wlr_output_state_finish(&state);
			return 1;
		}
	}

	wlr_output_state_finish(&state);
	wlr_log(WLR_DEBUG, "Failed to enable VRR on %s", m->wlr_output->name);
	return 0;
}

/*
 * Disable VRR mode and restore normal operation.
 */
static void
disable_vrr_video_mode(Monitor *m)
{
	struct wlr_output_state state;
	struct wlr_output_configuration_v1 *config;
	struct wlr_output_configuration_head_v1 *config_head;

	if (!m || !m->wlr_output || !m->wlr_output->enabled || !m->vrr_active)
		return;

	wlr_log(WLR_INFO, "Disabling VRR on %s", m->wlr_output->name);

	wlr_output_state_init(&state);
	wlr_output_state_set_adaptive_sync_enabled(&state, 0);

	if (wlr_output_commit_state(m->wlr_output, &state)) {
		m->vrr_active = 0;
		m->vrr_target_hz = 0.0f;

		config = wlr_output_configuration_v1_create();
		config_head = wlr_output_configuration_head_v1_create(config, m->wlr_output);
		config_head->state.adaptive_sync_enabled = 0;
		wlr_output_manager_v1_set_configuration(output_mgr, config);
	}

	wlr_output_state_finish(&state);
}

/*
 * Apply the best video mode based on scoring evaluation.
 * This is the main entry point for automatic video mode selection.
 * Returns 1 on success, 0 on failure.
 */
static int
apply_best_video_mode(Monitor *m, float video_hz)
{
	VideoModeCandidate best;
	struct wlr_output_state state;
	struct wlr_output_configuration_v1 *config;
	struct wlr_output_configuration_head_v1 *config_head;
	drmModeModeInfo drm_mode;
	struct wlr_output_mode *new_mode;
	char osd_msg[64];
	int success = 0;

	if (!m || !m->wlr_output || !m->wlr_output->enabled || video_hz <= 0.0f)
		return 0;

	/* Find the best option using scoring system */
	best = find_best_video_mode(m, video_hz);

	if (best.score <= 0) {
		wlr_log(WLR_ERROR, "No suitable video mode found for %.3f Hz", video_hz);
		show_hz_osd(m, "No compatible mode");
		return 0;
	}

	/* Save original mode before first switch */
	if (!m->video_mode_active && !m->vrr_active)
		m->original_mode = m->wlr_output->current_mode;

	switch (best.method) {
	case 3: /* VRR - best option */
		success = enable_vrr_video_mode(m, video_hz);
		break;

	case 1: /* Existing mode */
		if (!best.mode) {
			wlr_log(WLR_ERROR, "Best method is existing mode but no mode set");
			break;
		}

		wlr_output_state_init(&state);
		wlr_output_state_set_mode(&state, best.mode);

		if (wlr_output_test_state(m->wlr_output, &state) &&
		    wlr_output_commit_state(m->wlr_output, &state)) {
			m->video_mode_active = 1;
			success = 1;

			config = wlr_output_configuration_v1_create();
			config_head = wlr_output_configuration_head_v1_create(config, m->wlr_output);
			config_head->state.mode = best.mode;
			wlr_output_manager_v1_set_configuration(output_mgr, config);

			/* Show OSD */
			if (best.multiplier > 1) {
				snprintf(osd_msg, sizeof(osd_msg), "%d.%03d Hz (%dx%.0f)",
						best.mode->refresh / 1000, best.mode->refresh % 1000,
						best.multiplier, video_hz);
			} else {
				snprintf(osd_msg, sizeof(osd_msg), "%d.%03d Hz",
						best.mode->refresh / 1000, best.mode->refresh % 1000);
			}
			show_hz_osd(m, osd_msg);

			wlr_log(WLR_INFO, "Applied existing mode %d.%03d Hz for %.3f Hz video",
					best.mode->refresh / 1000, best.mode->refresh % 1000, video_hz);
		}
		wlr_output_state_finish(&state);
		break;

	case 2: /* Custom CVT mode */
		if (!wlr_output_is_drm(m->wlr_output)) {
			wlr_log(WLR_ERROR, "CVT mode requires DRM output");
			break;
		}

		/* Generate CVT mode */
		generate_cvt_mode(&drm_mode,
				m->wlr_output->current_mode->width,
				m->wlr_output->current_mode->height,
				best.actual_hz);

		new_mode = wlr_drm_connector_add_mode(m->wlr_output, &drm_mode);
		if (!new_mode) {
			wlr_log(WLR_ERROR, "Failed to add CVT mode for %.3f Hz", best.actual_hz);
			break;
		}

		wlr_output_state_init(&state);
		wlr_output_state_set_mode(&state, new_mode);

		if (wlr_output_test_state(m->wlr_output, &state) &&
		    wlr_output_commit_state(m->wlr_output, &state)) {
			m->video_mode_active = 1;
			success = 1;

			config = wlr_output_configuration_v1_create();
			config_head = wlr_output_configuration_head_v1_create(config, m->wlr_output);
			config_head->state.mode = new_mode;
			wlr_output_manager_v1_set_configuration(output_mgr, config);

			/* Show OSD */
			int actual_mhz = (int)(best.actual_hz * 1000.0f + 0.5f);
			int source_mhz = (int)(video_hz * 1000.0f + 0.5f);
			if (best.multiplier > 1) {
				snprintf(osd_msg, sizeof(osd_msg), "%d.%03d Hz (%dx %d.%03d)",
						actual_mhz / 1000, actual_mhz % 1000,
						best.multiplier,
						source_mhz / 1000, source_mhz % 1000);
			} else {
				snprintf(osd_msg, sizeof(osd_msg), "%d.%03d Hz",
						actual_mhz / 1000, actual_mhz % 1000);
			}
			show_hz_osd(m, osd_msg);

			wlr_log(WLR_INFO, "Applied CVT mode %.3f Hz for %.3f Hz video",
					best.actual_hz, video_hz);
		}
		wlr_output_state_finish(&state);
		break;
	}

	if (!success) {
		wlr_log(WLR_ERROR, "Failed to apply best video mode (method=%d, hz=%.3f)",
				best.method, best.actual_hz);
	}

	return success;
}

/*
 * Set optimal video mode using intelligent prioritization:
 * 1. VRR (Variable Refresh Rate) - best option, true judder-free
 * 2. Exact mode match (integer multiple of video Hz)
 * 3. Custom CVT mode generation
 *
 * Returns 1 on success, 0 on failure.
 */
static int
set_custom_video_mode(Monitor *m, float exact_hz)
{
	struct wlr_output_state state;
	struct wlr_output_configuration_v1 *config;
	struct wlr_output_configuration_head_v1 *config_head;
	struct wlr_output_mode *new_mode, *friendly_mode;
	drmModeModeInfo drm_mode;
	int width, height;
	float actual_hz;
	int multiplier;
	int success = 0;
	char osd_msg[64];

	if (!m || !m->wlr_output || !m->wlr_output->enabled || !m->wlr_output->current_mode)
		return 0;

	if (exact_hz <= 0.0f)
		return 0;

	/*
	 * PRIORITY 1: Try VRR first - the best solution for judder-free video.
	 * With VRR, the display adapts to each frame, so we don't need to match
	 * refresh rates at all. This is how high-end displays handle video.
	 */
	if (m->vrr_capable && enable_vrr_video_mode(m, exact_hz)) {
		wlr_log(WLR_INFO, "Using VRR for %.3f Hz video - optimal solution", exact_hz);
		return 1;
	}

	/* Check if this is a DRM output - needed for mode switching */
	if (!wlr_output_is_drm(m->wlr_output)) {
		wlr_log(WLR_INFO, "Output is not DRM, cannot change mode");
		return 0;
	}

	/* Save original mode before first switch */
	if (!m->video_mode_active)
		m->original_mode = m->wlr_output->current_mode;

	width = m->wlr_output->current_mode->width;
	height = m->wlr_output->current_mode->height;

	/*
	 * PRIORITY 2: Check if there's an existing mode that's a multiple of video Hz.
	 * Many displays have modes like 120Hz which work perfectly for 24Hz content.
	 */
	friendly_mode = find_video_friendly_mode(m, exact_hz);
	if (friendly_mode) {
		wlr_output_state_init(&state);
		wlr_output_state_set_mode(&state, friendly_mode);

		if (wlr_output_test_state(m->wlr_output, &state)) {
			if (wlr_output_commit_state(m->wlr_output, &state)) {
				success = 1;
				m->video_mode_active = 1;
				actual_hz = friendly_mode->refresh / 1000.0f;
				multiplier = (int)(actual_hz / exact_hz + 0.5f);

				config = wlr_output_configuration_v1_create();
				config_head = wlr_output_configuration_head_v1_create(config, m->wlr_output);
				config_head->state.mode = friendly_mode;
				wlr_output_manager_v1_set_configuration(output_mgr, config);

				wlr_log(WLR_INFO, "Using existing mode %d.%03d Hz for %.3f Hz video (%dx)",
						friendly_mode->refresh / 1000, friendly_mode->refresh % 1000,
						exact_hz, multiplier);

				/* Show OSD */
				snprintf(osd_msg, sizeof(osd_msg), "%d.%03d Hz (%dx%.0f)",
						friendly_mode->refresh / 1000, friendly_mode->refresh % 1000,
						multiplier, exact_hz);
				show_hz_osd(m, osd_msg);

				wlr_output_state_finish(&state);
				return 1;
			}
		}
		wlr_output_state_finish(&state);
	}

	/*
	 * PRIORITY 3: Generate custom CVT mode.
	 * Multiply Hz to stay above panel minimum (typically 48 Hz).
	 */
	multiplier = 1;
	if (exact_hz < 48.0f) {
		multiplier = (int)ceilf(48.0f / exact_hz);
	}

	wlr_log(WLR_INFO, "Video mode: no VRR, no friendly mode, trying CVT at %dx multiplier",
			multiplier);

	for (; multiplier <= 8 && !success; multiplier++) {
		actual_hz = exact_hz * multiplier;

		/* Skip if above typical maximum */
		if (actual_hz > 300.0f)
			break;

		wlr_log(WLR_INFO, "Video mode: trying %.3f Hz -> %.3f Hz (%dx multiplier)",
				exact_hz, actual_hz, multiplier);

		/* Generate CVT mode with exact timing parameters */
		generate_cvt_mode(&drm_mode, width, height, actual_hz);

		/* Add custom mode to DRM connector */
		new_mode = wlr_drm_connector_add_mode(m->wlr_output, &drm_mode);
		if (!new_mode) {
			wlr_log(WLR_DEBUG, "wlr_drm_connector_add_mode failed for %.3f Hz", actual_hz);
			continue;
		}

		wlr_log(WLR_INFO, "Added custom mode: %dx%d@%d mHz",
				new_mode->width, new_mode->height, new_mode->refresh);

		/* Try to apply the new mode */
		wlr_output_state_init(&state);
		wlr_output_state_set_mode(&state, new_mode);

		if (wlr_output_test_state(m->wlr_output, &state)) {
			if (wlr_output_commit_state(m->wlr_output, &state)) {
				success = 1;
				m->video_mode_active = 1;

				config = wlr_output_configuration_v1_create();
				config_head = wlr_output_configuration_head_v1_create(config, m->wlr_output);
				config_head->state.mode = new_mode;
				wlr_output_manager_v1_set_configuration(output_mgr, config);

				wlr_log(WLR_INFO, "Custom mode %.3f Hz applied for %.3f Hz video (%dx)",
						actual_hz, exact_hz, multiplier);
			} else {
				wlr_log(WLR_DEBUG, "wlr_output_commit_state failed for %.3f Hz", actual_hz);
			}
		} else {
			wlr_log(WLR_DEBUG, "wlr_output_test_state failed for %.3f Hz", actual_hz);
		}
		wlr_output_state_finish(&state);
	}

	/* Show OSD notification */
	if (success) {
		int actual_mhz = (int)(actual_hz * 1000.0f + 0.5f);
		int source_mhz = (int)(exact_hz * 1000.0f + 0.5f);
		if (multiplier > 1) {
			snprintf(osd_msg, sizeof(osd_msg), "%d.%03d Hz (%dx %d.%03d)",
					actual_mhz / 1000, actual_mhz % 1000,
					multiplier,
					source_mhz / 1000, source_mhz % 1000);
		} else {
			snprintf(osd_msg, sizeof(osd_msg), "%d.%03d Hz",
					actual_mhz / 1000, actual_mhz % 1000);
		}
		show_hz_osd(m, osd_msg);
	} else {
		wlr_log(WLR_ERROR, "Failed to set video mode for %.3f Hz (VRR: %s, no friendly modes)",
				exact_hz, m->vrr_capable ? "unavailable" : "not supported");
	}

	return success;
}

/* Timer callback to check fullscreen clients for video content */
static int
video_check_timeout(void *data)
{
	(void)data;
	check_fullscreen_video();
	return 0;
}

/* Schedule video check timer */
static void
schedule_video_check(uint32_t ms)
{
	if (!event_loop)
		return;
	if (!video_check_timer)
		video_check_timer = wl_event_loop_add_timer(event_loop,
				video_check_timeout, NULL);
	if (video_check_timer)
		wl_event_source_timer_update(video_check_timer, ms);
}

/* Hz OSD - show refresh rate change notification */
static int
hz_osd_timeout(void *data)
{
	Monitor *m;
	(void)data;

	wl_list_for_each(m, &mons, link) {
		if (m->hz_osd_visible)
			hide_hz_osd(m);
	}
	return 0;
}

static void
hide_hz_osd(Monitor *m)
{
	if (!m || !m->hz_osd_tree)
		return;

	m->hz_osd_visible = 0;
	wlr_scene_node_set_enabled(&m->hz_osd_tree->node, 0);
}

static void
show_hz_osd(Monitor *m, const char *msg)
{
	tll(struct GlyphRun) glyphs = tll_init();
	const struct fcft_glyph *glyph;
	struct wlr_scene_buffer *scene_buf;
	struct wlr_buffer *buffer;
	uint32_t prev_cp = 0;
	int pen_x = 0;
	int min_y = INT_MAX, max_y = INT_MIN;
	int padding = 20;
	int box_width, box_height;
	int osd_x, osd_y;
	static const float osd_bg[4] = {0.1f, 0.1f, 0.1f, 0.85f};

	if (!m || !statusfont.font || !msg || !*msg)
		return;

	/* Create tree if needed */
	if (!m->hz_osd_tree) {
		m->hz_osd_tree = wlr_scene_tree_create(layers[LyrOverlay]);
		if (!m->hz_osd_tree)
			return;
		m->hz_osd_bg = NULL;
		m->hz_osd_visible = 0;
	}

	/* Build glyph list and measure text */
	for (size_t i = 0; msg[i]; i++) {
		long kern_x = 0, kern_y = 0;
		uint32_t cp = (unsigned char)msg[i];

		if (prev_cp)
			fcft_kerning(statusfont.font, prev_cp, cp, &kern_x, &kern_y);
		pen_x += (int)kern_x;

		glyph = fcft_rasterize_char_utf32(statusfont.font, cp, statusbar_font_subpixel);
		if (glyph && glyph->pix) {
			tll_push_back(glyphs, ((struct GlyphRun){
				.glyph = glyph,
				.pen_x = pen_x,
				.codepoint = cp,
			}));
			if (-glyph->y < min_y)
				min_y = -glyph->y;
			if (-glyph->y + (int)glyph->height > max_y)
				max_y = -glyph->y + (int)glyph->height;
			pen_x += glyph->advance.x;
		}
		prev_cp = cp;
	}

	if (tll_length(glyphs) == 0) {
		tll_free(glyphs);
		return;
	}

	box_width = pen_x + padding * 2;
	box_height = (max_y - min_y) + padding * 2;

	/* Center on monitor */
	osd_x = m->m.x + (m->m.width - box_width) / 2;
	osd_y = m->m.y + (m->m.height - box_height) / 2;

	/* Clear old children */
	struct wlr_scene_node *node, *tmp;
	wl_list_for_each_safe(node, tmp, &m->hz_osd_tree->children, link)
		wlr_scene_node_destroy(node);
	m->hz_osd_bg = NULL;

	/* Create background */
	m->hz_osd_bg = wlr_scene_tree_create(m->hz_osd_tree);
	if (m->hz_osd_bg)
		drawrect(m->hz_osd_bg, 0, 0, box_width, box_height, osd_bg);

	/* Draw glyphs */
	{
		int origin_y = padding - min_y;

		tll_foreach(glyphs, it) {
			glyph = it->item.glyph;
			buffer = statusbar_buffer_from_glyph(glyph);
			if (!buffer)
				continue;

			scene_buf = wlr_scene_buffer_create(m->hz_osd_tree, NULL);
			if (scene_buf) {
				wlr_scene_buffer_set_buffer(scene_buf, buffer);
				wlr_scene_node_set_position(&scene_buf->node,
						padding + it->item.pen_x + glyph->x,
						origin_y - glyph->y);
			}
			wlr_buffer_drop(buffer);
		}
	}

	tll_free(glyphs);

	/* Position and show */
	wlr_scene_node_set_position(&m->hz_osd_tree->node, osd_x, osd_y);
	wlr_scene_node_set_enabled(&m->hz_osd_tree->node, 1);
	m->hz_osd_visible = 1;

	/* Schedule auto-hide after 3 seconds */
	if (!hz_osd_timer)
		hz_osd_timer = wl_event_loop_add_timer(event_loop, hz_osd_timeout, NULL);
	if (hz_osd_timer)
		wl_event_source_timer_update(hz_osd_timer, 3000);
}

/* Test Hz OSD - show current monitor refresh rate */
static void
testhzosd(const Arg *arg)
{
	Monitor *m = selmon;
	char osd_msg[64];
	int refresh_mhz;

	if (!m || !m->wlr_output)
		return;

	/* Use current_mode->refresh for accurate active refresh rate */
	if (m->wlr_output->current_mode)
		refresh_mhz = m->wlr_output->current_mode->refresh;
	else
		refresh_mhz = m->wlr_output->refresh;

	snprintf(osd_msg, sizeof(osd_msg), "%d.%03d Hz",
			refresh_mhz / 1000, refresh_mhz % 1000);
	show_hz_osd(m, osd_msg);
}

/*
 * Generate CVT (Coordinated Video Timings) modeline for a given resolution and refresh rate.
 * This creates a full drmModeModeInfo structure with proper timing parameters.
 * Based on VESA CVT 1.2 standard formula (reduced blanking variant).
 */
static void
generate_cvt_mode(drmModeModeInfo *mode, int hdisplay, int vdisplay, float vrefresh)
{
	/* CVT-RB (Reduced Blanking) constants - better for modern displays */
	const int RB_H_BLANK = 160;       /* Horizontal blanking pixels */
	const int RB_H_SYNC = 32;         /* Horizontal sync width */
	const int RB_V_FPORCH = 3;        /* Vertical front porch lines */
	const int RB_MIN_V_BLANK = 460;   /* Minimum vertical blank time (us) */

	int h_sync_start, h_sync_end, h_total;
	int v_sync_start, v_sync_end, v_total;
	int v_sync, v_back_porch, v_blank;
	float h_period, pixel_clock;

	memset(mode, 0, sizeof(*mode));

	/* Round hdisplay to multiple of 8 (CVT granularity) */
	hdisplay = (hdisplay / 8) * 8;

	/* Determine vsync lines based on aspect ratio */
	float aspect = (float)hdisplay / vdisplay;
	if (fabsf(aspect - 4.0f/3.0f) < 0.01f)
		v_sync = 4;
	else if (fabsf(aspect - 16.0f/9.0f) < 0.01f)
		v_sync = 5;
	else if (fabsf(aspect - 16.0f/10.0f) < 0.01f)
		v_sync = 6;
	else if (fabsf(aspect - 5.0f/4.0f) < 0.01f)
		v_sync = 7;
	else if (fabsf(aspect - 15.0f/9.0f) < 0.01f)
		v_sync = 7;
	else
		v_sync = 10; /* Default for other ratios */

	/* CVT-RB horizontal timings */
	h_total = hdisplay + RB_H_BLANK;
	h_sync_start = hdisplay + 48; /* Front porch = 48 pixels */
	h_sync_end = h_sync_start + RB_H_SYNC;

	/* Calculate horizontal period and vertical blanking */
	h_period = (1000000.0f / vrefresh - RB_MIN_V_BLANK) / vdisplay;
	v_blank = (int)(RB_MIN_V_BLANK / h_period + 0.5f);
	if (v_blank < RB_V_FPORCH + v_sync + 1)
		v_blank = RB_V_FPORCH + v_sync + 1;

	v_back_porch = v_blank - RB_V_FPORCH - v_sync;
	v_total = vdisplay + v_blank;

	/* CVT-RB vertical timings */
	v_sync_start = vdisplay + RB_V_FPORCH;
	v_sync_end = v_sync_start + v_sync;

	/* Calculate pixel clock in kHz */
	pixel_clock = vrefresh * h_total * v_total / 1000.0f;

	/* Fill in drmModeModeInfo */
	mode->clock = (uint32_t)(pixel_clock + 0.5f);
	mode->hdisplay = hdisplay;
	mode->hsync_start = h_sync_start;
	mode->hsync_end = h_sync_end;
	mode->htotal = h_total;
	mode->vdisplay = vdisplay;
	mode->vsync_start = v_sync_start;
	mode->vsync_end = v_sync_end;
	mode->vtotal = v_total;
	mode->vrefresh = (uint32_t)(vrefresh + 0.5f);
	mode->flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC;
	mode->type = DRM_MODE_TYPE_USERDEF;

	snprintf(mode->name, sizeof(mode->name), "%dx%d@%.2f",
			hdisplay, vdisplay, vrefresh);

	wlr_log(WLR_INFO, "CVT-RB mode: %s clock=%d htotal=%d vtotal=%d",
			mode->name, mode->clock, h_total, v_total);
	(void)v_back_porch;
}

/*
 * Generate a fixed mode by copying timings from base mode and adjusting only the clock.
 * This is the method Gamescope uses for dynamic refresh rate changes - it preserves
 * all timing parameters and just changes the pixel clock to achieve the target refresh.
 * Much more likely to be accepted by the display than CVT-generated timings.
 */
static void
generate_fixed_mode(drmModeModeInfo *mode, const drmModeModeInfo *base, int vrefresh)
{
	*mode = *base;
	if (!vrefresh)
		vrefresh = 60;

	/* Calculate new clock to achieve target refresh rate:
	 * clock (kHz) = htotal * vtotal * vrefresh / 1000
	 * Round up to avoid going below target refresh */
	mode->clock = ((mode->htotal * mode->vtotal * vrefresh) + 999) / 1000;

	/* Recalculate actual refresh rate from the clock we set */
	mode->vrefresh = (1000 * mode->clock) / (mode->htotal * mode->vtotal);

	snprintf(mode->name, sizeof(mode->name), "%dx%d@%d.00",
			mode->hdisplay, mode->vdisplay, vrefresh);
}

/* Set a custom refresh rate from keybind - uses arg.f as Hz (e.g., 25.55) */
static void
setcustomhz(const Arg *arg)
{
	Monitor *m = selmon;
	struct wlr_output_state state;
	struct wlr_output_configuration_v1 *config;
	struct wlr_output_configuration_head_v1 *config_head;
	struct wlr_output_mode *new_mode, *current;
	drmModeModeInfo drm_mode, base_drm_mode;
	int width, height;
	float actual_hz, target_hz;
	int multiplier;
	char osd_msg[64];
	int success = 0;

	if (!m || !m->wlr_output || !m->wlr_output->enabled || !m->wlr_output->current_mode)
		return;

	if (arg->f <= 0)
		return;

	/* Check if this is a DRM output - only DRM supports custom modes */
	if (!wlr_output_is_drm(m->wlr_output)) {
		wlr_log(WLR_INFO, "Output is not DRM, cannot add custom mode");
		snprintf(osd_msg, sizeof(osd_msg), "Not DRM output");
		show_hz_osd(m, osd_msg);
		return;
	}

	/* Save original mode before first switch */
	if (!m->video_mode_active)
		m->original_mode = m->wlr_output->current_mode;

	current = m->wlr_output->current_mode;
	width = current->width;
	height = current->height;
	target_hz = arg->f;

	/*
	 * Build base DRM mode from current wlr_output_mode.
	 * This preserves the timing parameters that the display already accepts.
	 */
	memset(&base_drm_mode, 0, sizeof(base_drm_mode));
	base_drm_mode.hdisplay = width;
	base_drm_mode.vdisplay = height;
	base_drm_mode.vrefresh = (current->refresh + 500) / 1000;
	base_drm_mode.clock = current->refresh * width * height / 1000000;

	/* Try to get actual DRM timings from preferred mode */
	struct wlr_output_mode *pref;
	wl_list_for_each(pref, &m->wlr_output->modes, link) {
		if (pref->width == width && pref->height == height && pref->preferred) {
			/* Use preferred mode timings as base - these are EDID-verified */
			base_drm_mode.clock = pref->refresh * width * height / 1000000;
			/* Estimate htotal/vtotal from clock and refresh */
			int total_pixels = (pref->refresh > 0) ? (base_drm_mode.clock * 1000000 / pref->refresh) : (width * height);
			/* Assume typical blanking ratio for htotal/vtotal estimation */
			base_drm_mode.htotal = width + 160; /* CVT-RB typical H blank */
			base_drm_mode.vtotal = total_pixels / base_drm_mode.htotal;
			if (base_drm_mode.vtotal < height)
				base_drm_mode.vtotal = height + 50; /* minimum V blank */
			/* Recalculate clock based on actual totals */
			base_drm_mode.clock = (base_drm_mode.htotal * base_drm_mode.vtotal * base_drm_mode.vrefresh + 999) / 1000;
			/* Standard sync positions */
			base_drm_mode.hsync_start = width + 48;
			base_drm_mode.hsync_end = base_drm_mode.hsync_start + 32;
			base_drm_mode.vsync_start = height + 3;
			base_drm_mode.vsync_end = base_drm_mode.vsync_start + 5;
			base_drm_mode.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC;
			wlr_log(WLR_INFO, "Using preferred mode as base: %dx%d htotal=%d vtotal=%d",
					width, height, base_drm_mode.htotal, base_drm_mode.vtotal);
			break;
		}
	}

	/* If no preferred mode found, generate CVT timings as base */
	if (base_drm_mode.htotal == 0) {
		generate_cvt_mode(&base_drm_mode, width, height, (float)base_drm_mode.vrefresh);
		wlr_log(WLR_INFO, "Generated CVT base mode: %dx%d htotal=%d vtotal=%d",
				width, height, base_drm_mode.htotal, base_drm_mode.vtotal);
	}

	/*
	 * Calculate starting multiplier to stay above panel minimum (48 Hz).
	 */
	multiplier = 1;
	if (target_hz < 48.0f) {
		multiplier = (int)ceilf(48.0f / target_hz);
	}

	/*
	 * Try FIXED mode generation first (Gamescope method).
	 * This preserves timings and only changes clock - much more likely to work.
	 */
	for (; multiplier <= 8 && !success; multiplier++) {
		int target_vrefresh = (int)(target_hz * multiplier + 0.5f);
		actual_hz = target_hz * multiplier;

		/* Skip if above typical max refresh */
		if (actual_hz > 300.0f)
			break;

		wlr_log(WLR_INFO, "Fixed mode: trying %.3f Hz -> %d Hz (%dx multiplier)",
				target_hz, target_vrefresh, multiplier);

		/* Generate fixed mode - only changes clock, preserves all timings */
		generate_fixed_mode(&drm_mode, &base_drm_mode, target_vrefresh);

		wlr_log(WLR_INFO, "Fixed mode params: clock=%d htotal=%d vtotal=%d vrefresh=%d",
				drm_mode.clock, drm_mode.htotal, drm_mode.vtotal, drm_mode.vrefresh);

		/* Add custom mode to DRM connector */
		new_mode = wlr_drm_connector_add_mode(m->wlr_output, &drm_mode);
		if (!new_mode) {
			wlr_log(WLR_DEBUG, "wlr_drm_connector_add_mode failed for fixed %d Hz", target_vrefresh);
			continue;
		}

		wlr_log(WLR_INFO, "Added fixed mode: %dx%d@%d mHz",
				new_mode->width, new_mode->height, new_mode->refresh);

		/* Try to apply the new mode */
		wlr_output_state_init(&state);
		wlr_output_state_set_mode(&state, new_mode);

		if (wlr_output_test_state(m->wlr_output, &state)) {
			if (wlr_output_commit_state(m->wlr_output, &state)) {
				success = 1;
				m->video_mode_active = 1;

				config = wlr_output_configuration_v1_create();
				config_head = wlr_output_configuration_head_v1_create(config, m->wlr_output);
				config_head->state.mode = new_mode;
				wlr_output_manager_v1_set_configuration(output_mgr, config);

				wlr_log(WLR_INFO, "Fixed mode %d Hz applied (%dx %.3f fps)",
						target_vrefresh, multiplier, target_hz);
			} else {
				wlr_log(WLR_DEBUG, "wlr_output_commit_state failed for fixed %d Hz", target_vrefresh);
			}
		} else {
			wlr_log(WLR_DEBUG, "wlr_output_test_state failed for fixed %d Hz", target_vrefresh);
		}
		wlr_output_state_finish(&state);
	}

	/*
	 * Fallback: Try CVT mode generation if fixed mode didn't work.
	 */
	if (!success) {
		multiplier = 1;
		if (target_hz < 48.0f) {
			multiplier = (int)ceilf(48.0f / target_hz);
		}

		for (; multiplier <= 8 && !success; multiplier++) {
			actual_hz = target_hz * multiplier;

			if (actual_hz > 300.0f)
				break;

			wlr_log(WLR_INFO, "CVT fallback: trying %.3f Hz -> %.3f Hz (%dx multiplier)",
					target_hz, actual_hz, multiplier);

			generate_cvt_mode(&drm_mode, width, height, actual_hz);

			new_mode = wlr_drm_connector_add_mode(m->wlr_output, &drm_mode);
			if (!new_mode) {
				wlr_log(WLR_DEBUG, "wlr_drm_connector_add_mode failed for CVT %.3f Hz", actual_hz);
				continue;
			}

			wlr_output_state_init(&state);
			wlr_output_state_set_mode(&state, new_mode);

			if (wlr_output_test_state(m->wlr_output, &state)) {
				if (wlr_output_commit_state(m->wlr_output, &state)) {
					success = 1;
					m->video_mode_active = 1;

					config = wlr_output_configuration_v1_create();
					config_head = wlr_output_configuration_head_v1_create(config, m->wlr_output);
					config_head->state.mode = new_mode;
					wlr_output_manager_v1_set_configuration(output_mgr, config);

					wlr_log(WLR_INFO, "CVT mode %.3f Hz applied (%dx %.3f fps)",
							actual_hz, multiplier, target_hz);
				}
			}
			wlr_output_state_finish(&state);
		}
	}

	/* Fallback: Find existing mode that's a multiple of target Hz */
	if (!success) {
		struct wlr_output_mode *video_mode = find_video_friendly_mode(m, target_hz);

		if (video_mode && video_mode != m->wlr_output->current_mode) {
			wlr_output_state_init(&state);
			wlr_output_state_set_mode(&state, video_mode);

			if (wlr_output_commit_state(m->wlr_output, &state)) {
				success = 1;
				m->video_mode_active = 1;
				actual_hz = video_mode->refresh / 1000.0f;
				multiplier = (int)(actual_hz / target_hz + 0.5f);

				config = wlr_output_configuration_v1_create();
				config_head = wlr_output_configuration_head_v1_create(config, m->wlr_output);
				config_head->state.mode = video_mode;
				wlr_output_manager_v1_set_configuration(output_mgr, config);

				wlr_log(WLR_INFO, "Fallback mode %d.%03d Hz applied (%dx %.3f Hz)",
						video_mode->refresh / 1000, video_mode->refresh % 1000,
						multiplier, target_hz);
			}
			wlr_output_state_finish(&state);
		}
	}

	/* Show result */
	if (success) {
		int actual_mhz = (int)(actual_hz * 1000.0f + 0.5f);
		if (multiplier > 1) {
			snprintf(osd_msg, sizeof(osd_msg), "%d.%03d Hz (%dx%.0f)",
					actual_mhz / 1000, actual_mhz % 1000, multiplier, target_hz);
		} else {
			snprintf(osd_msg, sizeof(osd_msg), "%d.%03d Hz",
					actual_mhz / 1000, actual_mhz % 1000);
		}
	} else {
		wlr_log(WLR_ERROR, "Failed to set video Hz for %.3f fps (all methods failed)", target_hz);

		/* Restore original mode */
		if (m->original_mode) {
			wlr_output_state_init(&state);
			wlr_output_state_set_mode(&state, m->original_mode);
			wlr_output_commit_state(m->wlr_output, &state);
			wlr_output_state_finish(&state);
		}

		snprintf(osd_msg, sizeof(osd_msg), "FAILED: %.0f fps", target_hz);
	}

	show_hz_osd(m, osd_msg);
}

/*
 * Check if any fullscreen client is playing video and adjust refresh rate.
 * Uses intelligent scoring system to find optimal mode for silky smooth playback.
 * Implements 3-retry logic when no video is detected initially.
 */
static void
check_fullscreen_video(void)
{
	Client *c;
	Monitor *m;
	int any_fullscreen_active = 0;

	wl_list_for_each(m, &mons, link) {
		c = focustop(m);
		if (!c || !c->isfullscreen)
			continue;

		any_fullscreen_active = 1;

		/* Check if this is a game - video detection runs silently for games */
		int is_game = is_game_content(c) || client_wants_tearing(c);

		/* Check content-type hint from client */
		int is_video = is_video_content(c);

		/* Detect exact video Hz from frame timing (use 8 samples for speed) */
		float hz = 0.0f;
		if (c->frame_time_count >= 8)
			hz = detect_video_framerate(c);

		wlr_log(WLR_DEBUG, "check_fullscreen_video: monitor=%s is_video=%d "
				"frame_count=%d hz=%.3f detected_hz=%.3f phase=%d retries=%d "
				"video_mode_active=%d vrr_active=%d",
				m->wlr_output->name, is_video, c->frame_time_count, hz,
				c->detected_video_hz, c->video_detect_phase, c->video_detect_retries,
				m->video_mode_active, m->vrr_active);

		/* Already successfully detected and mode set */
		if (c->video_detect_phase == 2 && (m->video_mode_active || m->vrr_active)) {
			/* Check if Hz changed significantly - video may have switched */
			if (hz > 0.0f && fabsf(hz - c->detected_video_hz) > 0.5f) {
				wlr_log(WLR_INFO, "Video Hz changed from %.3f to %.3f, re-evaluating",
						c->detected_video_hz, hz);
				c->detected_video_hz = hz;
				apply_best_video_mode(m, hz);
			}
			continue;
		}

		/* Phase 0: Scanning - collecting frame samples (silent, no OSD) */
		if (c->video_detect_phase == 0) {
			/* Use fewer samples for faster detection (8 instead of 16) */
			if (c->frame_time_count < 8)
				continue;
			/* Enough samples collected, move to analysis */
			c->video_detect_phase = 1;
		}

		/* Phase 1: Analysis - try to detect video framerate */
		if (c->video_detect_phase == 1) {
			if (hz > 0.0f) {
				/* Successfully detected! Apply best mode */
				c->detected_video_hz = hz;
				c->video_detect_phase = 2;
				c->video_detect_retries = 0;

				wlr_log(WLR_INFO, "Video detected at %.3f Hz on %s, applying best mode",
						hz, m->wlr_output->name);

				if (apply_best_video_mode(m, hz)) {
					wlr_log(WLR_INFO, "Successfully applied optimal video mode");
				} else {
					wlr_log(WLR_ERROR, "Failed to apply video mode");
				}
				continue;
			}

			/* No stable framerate detected yet */
			if (is_video) {
				/* Content-type says video but can't detect fps.
				 * Use default 59.94 Hz as fallback. */
				wlr_log(WLR_INFO, "Video content-type detected but fps unclear, using 59.94 Hz");
				c->detected_video_hz = 59.94f;
				c->video_detect_phase = 2;
				apply_best_video_mode(m, 59.94f);
				continue;
			}

			/* Try to estimate from raw measurements */
			double avg_interval = 0;
			int valid = 0;
			for (int i = 1; i < c->frame_time_count; i++) {
				int prev_idx = (c->frame_time_idx - c->frame_time_count + i - 1 + 32) % 32;
				int curr_idx = (c->frame_time_idx - c->frame_time_count + i + 32) % 32;
				uint64_t interval = c->frame_times[curr_idx] - c->frame_times[prev_idx];
				if (interval >= 5 && interval <= 200) {
					avg_interval += interval;
					valid++;
				}
			}

			if (valid > 0) {
				avg_interval /= valid;
				double raw_hz = 1000.0 / avg_interval;

				/* If in video range (20-120 Hz), use rounded standard framerate */
				if (raw_hz >= 20.0 && raw_hz <= 120.0) {
					float use_hz;
					if (raw_hz < 24.5)
						use_hz = (raw_hz < 24.0) ? 23.976f : 24.0f;
					else if (raw_hz < 27.5)
						use_hz = 25.0f;
					else if (raw_hz < 35.0)
						use_hz = (raw_hz < 30.0) ? 29.97f : 30.0f;
					else if (raw_hz < 55.0)
						use_hz = 50.0f;
					else if (raw_hz < 65.0)
						use_hz = (raw_hz < 60.0) ? 59.94f : 60.0f;
					else
						use_hz = (float)raw_hz;

					c->detected_video_hz = use_hz;
					c->video_detect_phase = 2;

					wlr_log(WLR_INFO, "Estimated framerate %.3f Hz (raw ~%.1f Hz) on %s",
							use_hz, raw_hz, m->wlr_output->name);

					apply_best_video_mode(m, use_hz);
					continue;
				}

				/* Hz outside video range - likely not video content */
				wlr_log(WLR_DEBUG, "Measured Hz (~%.1f) outside video range", raw_hz);
			}

			/* No video detected - silent retry (1 retry only for speed) */
			c->video_detect_retries++;

			if (c->video_detect_retries < 1) {
				/* Clear frame data for fresh scan - no OSD */
				c->frame_time_idx = 0;
				c->frame_time_count = 0;
				c->last_buffer = NULL;
				c->video_detect_phase = 0;
			} else {
				/* Done - no video content, stay silent */
				c->video_detect_phase = 2;
			}
		}
	}

	/* Continue checking while fullscreen clients exist (fast interval) */
	if (any_fullscreen_active)
		schedule_video_check(200);
}

void
setcursor(struct wl_listener *listener, void *data)
{
	/* This event is raised by the seat when a client provides a cursor image */
	struct wlr_seat_pointer_request_set_cursor_event *event = data;
	/* If we're "grabbing" the cursor, don't use the client's image, we will
	 * restore it after "grabbing" sending a leave event, followed by a enter
	 * event, which will result in the client requesting set the cursor surface */
	if (cursor_mode != CurNormal && cursor_mode != CurPressed)
		return;
	/* Keep cursor hidden in HTPC views */
	if (selmon && (selmon->pc_gaming.visible ||
	               selmon->movies_view.visible ||
	               selmon->tvshows_view.visible))
		return;
	/* This can be sent by any client, so we check to make sure this one
	 * actually has pointer focus first. If so, we can tell the cursor to
	 * use the provided surface as the cursor image. It will set the
	 * hardware cursor on the output that it's currently on and continue to
	 * do so as the cursor moves between outputs. */
	if (event->seat_client == seat->pointer_state.focused_client)
		wlr_cursor_set_surface(cursor, event->surface,
				event->hotspot_x, event->hotspot_y);
}

void
setcursorshape(struct wl_listener *listener, void *data)
{
	struct wlr_cursor_shape_manager_v1_request_set_shape_event *event = data;
	if (cursor_mode != CurNormal && cursor_mode != CurPressed)
		return;
	/* Keep cursor hidden in HTPC views */
	if (selmon && (selmon->pc_gaming.visible ||
	               selmon->movies_view.visible ||
	               selmon->tvshows_view.visible))
		return;
	/* This can be sent by any client, so we check to make sure this one
	 * actually has pointer focus first. If so, we can tell the cursor to
	 * use the provided cursor shape. */
	if (event->seat_client == seat->pointer_state.focused_client)
		wlr_cursor_set_xcursor(cursor, cursor_mgr,
				wlr_cursor_shape_v1_name(event->shape));
}

void
setfloating(Client *c, int floating)
{
	Client *p = client_get_parent(c);
	c->isfloating = floating;
	/* If in floating layout do not change the client's layer */
	if (!c->mon || !client_surface(c)->mapped || !c->mon->lt[c->mon->sellt]->arrange)
		return;
	wlr_scene_node_reparent(&c->scene->node, layers[c->isfullscreen ||
			(p && p->isfullscreen) ? LyrFS
			: c->isfloating ? LyrFloat : LyrTile]);
	arrange(c->mon);
	printstatus();
}

void
setfullscreen(Client *c, int fullscreen)
{
	/*
	 * In HTPC mode, games and Steam Big Picture are locked to fullscreen
	 * and cannot exit fullscreen. This prevents accidental unfullscreen
	 * from game menus or escape keys. The app must be closed to exit fullscreen.
	 */
	if (htpc_mode_active && !fullscreen && c->isfullscreen &&
	    (is_game_content(c) || is_steam_client(c))) {
		wlr_log(WLR_INFO, "HTPC: Blocking unfullscreen for '%s'",
			client_get_appid(c) ? client_get_appid(c) : "(unknown)");
		/* Re-assert fullscreen state to the client */
		client_set_fullscreen(c, 1);
		return;
	}

	c->isfullscreen = fullscreen;
	if (!c->mon || !client_surface(c)->mapped)
		return;
	c->bw = fullscreen ? 0 : borderpx;
	client_set_fullscreen(c, fullscreen);
	wlr_scene_node_reparent(&c->scene->node, layers[c->isfullscreen
			? LyrFS : c->isfloating ? LyrFloat : LyrTile]);

	if (fullscreen) {
		c->prev = c->geom;
		resize(c, c->mon->m, 0);
		set_adaptive_sync(c->mon, 1);
		/* Reset frame tracking and video detection state */
		c->frame_time_idx = 0;
		c->frame_time_count = 0;
		c->detected_video_hz = 0.0f;
		c->last_buffer = NULL;
		c->video_detect_retries = 0;
		c->video_detect_phase = 0;
		/*
		 * Enable dynamic game VRR if this is a game.
		 * Game VRR will automatically adjust the display refresh rate
		 * to match the game's actual framerate for judder-free gaming.
		 */
		if (is_game_content(c) || client_wants_tearing(c)) {
			enable_game_vrr(c->mon);
		} else {
			/* Try to match video refresh rate if content is video */
			set_video_refresh_rate(c->mon, c);
		}
		/* Always run silent video detection - catches cutscenes in games */
		schedule_video_check(200);
	} else {
		/* restore previous size only for floating windows since their
		 * positions are set by the user. Tiled windows will be positioned
		 * by the layout system in arrange(). */
		if (c->isfloating)
			resize(c, c->prev, 0);
		set_adaptive_sync(c->mon, 0);
		/* Disable game VRR when exiting fullscreen */
		disable_game_vrr(c->mon);
		/* Restore max refresh rate when exiting fullscreen */
		restore_max_refresh_rate(c->mon);
		c->detected_video_hz = 0.0f;
	}
	arrange(c->mon);
	printstatus();
	update_game_mode();

	/* Ensure fullscreen client gets keyboard focus immediately */
	if (fullscreen) {
		exclusive_focus = NULL;  /* Clear any exclusive focus that might block */
		focusclient(c, 1);
	}
}

void
setlayout(const Arg *arg)
{
	if (!selmon)
		return;
	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
		selmon->sellt ^= 1;
	if (arg && arg->v)
		selmon->lt[selmon->sellt] = (Layout *)arg->v;
	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, LENGTH(selmon->ltsymbol));
	arrange(selmon);
	printstatus();
}

/* arg > 1.0 will set mfact absolutely */
void
setmfact(const Arg *arg)
{
	float f;

	if (!arg || !selmon || !selmon->lt[selmon->sellt]->arrange)
		return;
	f = arg->f < 1.0f ? arg->f + selmon->mfact : arg->f - 1.0f;
	if (f < 0.1 || f > 0.9)
		return;
	selmon->mfact = f;
	arrange(selmon);
}

void
setmon(Client *c, Monitor *m, uint32_t newtags)
{
	Monitor *oldmon = c->mon;

	if (oldmon == m)
		return;
	c->mon = m;
	c->prev = c->geom;

	/* Scene graph sends surface leave/enter events on move and resize */
	if (oldmon)
		arrange(oldmon);
	if (m) {
		/* For floating windows, ensure they overlap with the new monitor.
		 * Tiled windows will be positioned by the layout system in arrange(). */
		if (c->isfloating)
			resize(c, c->geom, 0);
		c->tags = newtags ? newtags : m->tagset[m->seltags]; /* assign tags of target monitor */
		setfullscreen(c, c->isfullscreen); /* This will call arrange(c->mon) */
		setfloating(c, c->isfloating);
	}
	focusclient(focustop(selmon), 1);
}

void
setpsel(struct wl_listener *listener, void *data)
{
	/* This event is raised by the seat when a client wants to set the selection,
	 * usually when the user copies something. wlroots allows compositors to
	 * ignore such requests if they so choose, but in dwl we always honor them
	 */
	struct wlr_seat_request_set_primary_selection_event *event = data;
	wlr_seat_set_primary_selection(seat, event->source, event->serial);
}

void
setsel(struct wl_listener *listener, void *data)
{
	/* This event is raised by the seat when a client wants to set the selection,
	 * usually when the user copies something. wlroots allows compositors to
	 * ignore such requests if they so choose, but in dwl we always honor them
	 */
	struct wlr_seat_request_set_selection_event *event = data;
	wlr_seat_set_selection(seat, event->source, event->serial);
}

/* ========== Runtime Configuration Parser ========== */
static char *config_strdup(const char *s)
{
	size_t len = strlen(s);
	char *dup = malloc(len + 1);
	if (dup) memcpy(dup, s, len + 1);
	return dup;
}

static void config_trim(char *s)
{
	char *start = s, *end;
	while (*start && isspace((unsigned char)*start)) start++;
	if (start != s) memmove(s, start, strlen(start) + 1);
	end = s + strlen(s);
	while (end > s && isspace((unsigned char)*(end - 1))) end--;
	*end = '\0';
}

static int config_parse_color(const char *value, float color[4])
{
	unsigned int hex;
	if (value[0] == '#') value++;
	else if (value[0] == '0' && (value[1] == 'x' || value[1] == 'X')) value += 2;
	if (sscanf(value, "%x", &hex) != 1) return 0;
	/* Handle both #RRGGBB and #RRGGBBAA formats */
	if (strlen(value) <= 6) hex = (hex << 8) | 0xFF;
	color[0] = ((hex >> 24) & 0xFF) / 255.0f;
	color[1] = ((hex >> 16) & 0xFF) / 255.0f;
	color[2] = ((hex >> 8) & 0xFF) / 255.0f;
	color[3] = (hex & 0xFF) / 255.0f;
	return 1;
}

static void config_expand_path(const char *src, char *dst, size_t dstlen)
{
	const char *home = getenv("HOME");
	if (src[0] == '~' && src[1] == '/') {
		snprintf(dst, dstlen, "%s%s", home ? home : "", src + 1);
	} else if (strncmp(src, "$HOME", 5) == 0) {
		snprintf(dst, dstlen, "%s%s", home ? home : "", src + 5);
	} else {
		snprintf(dst, dstlen, "%s", src);
	}
}

static void config_set_value(const char *key, const char *value)
{
	/* General appearance */
	if (strcmp(key, "sloppyfocus") == 0) sloppyfocus = atoi(value);
	else if (strcmp(key, "bypass_surface_visibility") == 0) bypass_surface_visibility = atoi(value);
	else if (strcmp(key, "smartgaps") == 0) smartgaps = atoi(value);
	else if (strcmp(key, "gaps") == 0) gaps = atoi(value);
	else if (strcmp(key, "gappx") == 0) gappx = (unsigned int)atoi(value);
	else if (strcmp(key, "borderpx") == 0) borderpx = (unsigned int)atoi(value);
	else if (strcmp(key, "lock_cursor") == 0) lock_cursor = atoi(value);

	/* HTPC mode (0=disabled, 1=auto on controller, 2=always on) */
	else if (strcmp(key, "htpc_mode") == 0) htpc_mode = atoi(value);
	else if (strcmp(key, "htpc_wallpaper") == 0) {
		config_expand_path(value, htpc_wallpaper_path, sizeof(htpc_wallpaper_path));
	}
	else if (strcmp(key, "htpc_page_pcgaming") == 0) htpc_page_pcgaming = atoi(value);
	else if (strcmp(key, "htpc_page_retrogaming") == 0) htpc_page_retrogaming = atoi(value);
	else if (strcmp(key, "htpc_page_movies") == 0) htpc_page_movies = atoi(value);
	else if (strcmp(key, "htpc_page_tvshows") == 0) htpc_page_tvshows = atoi(value);
	else if (strcmp(key, "htpc_page_quit") == 0) htpc_page_quit = atoi(value);

	/* Media server configuration (disables auto-discovery if set) */
	else if (strcmp(key, "media_server") == 0) {
		if (media_server_count < MAX_MEDIA_SERVERS && *value) {
			/* Add http:// prefix if missing */
			if (strncmp(value, "http://", 7) != 0 && strncmp(value, "https://", 8) != 0) {
				snprintf(media_servers[media_server_count], sizeof(media_servers[0]),
					 "http://%s", value);
			} else {
				strncpy(media_servers[media_server_count], value,
					sizeof(media_servers[0]) - 1);
			}
			media_server_count++;
			wlr_log(WLR_INFO, "Added media server: %s (total: %d)",
				media_servers[media_server_count - 1], media_server_count);
		}
	}

	/* PC Gaming services */
	else if (strcmp(key, "gaming_steam_enabled") == 0) gaming_service_enabled[GAMING_SERVICE_STEAM] = atoi(value);
	else if (strcmp(key, "gaming_heroic_enabled") == 0) gaming_service_enabled[GAMING_SERVICE_HEROIC] = atoi(value);
	else if (strcmp(key, "gaming_lutris_enabled") == 0) gaming_service_enabled[GAMING_SERVICE_LUTRIS] = atoi(value);
	else if (strcmp(key, "gaming_bottles_enabled") == 0) gaming_service_enabled[GAMING_SERVICE_BOTTLES] = atoi(value);

	/* Colors */
	else if (strcmp(key, "rootcolor") == 0) config_parse_color(value, rootcolor);
	else if (strcmp(key, "bordercolor") == 0) config_parse_color(value, bordercolor);
	else if (strcmp(key, "focuscolor") == 0) config_parse_color(value, focuscolor);
	else if (strcmp(key, "urgentcolor") == 0) config_parse_color(value, urgentcolor);
	else if (strcmp(key, "fullscreen_bg") == 0) config_parse_color(value, fullscreen_bg);

	/* Statusbar */
	else if (strcmp(key, "statusbar_height") == 0) statusbar_height = (unsigned int)atoi(value);
	else if (strcmp(key, "statusbar_module_spacing") == 0) statusbar_module_spacing = (unsigned int)atoi(value);
	else if (strcmp(key, "statusbar_module_padding") == 0) statusbar_module_padding = (unsigned int)atoi(value);
	else if (strcmp(key, "statusbar_icon_text_gap") == 0) statusbar_icon_text_gap = (unsigned int)atoi(value);
	else if (strcmp(key, "statusbar_top_gap") == 0) statusbar_top_gap = (unsigned int)atoi(value);
	else if (strcmp(key, "statusbar_fg") == 0) config_parse_color(value, statusbar_fg);
	else if (strcmp(key, "statusbar_bg") == 0) config_parse_color(value, statusbar_bg);
	else if (strcmp(key, "statusbar_popup_bg") == 0) config_parse_color(value, statusbar_popup_bg);
	else if (strcmp(key, "statusbar_volume_muted_fg") == 0) config_parse_color(value, statusbar_volume_muted_fg);
	else if (strcmp(key, "statusbar_mic_muted_fg") == 0) config_parse_color(value, statusbar_mic_muted_fg);
	else if (strcmp(key, "statusbar_tag_bg") == 0) config_parse_color(value, statusbar_tag_bg);
	else if (strcmp(key, "statusbar_tag_active_bg") == 0) config_parse_color(value, statusbar_tag_active_bg);
	else if (strcmp(key, "statusbar_tag_hover_bg") == 0) config_parse_color(value, statusbar_tag_hover_bg);
	else if (strcmp(key, "statusbar_hover_fade_ms") == 0) statusbar_hover_fade_ms = atoi(value);
	else if (strcmp(key, "statusbar_tray_force_rgba") == 0) statusbar_tray_force_rgba = atoi(value);
	else if (strcmp(key, "statusbar_font_spacing") == 0) statusbar_font_spacing = atoi(value);
	else if (strcmp(key, "statusbar_font_force_color") == 0) statusbar_font_force_color = atoi(value);
	else if (strcmp(key, "statusbar_workspace_padding") == 0) statusbar_workspace_padding = atoi(value);
	else if (strcmp(key, "statusbar_workspace_spacing") == 0) statusbar_workspace_spacing = atoi(value);
	else if (strcmp(key, "statusbar_thumb_height") == 0) statusbar_thumb_height = atoi(value);
	else if (strcmp(key, "statusbar_thumb_gap") == 0) statusbar_thumb_gap = atoi(value);
	else if (strcmp(key, "statusbar_thumb_window") == 0) config_parse_color(value, statusbar_thumb_window);
	else if (strcmp(key, "statusbar_font") == 0) {
		/* Parse comma-separated fonts into runtime array */
		char *copy = config_strdup(value);
		char *saveptr, *tok;
		int i = 0;
		for (tok = strtok_r(copy, ",", &saveptr); tok && i < 7; tok = strtok_r(NULL, ",", &saveptr)) {
			config_trim(tok);
			if (*tok) runtime_fonts[i++] = config_strdup(tok);
		}
		runtime_fonts[i] = NULL;
		runtime_fonts_set = 1;
		free(copy);
	}

	/* Keyboard */
	else if (strcmp(key, "repeat_delay") == 0) repeat_delay = atoi(value);
	else if (strcmp(key, "repeat_rate") == 0) repeat_rate = atoi(value);

	/* Trackpad */
	else if (strcmp(key, "tap_to_click") == 0) tap_to_click = atoi(value);
	else if (strcmp(key, "tap_and_drag") == 0) tap_and_drag = atoi(value);
	else if (strcmp(key, "drag_lock") == 0) drag_lock = atoi(value);
	else if (strcmp(key, "natural_scrolling") == 0) natural_scrolling = atoi(value);
	else if (strcmp(key, "disable_while_typing") == 0) disable_while_typing = atoi(value);
	else if (strcmp(key, "left_handed") == 0) left_handed = atoi(value);
	else if (strcmp(key, "middle_button_emulation") == 0) middle_button_emulation = atoi(value);
	else if (strcmp(key, "accel_speed") == 0) accel_speed = atof(value);
	else if (strcmp(key, "accel_profile") == 0) {
		if (strcmp(value, "flat") == 0) accel_profile = LIBINPUT_CONFIG_ACCEL_PROFILE_FLAT;
		else if (strcmp(value, "adaptive") == 0) accel_profile = LIBINPUT_CONFIG_ACCEL_PROFILE_ADAPTIVE;
	}
	else if (strcmp(key, "scroll_method") == 0) {
		if (strcmp(value, "none") == 0) scroll_method = LIBINPUT_CONFIG_SCROLL_NO_SCROLL;
		else if (strcmp(value, "2fg") == 0) scroll_method = LIBINPUT_CONFIG_SCROLL_2FG;
		else if (strcmp(value, "edge") == 0) scroll_method = LIBINPUT_CONFIG_SCROLL_EDGE;
		else if (strcmp(value, "button") == 0) scroll_method = LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN;
	}
	else if (strcmp(key, "click_method") == 0) {
		if (strcmp(value, "none") == 0) click_method = LIBINPUT_CONFIG_CLICK_METHOD_NONE;
		else if (strcmp(value, "button_areas") == 0) click_method = LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS;
		else if (strcmp(value, "clickfinger") == 0) click_method = LIBINPUT_CONFIG_CLICK_METHOD_CLICKFINGER;
	}
	else if (strcmp(key, "button_map") == 0) {
		if (strcmp(value, "lrm") == 0) button_map = LIBINPUT_CONFIG_TAP_MAP_LRM;
		else if (strcmp(value, "lmr") == 0) button_map = LIBINPUT_CONFIG_TAP_MAP_LMR;
	}

	/* Resizing */
	else if (strcmp(key, "resize_factor") == 0) resize_factor = (float)atof(value);
	else if (strcmp(key, "resize_interval_ms") == 0) resize_interval_ms = (uint32_t)atoi(value);
	else if (strcmp(key, "resize_min_pixels") == 0) resize_min_pixels = atof(value);
	else if (strcmp(key, "resize_ratio_epsilon") == 0) resize_ratio_epsilon = (float)atof(value);
	else if (strcmp(key, "modal_file_search_minlen") == 0) modal_file_search_minlen = atoi(value);

	/* Wallpaper and autostart */
	else if (strcmp(key, "wallpaper") == 0) {
		/* Store wallpaper path - autostart_cmd is built in main() */
		snprintf(wallpaper_path, sizeof(wallpaper_path), "%s", value);
	}
	else if (strcmp(key, "autostart") == 0) {
		snprintf(autostart_cmd, sizeof(autostart_cmd), "%s", value);
	}

	/* Modifier keys */
	else if (strcmp(key, "modkey") == 0) {
		if (strcmp(value, "super") == 0 || strcmp(value, "logo") == 0 || strcmp(value, "mod4") == 0)
			modkey = WLR_MODIFIER_LOGO;
		else if (strcmp(value, "alt") == 0 || strcmp(value, "mod1") == 0)
			modkey = WLR_MODIFIER_ALT;
		else if (strcmp(value, "ctrl") == 0 || strcmp(value, "control") == 0)
			modkey = WLR_MODIFIER_CTRL;
		else if (strcmp(value, "shift") == 0)
			modkey = WLR_MODIFIER_SHIFT;
	}
	else if (strcmp(key, "monitorkey") == 0) {
		if (strcmp(value, "super") == 0 || strcmp(value, "logo") == 0 || strcmp(value, "mod4") == 0)
			monitorkey = WLR_MODIFIER_LOGO;
		else if (strcmp(value, "alt") == 0 || strcmp(value, "mod1") == 0)
			monitorkey = WLR_MODIFIER_ALT;
		else if (strcmp(value, "ctrl") == 0 || strcmp(value, "control") == 0)
			monitorkey = WLR_MODIFIER_CTRL;
		else if (strcmp(value, "shift") == 0)
			monitorkey = WLR_MODIFIER_SHIFT;
	}

	/* Spawn commands */
	else if (strcmp(key, "terminal") == 0) {
		snprintf(spawn_cmd_terminal, sizeof(spawn_cmd_terminal), "%s", value);
	}
	else if (strcmp(key, "terminal_alt") == 0) {
		snprintf(spawn_cmd_terminal_alt, sizeof(spawn_cmd_terminal_alt), "%s", value);
	}
	else if (strcmp(key, "browser") == 0) {
		snprintf(spawn_cmd_browser, sizeof(spawn_cmd_browser), "%s", value);
	}
	else if (strcmp(key, "filemanager") == 0) {
		snprintf(spawn_cmd_filemanager, sizeof(spawn_cmd_filemanager), "%s", value);
	}
	else if (strcmp(key, "launcher") == 0) {
		snprintf(spawn_cmd_launcher, sizeof(spawn_cmd_launcher), "%s", value);
	}
}

/* Keysym name to XKB keysym lookup */
static xkb_keysym_t config_parse_keysym(const char *name)
{
	xkb_keysym_t sym;

	/* Try XKB lookup first */
	sym = xkb_keysym_from_name(name, XKB_KEYSYM_NO_FLAGS);
	if (sym != XKB_KEY_NoSymbol) return sym;

	/* Try case-insensitive */
	sym = xkb_keysym_from_name(name, XKB_KEYSYM_CASE_INSENSITIVE);
	if (sym != XKB_KEY_NoSymbol) return sym;

	/* Common aliases */
	if (strcasecmp(name, "enter") == 0) return XKB_KEY_Return;
	if (strcasecmp(name, "esc") == 0) return XKB_KEY_Escape;
	if (strcasecmp(name, "backspace") == 0) return XKB_KEY_BackSpace;
	if (strcasecmp(name, "tab") == 0) return XKB_KEY_Tab;
	if (strcasecmp(name, "space") == 0) return XKB_KEY_space;
	if (strcasecmp(name, "up") == 0) return XKB_KEY_Up;
	if (strcasecmp(name, "down") == 0) return XKB_KEY_Down;
	if (strcasecmp(name, "left") == 0) return XKB_KEY_Left;
	if (strcasecmp(name, "right") == 0) return XKB_KEY_Right;
	if (strcasecmp(name, "delete") == 0) return XKB_KEY_Delete;
	if (strcasecmp(name, "home") == 0) return XKB_KEY_Home;
	if (strcasecmp(name, "end") == 0) return XKB_KEY_End;
	if (strcasecmp(name, "pageup") == 0) return XKB_KEY_Page_Up;
	if (strcasecmp(name, "pagedown") == 0) return XKB_KEY_Page_Down;
	if (strcasecmp(name, "print") == 0) return XKB_KEY_Print;

	return XKB_KEY_NoSymbol;
}

/* Parse modifier string like "super+shift" */
static unsigned int config_parse_modifiers(const char *mods_str)
{
	unsigned int mods = 0;
	char *copy = config_strdup(mods_str);
	char *saveptr, *tok;

	for (tok = strtok_r(copy, "+", &saveptr); tok; tok = strtok_r(NULL, "+", &saveptr)) {
		config_trim(tok);
		if (strcasecmp(tok, "super") == 0 || strcasecmp(tok, "logo") == 0 || strcasecmp(tok, "mod4") == 0)
			mods |= WLR_MODIFIER_LOGO;
		else if (strcasecmp(tok, "alt") == 0 || strcasecmp(tok, "mod1") == 0)
			mods |= WLR_MODIFIER_ALT;
		else if (strcasecmp(tok, "ctrl") == 0 || strcasecmp(tok, "control") == 0)
			mods |= WLR_MODIFIER_CTRL;
		else if (strcasecmp(tok, "shift") == 0)
			mods |= WLR_MODIFIER_SHIFT;
		else if (strcasecmp(tok, "mod") == 0)
			mods |= modkey;
	}
	free(copy);
	return mods;
}

/* Stored spawn commands for runtime bindings */
static char *runtime_spawn_cmds[MAX_KEYS];
static int runtime_spawn_cmd_count = 0;

/* ========== Runtime Monitor Configuration ========== */
#define MAX_MONITORS 16

static RuntimeMonitorConfig runtime_monitors[MAX_MONITORS];
static int runtime_monitor_count = 0;

/* Default monitor assignments by connector type priority */
static int monitor_master_set = 0;  /* Track if master was explicitly configured */

/* Function lookup for keybindings */
typedef struct {
	const char *name;
	void (*func)(const Arg *);
	int arg_type; /* 0=none, 1=int, 2=uint, 3=float, 4=spawn */
} FuncEntry;

static const FuncEntry func_table[] = {
	{ "quit",              quit,              0 },
	{ "killclient",        killclient,        0 },
	{ "focusstack",        focusstack,        1 },
	{ "incnmaster",        incnmaster,        1 },
	{ "setmfact",          setmfact,          3 },
	{ "zoom",              zoom,              0 },
	{ "view",              view,              2 },
	{ "tag",               tag,               2 },
	{ "toggleview",        toggleview,        2 },
	{ "toggletag",         toggletag,         2 },
	{ "togglefloating",    togglefloating,    0 },
	{ "togglefullscreen",  togglefullscreen,  0 },
	{ "togglegaps",        togglegaps,        0 },
	{ "togglestatusbar",   togglestatusbar,   0 },
	{ "htpc_mode_toggle",  htpc_mode_toggle,  0 },
	{ "focusmon",          focusmon,          1 },
	{ "tagmon",            tagmon,            1 },
	{ "setlayout",         setlayout,         0 },
	{ "spawn",             spawn,             4 },
	{ "modal_show",        modal_show,        0 },
	{ "modal_show_files",  modal_show_files,  0 },
	{ "modal_show_git",    modal_show_git,    0 },
	{ "nixpkgs_show",      nixpkgs_show,      0 },
	{ "focusdir",          focusdir,          2 },
	{ "swapclients",       swapclients,       1 },
	{ "setratio_h",        setratio_h,        3 },
	{ "setratio_v",        setratio_v,        3 },
	{ "rotate_clients",    rotate_clients,    1 },
	{ "warptomonitor",     warptomonitor,     1 },
	{ "tagtomonitornum",   tagtomonitornum,   2 },
	{ "chvt",              chvt,              2 },
	{ "gamepanel", gamepanel, 0 },
	{ NULL, NULL, 0 }
};

/* Parse a single keybinding line: bind = mod+key action [arg] */
static int config_parse_binding(const char *line)
{
	char mods_key[128], action[128], arg_str[256];
	char *plus, *mods_str, *key_str;
	unsigned int mods;
	xkb_keysym_t keysym;
	const FuncEntry *fe;
	Key *k;
	int n;

	if (runtime_keys_count >= MAX_KEYS) return 0;

	/* Parse: mods+key action [arg] */
	arg_str[0] = '\0';
	n = sscanf(line, "%127s %127s %255[^\n]", mods_key, action, arg_str);
	if (n < 2) return 0;

	/* Split mods+key */
	plus = strrchr(mods_key, '+');
	if (plus) {
		*plus = '\0';
		mods_str = mods_key;
		key_str = plus + 1;
	} else {
		mods_str = "";
		key_str = mods_key;
	}

	/* Parse modifiers */
	mods = config_parse_modifiers(mods_str);

	/* Parse key */
	keysym = config_parse_keysym(key_str);
	if (keysym == XKB_KEY_NoSymbol) {
		wlr_log(WLR_ERROR, "Unknown key: %s", key_str);
		return 0;
	}

	/* Find function */
	for (fe = func_table; fe->name; fe++) {
		if (strcasecmp(action, fe->name) == 0) break;
	}
	if (!fe->name) {
		wlr_log(WLR_ERROR, "Unknown action: %s", action);
		return 0;
	}

	/* Add keybinding */
	k = &runtime_keys[runtime_keys_count];
	k->mod = mods;
	k->keysym = keysym;
	k->func = fe->func;

	/* Parse argument - cast away const to set the value */
	config_trim(arg_str);
	{
		Arg *argp = (Arg *)&k->arg;
		switch (fe->arg_type) {
		case 0: /* none */
			argp->i = 0;
			break;
		case 1: /* int */
			argp->i = atoi(arg_str);
			break;
		case 2: /* uint */
			if (strcmp(arg_str, "all") == 0 || strcmp(arg_str, "~0") == 0)
				argp->ui = ~0u;
			else if (strcasecmp(arg_str, "up") == 0)
				argp->ui = DIR_UP;
			else if (strcasecmp(arg_str, "down") == 0)
				argp->ui = DIR_DOWN;
			else if (strcasecmp(arg_str, "left") == 0)
				argp->ui = DIR_LEFT;
			else if (strcasecmp(arg_str, "right") == 0)
				argp->ui = DIR_RIGHT;
			else
				argp->ui = (unsigned int)atoi(arg_str);
			break;
		case 3: /* float */
			argp->f = (float)atof(arg_str);
			break;
		case 4: /* spawn */
			if (runtime_spawn_cmd_count < MAX_KEYS) {
				runtime_spawn_cmds[runtime_spawn_cmd_count] = config_strdup(arg_str);
				argp->v = runtime_spawn_cmds[runtime_spawn_cmd_count];
				runtime_spawn_cmd_count++;
			}
			break;
		}
	}

	runtime_keys_count++;
	return 1;
}

/* Parse monitor position string */
static MonitorPosition config_parse_monitor_position(const char *pos)
{
	if (!pos || !*pos) return MON_POS_AUTO;
	if (strcasecmp(pos, "master") == 0 || strcasecmp(pos, "primary") == 0 || strcasecmp(pos, "1") == 0)
		return MON_POS_MASTER;
	if (strcasecmp(pos, "left") == 0 || strcasecmp(pos, "2") == 0)
		return MON_POS_LEFT;
	if (strcasecmp(pos, "right") == 0 || strcasecmp(pos, "3") == 0)
		return MON_POS_RIGHT;
	if (strcasecmp(pos, "top-left") == 0 || strcasecmp(pos, "topleft") == 0 || strcasecmp(pos, "4") == 0)
		return MON_POS_TOP_LEFT;
	if (strcasecmp(pos, "top-right") == 0 || strcasecmp(pos, "topright") == 0 || strcasecmp(pos, "5") == 0)
		return MON_POS_TOP_RIGHT;
	if (strcasecmp(pos, "bottom-left") == 0 || strcasecmp(pos, "bottomleft") == 0)
		return MON_POS_BOTTOM_LEFT;
	if (strcasecmp(pos, "bottom-right") == 0 || strcasecmp(pos, "bottomright") == 0)
		return MON_POS_BOTTOM_RIGHT;
	if (strcasecmp(pos, "auto") == 0)
		return MON_POS_AUTO;
	return MON_POS_AUTO;
}

/* Parse transform string */
static int config_parse_transform(const char *str)
{
	if (!str || !*str || strcasecmp(str, "normal") == 0 || strcasecmp(str, "0") == 0)
		return WL_OUTPUT_TRANSFORM_NORMAL;
	if (strcasecmp(str, "90") == 0 || strcasecmp(str, "rotate-90") == 0)
		return WL_OUTPUT_TRANSFORM_90;
	if (strcasecmp(str, "180") == 0 || strcasecmp(str, "rotate-180") == 0)
		return WL_OUTPUT_TRANSFORM_180;
	if (strcasecmp(str, "270") == 0 || strcasecmp(str, "rotate-270") == 0)
		return WL_OUTPUT_TRANSFORM_270;
	if (strcasecmp(str, "flipped") == 0)
		return WL_OUTPUT_TRANSFORM_FLIPPED;
	if (strcasecmp(str, "flipped-90") == 0)
		return WL_OUTPUT_TRANSFORM_FLIPPED_90;
	if (strcasecmp(str, "flipped-180") == 0)
		return WL_OUTPUT_TRANSFORM_FLIPPED_180;
	if (strcasecmp(str, "flipped-270") == 0)
		return WL_OUTPUT_TRANSFORM_FLIPPED_270;
	return WL_OUTPUT_TRANSFORM_NORMAL;
}

/* Parse monitor configuration line:
 * monitor = name position [WxH@Hz] [scale=X] [transform=X] [mfact=X] [nmaster=X] [disabled]
 * Examples:
 *   monitor = HDMI-A-1 master
 *   monitor = DP-1 left 1920x1080@144 scale=1.0
 *   monitor = eDP-1 master 2560x1440@60 scale=1.5
 *   monitor = * auto
 */
static int config_parse_monitor(const char *line)
{
	RuntimeMonitorConfig *mon;
	char name[64], pos_str[32], rest[256];
	char *token, *saveptr, *rest_copy;
	int n;

	if (runtime_monitor_count >= MAX_MONITORS) {
		wlr_log(WLR_ERROR, "Too many monitor configurations (max %d)", MAX_MONITORS);
		return 0;
	}

	/* Parse: name position [rest...] */
	rest[0] = '\0';
	n = sscanf(line, "%63s %31s %255[^\n]", name, pos_str, rest);
	if (n < 2) {
		wlr_log(WLR_ERROR, "Invalid monitor config: %s", line);
		return 0;
	}

	mon = &runtime_monitors[runtime_monitor_count];
	memset(mon, 0, sizeof(*mon));
	strncpy(mon->name, name, sizeof(mon->name) - 1);
	mon->position = config_parse_monitor_position(pos_str);
	mon->width = 0;      /* 0 = auto */
	mon->height = 0;
	mon->refresh = 0;    /* 0 = auto */
	mon->scale = 1.0f;
	mon->mfact = 0.55f;
	mon->nmaster = 1;
	mon->enabled = 1;
	mon->transform = WL_OUTPUT_TRANSFORM_NORMAL;

	if (mon->position == MON_POS_MASTER)
		monitor_master_set = 1;

	/* Parse optional parameters from rest */
	if (rest[0]) {
		rest_copy = config_strdup(rest);
		if (rest_copy) {
			for (token = strtok_r(rest_copy, " \t", &saveptr); token; token = strtok_r(NULL, " \t", &saveptr)) {
				/* Check for WxH or WxH@Hz format */
				int w, h;
				float hz;
				if (sscanf(token, "%dx%d@%f", &w, &h, &hz) == 3) {
					mon->width = w;
					mon->height = h;
					mon->refresh = hz;
				} else if (sscanf(token, "%dx%d", &w, &h) == 2) {
					mon->width = w;
					mon->height = h;
				} else if (strncasecmp(token, "scale=", 6) == 0) {
					mon->scale = (float)atof(token + 6);
					if (mon->scale < 0.5f) mon->scale = 0.5f;
					if (mon->scale > 4.0f) mon->scale = 4.0f;
				} else if (strncasecmp(token, "transform=", 10) == 0) {
					mon->transform = config_parse_transform(token + 10);
				} else if (strncasecmp(token, "mfact=", 6) == 0) {
					mon->mfact = (float)atof(token + 6);
					if (mon->mfact < 0.1f) mon->mfact = 0.1f;
					if (mon->mfact > 0.9f) mon->mfact = 0.9f;
				} else if (strncasecmp(token, "nmaster=", 8) == 0) {
					mon->nmaster = atoi(token + 8);
					if (mon->nmaster < 1) mon->nmaster = 1;
				} else if (strcasecmp(token, "disabled") == 0 || strcasecmp(token, "off") == 0) {
					mon->enabled = 0;
				}
			}
			free(rest_copy);
		}
	}

	wlr_log(WLR_INFO, "Monitor config: %s at %s (%dx%d@%.2f scale=%.2f)",
		mon->name,
		pos_str,
		mon->width, mon->height, mon->refresh, mon->scale);

	runtime_monitor_count++;
	return 1;
}

/* Find runtime config for a monitor by name */
static RuntimeMonitorConfig *find_monitor_config(const char *name)
{
	int i;
	for (i = 0; i < runtime_monitor_count; i++) {
		/* Support wildcards: "*" matches all, "DP-*" matches DP-1, DP-2, etc. */
		const char *pattern = runtime_monitors[i].name;
		if (strcmp(pattern, "*") == 0)
			return &runtime_monitors[i];
		if (strchr(pattern, '*')) {
			/* Simple prefix wildcard: "DP-*" */
			size_t prefix_len = strchr(pattern, '*') - pattern;
			if (strncmp(name, pattern, prefix_len) == 0)
				return &runtime_monitors[i];
		} else if (strcmp(name, pattern) == 0) {
			return &runtime_monitors[i];
		}
	}
	return NULL;
}

/* Get monitor connector type priority (lower = higher priority for master) */
static int get_connector_priority(const char *name)
{
	/* Priority: HDMI > DP > eDP > others */
	if (strncmp(name, "HDMI", 4) == 0) return 1;
	if (strncmp(name, "DP-", 3) == 0) return 2;
	if (strncmp(name, "eDP", 3) == 0) return 3;
	if (strncmp(name, "VGA", 3) == 0) return 4;
	if (strncmp(name, "DVI", 3) == 0) return 5;
	return 10;
}

/* Calculate monitor position based on slot and other monitors */
static void calculate_monitor_position(Monitor *m, RuntimeMonitorConfig *cfg, int *out_x, int *out_y)
{
	Monitor *other;
	int master_x = 0, master_y = 0, master_w = 1920, master_h = 1080;
	int left_x = 0, left_w = 1920;
	int right_x = 0;

	/* Find master monitor dimensions for positioning */
	wl_list_for_each(other, &mons, link) {
		RuntimeMonitorConfig *other_cfg = find_monitor_config(other->wlr_output->name);
		if (other_cfg && other_cfg->position == MON_POS_MASTER) {
			master_x = other->m.x;
			master_y = other->m.y;
			master_w = other->m.width > 0 ? other->m.width : 1920;
			master_h = other->m.height > 0 ? other->m.height : 1080;
			break;
		}
	}

	/* Find left monitor for top-left positioning */
	wl_list_for_each(other, &mons, link) {
		RuntimeMonitorConfig *other_cfg = find_monitor_config(other->wlr_output->name);
		if (other_cfg && other_cfg->position == MON_POS_LEFT) {
			left_x = other->m.x;
			left_w = other->m.width > 0 ? other->m.width : 1920;
			break;
		}
	}

	/* Find right monitor x position for top-right positioning */
	wl_list_for_each(other, &mons, link) {
		RuntimeMonitorConfig *other_cfg = find_monitor_config(other->wlr_output->name);
		if (other_cfg && other_cfg->position == MON_POS_RIGHT) {
			right_x = other->m.x;
			break;
		}
	}

	/* Get this monitor's dimensions */
	int my_w = m->m.width > 0 ? m->m.width : (cfg->width > 0 ? cfg->width : 1920);
	int my_h = m->m.height > 0 ? m->m.height : (cfg->height > 0 ? cfg->height : 1080);

	switch (cfg->position) {
	case MON_POS_MASTER:
		*out_x = 0;
		*out_y = 0;
		break;
	case MON_POS_LEFT:
		*out_x = master_x - my_w;
		*out_y = master_y;
		break;
	case MON_POS_RIGHT:
		*out_x = master_x + master_w;
		*out_y = master_y;
		break;
	case MON_POS_TOP_LEFT:
		*out_x = left_x;
		*out_y = master_y - my_h;
		break;
	case MON_POS_TOP_RIGHT:
		*out_x = right_x > 0 ? right_x : (master_x + master_w);
		*out_y = master_y - my_h;
		break;
	case MON_POS_BOTTOM_LEFT:
		*out_x = left_x;
		*out_y = master_y + master_h;
		break;
	case MON_POS_BOTTOM_RIGHT:
		*out_x = right_x > 0 ? right_x : (master_x + master_w);
		*out_y = master_y + master_h;
		break;
	case MON_POS_AUTO:
	default:
		*out_x = -1;  /* Auto-placement */
		*out_y = -1;
		break;
	}
}

static void
load_config(void)
{
	const char *home = getenv("HOME");
	const char *config_home = getenv("XDG_CONFIG_HOME");
	char config_path[PATH_MAX];
	char fallback_path[PATH_MAX];
	FILE *f;
	char line[1024];
	const char *xdg_data_dirs;
	char *data_dirs_copy, *dir, *saveptr;
	int found_fallback = 0;

	/* Try XDG_CONFIG_HOME first, then ~/.config */
	if (config_home && *config_home) {
		snprintf(config_path, sizeof(config_path), "%s/nixlytile/config.conf", config_home);
	} else if (home) {
		snprintf(config_path, sizeof(config_path), "%s/.config/nixlytile/config.conf", home);
	} else {
		return; /* No home directory, use defaults */
	}

	/* Cache the config path for hot-reload watching */
	strncpy(config_path_cached, config_path, sizeof(config_path_cached) - 1);

	f = fopen(config_path, "r");
	if (!f) {
		/* Try to find config.conf.example in XDG_DATA_DIRS */
		xdg_data_dirs = getenv("XDG_DATA_DIRS");
		if (xdg_data_dirs && *xdg_data_dirs) {
			data_dirs_copy = strdup(xdg_data_dirs);
			if (data_dirs_copy) {
				for (dir = strtok_r(data_dirs_copy, ":", &saveptr); dir; dir = strtok_r(NULL, ":", &saveptr)) {
					snprintf(fallback_path, sizeof(fallback_path), "%s/nixlytile/config.conf.example", dir);
					f = fopen(fallback_path, "r");
					if (f) {
						found_fallback = 1;
						strncpy(config_path_cached, fallback_path, sizeof(config_path_cached) - 1);
						wlr_log(WLR_INFO, "Using fallback config from %s", fallback_path);
						break;
					}
				}
				free(data_dirs_copy);
			}
		}
		if (!found_fallback) {
			wlr_log(WLR_INFO, "No config file found at %s, using defaults", config_path);
			return;
		}
	} else {
		wlr_log(WLR_INFO, "Loading config from %s", config_path);
	}

	while (fgets(line, sizeof(line), f)) {
		char *p = line;
		char *key, *value, *eq;

		/* Skip leading whitespace */
		while (*p && isspace((unsigned char)*p)) p++;

		/* Skip empty lines and comments */
		if (!*p || *p == '#' || *p == ';') continue;

		/* Remove trailing newline/whitespace */
		config_trim(p);

		/* Find '=' separator */
		eq = strchr(p, '=');
		if (!eq) continue;

		*eq = '\0';
		key = p;
		value = eq + 1;

		config_trim(key);
		config_trim(value);

		/* Remove quotes from value if present */
		if (*value == '"' || *value == '\'') {
			char quote = *value++;
			char *end = strrchr(value, quote);
			if (end) *end = '\0';
		}

		/* Handle special config types */
		if (strcmp(key, "bind") == 0) {
			config_parse_binding(value);
		} else if (strcmp(key, "monitor") == 0) {
			config_parse_monitor(value);
		} else if (*key && *value) {
			config_set_value(key, value);
		}
	}

	fclose(f);
}

/* Initialize keybindings - uses runtime keys if any were loaded, otherwise defaults */
static void
init_keybindings(void)
{
	if (runtime_keys_count > 0) {
		keys = runtime_keys;
		keys_count = runtime_keys_count;
		wlr_log(WLR_INFO, "Using %zu custom keybindings from config", keys_count);
	} else {
		keys = default_keys;
		keys_count = LENGTH(default_keys);
		wlr_log(WLR_INFO, "Using %zu default keybindings", keys_count);
	}
}

/* Reset runtime config state before reload */
static void
reset_runtime_config(void)
{
	int i;

	/* Free allocated spawn commands */
	for (i = 0; i < runtime_spawn_cmd_count; i++) {
		if (runtime_spawn_cmds[i]) {
			free(runtime_spawn_cmds[i]);
			runtime_spawn_cmds[i] = NULL;
		}
	}
	runtime_spawn_cmd_count = 0;

	/* Reset keybindings */
	runtime_keys_count = 0;
	memset(runtime_keys, 0, sizeof(runtime_keys));

	/* Reset monitor config */
	runtime_monitor_count = 0;
	monitor_master_set = 0;
	memset(runtime_monitors, 0, sizeof(runtime_monitors));
}

/* Reload config file and apply changes */
static void
reload_config(void)
{
	Monitor *m;
	int i;

	wlr_log(WLR_INFO, "Hot-reloading config file...");

	/* Reset runtime state */
	reset_runtime_config();

	/* Re-load config */
	load_config();

	/* Re-initialize keybindings */
	init_keybindings();

	/* Update visual settings on all monitors */
	wl_list_for_each(m, &mons, link) {
		/* Update gaps setting */
		m->gaps = gaps;

		/* Update border width on all clients */
		Client *c;
		wl_list_for_each(c, &clients, link) {
			if (c->mon == m && !c->isfullscreen)
				c->bw = borderpx;
		}

		/* Re-arrange with new settings (this also updates statusbar) */
		arrange(m);
	}

	/* Update root background color */
	if (root_bg)
		wlr_scene_rect_set_color(root_bg, rootcolor);

	/* Update locked background if exists */
	if (locked_bg)
		wlr_scene_rect_set_color(locked_bg, (float[]){0.1f, 0.1f, 0.1f, 1.0f});

	/* Reload font if needed */
	if (statusfont.font) {
		struct StatusFont new_font = {0};
		if (loadstatusfont()) {
			/* Font loaded successfully, update tray icons */
			tray_update_icons_text();
		}
		(void)new_font;
	}

	/* Force redraw of all monitors */
	wl_list_for_each(m, &mons, link) {
		if (m->wlr_output)
			wlr_output_schedule_frame(m->wlr_output);
	}

	wlr_log(WLR_INFO, "Config reload complete: %zu keybindings, %d monitors configured",
		keys_count, runtime_monitor_count);
}

/* Timer callback to re-add config watch */
static int
config_rewatch_timer_cb(void *data)
{
	(void)data;

	if (config_needs_rewatch && config_path_cached[0]) {
		config_watch_wd = inotify_add_watch(config_inotify_fd,
			config_path_cached, IN_MODIFY | IN_CLOSE_WRITE | IN_MOVED_TO | IN_DELETE_SELF | IN_MOVE_SELF);
		config_needs_rewatch = 0;
		reload_config();
	}

	return 0;
}

/* Handle inotify events for config file changes */
static int
config_watch_handler(int fd, uint32_t mask, void *data)
{
	char buf[4096] __attribute__((aligned(__alignof__(struct inotify_event))));
	const struct inotify_event *event;
	ssize_t len;
	char *ptr;
	int should_reload = 0;

	(void)mask;
	(void)data;

	while ((len = read(fd, buf, sizeof(buf))) > 0) {
		for (ptr = buf; ptr < buf + len; ptr += sizeof(struct inotify_event) + event->len) {
			event = (const struct inotify_event *)ptr;

			/* Check for modify, close_write, or move events */
			if (event->mask & (IN_MODIFY | IN_CLOSE_WRITE | IN_MOVED_TO)) {
				should_reload = 1;
			}

			/* If the file was deleted or moved away, re-add watch */
			if (event->mask & (IN_DELETE_SELF | IN_MOVE_SELF)) {
				if (config_watch_wd >= 0) {
					inotify_rm_watch(config_inotify_fd, config_watch_wd);
					config_watch_wd = -1;
				}
				/* Schedule timer to re-add watch (non-blocking) */
				config_needs_rewatch = 1;
				if (config_rewatch_timer)
					wl_event_source_timer_update(config_rewatch_timer, 100); /* 100ms */
				/* Don't reload now, timer will do it */
				continue;
			}
		}
	}

	if (should_reload)
		reload_config();

	return 0;
}

/* Set up inotify watch for config file */
static void
setup_config_watch(void)
{
	char dir_path[PATH_MAX];
	char *slash;

	if (!config_path_cached[0]) {
		wlr_log(WLR_INFO, "No config path to watch");
		return;
	}

	/* Create inotify instance */
	config_inotify_fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC);
	if (config_inotify_fd < 0) {
		wlr_log(WLR_ERROR, "Failed to create inotify instance: %s", strerror(errno));
		return;
	}

	/* Watch the config file for changes */
	config_watch_wd = inotify_add_watch(config_inotify_fd, config_path_cached,
		IN_MODIFY | IN_CLOSE_WRITE | IN_MOVED_TO | IN_DELETE_SELF | IN_MOVE_SELF);

	if (config_watch_wd < 0) {
		/* File doesn't exist yet, watch the directory instead */
		strncpy(dir_path, config_path_cached, sizeof(dir_path) - 1);
		slash = strrchr(dir_path, '/');
		if (slash) {
			*slash = '\0';
			/* Create directory if it doesn't exist */
			mkdir(dir_path, 0755);
			config_watch_wd = inotify_add_watch(config_inotify_fd, dir_path,
				IN_CREATE | IN_MOVED_TO);
		}
		if (config_watch_wd < 0) {
			wlr_log(WLR_ERROR, "Failed to watch config: %s", strerror(errno));
			close(config_inotify_fd);
			config_inotify_fd = -1;
			return;
		}
		wlr_log(WLR_INFO, "Watching config directory for file creation: %s", dir_path);
	} else {
		wlr_log(WLR_INFO, "Watching config file for changes: %s", config_path_cached);
	}

	/* Add to event loop */
	config_watch_source = wl_event_loop_add_fd(event_loop, config_inotify_fd,
		WL_EVENT_READABLE, config_watch_handler, NULL);

	/* Create timer for delayed re-watch */
	config_rewatch_timer = wl_event_loop_add_timer(event_loop, config_rewatch_timer_cb, NULL);
	if (!config_watch_source) {
		wlr_log(WLR_ERROR, "Failed to add config watcher to event loop");
		close(config_inotify_fd);
		config_inotify_fd = -1;
	}
}

static void
ensure_shell_env(void)
{
	const char *shell = getenv("SHELL");
	struct passwd *pw;
	int looks_like_minimal_nix_bash = 0;

	if (shell && *shell) {
		looks_like_minimal_nix_bash = strstr(shell, "/nix/store/") &&
				strstr(shell, "bash-") &&
				!strstr(shell, "bash-interactive");
		if (!looks_like_minimal_nix_bash)
			return;
	}

	pw = getpwuid(getuid());
	if (pw && pw->pw_shell && *pw->pw_shell)
		setenv("SHELL", pw->pw_shell, 1);
}

void
setup(void)
{
	int drm_fd, i, sig[] = {SIGCHLD, SIGINT, SIGTERM, SIGPIPE};
	struct sigaction sa = {.sa_flags = SA_RESTART, .sa_handler = handlesig};
	sigemptyset(&sa.sa_mask);

	for (i = 0; i < (int)LENGTH(sig); i++)
		sigaction(sig[i], &sa, NULL);

	wlr_log_init(log_level, NULL);

	/* Make sure spawned terminals get the real login shell, not the minimal wrapper shell */
	ensure_shell_env();

	/* The Wayland display is managed by libwayland. It handles accepting
	 * clients from the Unix socket, manging Wayland globals, and so on. */
	dpy = wl_display_create();
	event_loop = wl_display_get_event_loop(dpy);
	wl_list_init(&mons);
	wl_list_init(&tray_items);
	status_timer = wl_event_loop_add_timer(event_loop, updatestatusclock, NULL);
	status_cpu_timer = wl_event_loop_add_timer(event_loop, updatestatuscpu, NULL);
	status_hover_timer = wl_event_loop_add_timer(event_loop, updatehoverfade, NULL);
	cache_update_timer = wl_event_loop_add_timer(event_loop, cache_update_timer_cb, NULL);
	nixpkgs_cache_timer = wl_event_loop_add_timer(event_loop, nixpkgs_cache_timer_cb, NULL);
	tray_init();
	fcft_initialized = fcft_init(FCFT_LOG_COLORIZE_NEVER, 0, FCFT_LOG_CLASS_ERROR);
	if (!fcft_initialized)
		die("couldn't initialize fcft");
	init_net_icon_paths();
	if (!loadstatusfont())
		die("couldn't load statusbar font");
	tray_update_icons_text();
	ensure_desktop_entries_loaded();
	backlight_available = findbacklightdevice(backlight_brightness_path,
			sizeof(backlight_brightness_path),
			backlight_max_path, sizeof(backlight_max_path));
	bluetooth_available = findbluetoothdevice();

	/* The backend is a wlroots feature which abstracts the underlying input and
	 * output hardware. The autocreate option will choose the most suitable
	 * backend based on the current environment, such as opening an X11 window
	 * if an X11 server is running. */
	if (!(backend = wlr_backend_autocreate(event_loop, &session)))
		die("couldn't create backend");

	/* Initialize the scene graph used to lay out windows */
	scene = wlr_scene_create();
	root_bg = wlr_scene_rect_create(&scene->tree, 0, 0, rootcolor);
	for (i = 0; i < NUM_LAYERS; i++)
		layers[i] = wlr_scene_tree_create(&scene->tree);
	drag_icon = wlr_scene_tree_create(&scene->tree);
	wlr_scene_node_place_below(&drag_icon->node, &layers[LyrBlock]->node);

	/* Autocreates a renderer, either Pixman, GLES2 or Vulkan for us. The user
	 * can also specify a renderer using the WLR_RENDERER env var.
	 * The renderer is responsible for defining the various pixel formats it
	 * supports for shared memory, this configures that for clients. */
	if (!(drw = wlr_renderer_autocreate(backend)))
		die("couldn't create renderer");
	wl_signal_add(&drw->events.lost, &gpu_reset);

	/* Create shm, drm and linux_dmabuf interfaces by ourselves.
	 * The simplest way is to call:
	 *      wlr_renderer_init_wl_display(drw);
	 * but we need to create the linux_dmabuf interface manually to integrate it
	 * with wlr_scene. */
	wlr_renderer_init_wl_shm(drw, dpy);

	if (wlr_renderer_get_texture_formats(drw, WLR_BUFFER_CAP_DMABUF)) {
		wlr_drm_create(dpy, drw);
		wlr_scene_set_linux_dmabuf_v1(scene,
				wlr_linux_dmabuf_v1_create_with_renderer(dpy, 5, drw));
	}

	if ((drm_fd = wlr_renderer_get_drm_fd(drw)) >= 0 && drw->features.timeline
			&& backend->features.timeline)
		wlr_linux_drm_syncobj_manager_v1_create(dpy, 1, drm_fd);

	/* Autocreates an allocator for us.
	 * The allocator is the bridge between the renderer and the backend. It
	 * handles the buffer creation, allowing wlroots to render onto the
	 * screen */
	if (!(alloc = wlr_allocator_autocreate(backend, drw)))
		die("couldn't create allocator");

	/* This creates some hands-off wlroots interfaces. The compositor is
	 * necessary for clients to allocate surfaces and the data device manager
	 * handles the clipboard. Each of these wlroots interfaces has room for you
	 * to dig your fingers in and play with their behavior if you want. Note that
	 * the clients cannot set the selection directly without compositor approval,
	 * see the setsel() function. */
	compositor = wlr_compositor_create(dpy, 6, drw);
	wlr_subcompositor_create(dpy);
	wlr_data_device_manager_create(dpy);
	wlr_export_dmabuf_manager_v1_create(dpy);
	wlr_screencopy_manager_v1_create(dpy);
	wlr_data_control_manager_v1_create(dpy);
	wlr_primary_selection_v1_device_manager_create(dpy);
	wlr_viewporter_create(dpy);
	wlr_single_pixel_buffer_manager_v1_create(dpy);
	wlr_fractional_scale_manager_v1_create(dpy, 1);
	wlr_presentation_create(dpy, backend, 2);
	wlr_alpha_modifier_v1_create(dpy);
	content_type_mgr = wlr_content_type_manager_v1_create(dpy, 1);
	tearing_control_mgr = wlr_tearing_control_manager_v1_create(dpy, 1);

	/* Initializes the interface used to implement urgency hints */
	activation = wlr_xdg_activation_v1_create(dpy);
	wl_signal_add(&activation->events.request_activate, &request_activate);

	wlr_scene_set_gamma_control_manager_v1(scene, wlr_gamma_control_manager_v1_create(dpy));

	power_mgr = wlr_output_power_manager_v1_create(dpy);
	wl_signal_add(&power_mgr->events.set_mode, &output_power_mgr_set_mode);

	/* Creates an output layout, which is a wlroots utility for working with an
	 * arrangement of screens in a physical layout. */
	output_layout = wlr_output_layout_create(dpy);
	wl_signal_add(&output_layout->events.change, &layout_change);

    wlr_xdg_output_manager_v1_create(dpy, output_layout);

	/* Configure a listener to be notified when new outputs are available on the
	 * backend. */
	wl_signal_add(&backend->events.new_output, &new_output);

	/* Set up our client lists, the xdg-shell and the layer-shell. The xdg-shell is a
	 * Wayland protocol which is used for application windows. For more
	 * detail on shells, refer to the article:
	 *
	 * https://drewdevault.com/2018/07/29/Wayland-shells.html
	 */
	wl_list_init(&clients);
	wl_list_init(&fstack);
	wl_list_init(&text_inputs);

	xdg_shell = wlr_xdg_shell_create(dpy, 6);
	wl_signal_add(&xdg_shell->events.new_toplevel, &new_xdg_toplevel);
	wl_signal_add(&xdg_shell->events.new_popup, &new_xdg_popup);

	layer_shell = wlr_layer_shell_v1_create(dpy, 3);
	wl_signal_add(&layer_shell->events.new_surface, &new_layer_surface);

	idle_notifier = wlr_idle_notifier_v1_create(dpy);

	idle_inhibit_mgr = wlr_idle_inhibit_v1_create(dpy);
	wl_signal_add(&idle_inhibit_mgr->events.new_inhibitor, &new_idle_inhibitor);

	session_lock_mgr = wlr_session_lock_manager_v1_create(dpy);
	wl_signal_add(&session_lock_mgr->events.new_lock, &new_session_lock);
	locked_bg = wlr_scene_rect_create(layers[LyrBlock], sgeom.width, sgeom.height,
			(float [4]){0.1f, 0.1f, 0.1f, 1.0f});
	wlr_scene_node_set_enabled(&locked_bg->node, 0);

	/* Use decoration protocols to negotiate server-side decorations */
	wlr_server_decoration_manager_set_default_mode(
			wlr_server_decoration_manager_create(dpy),
			WLR_SERVER_DECORATION_MANAGER_MODE_SERVER);
	xdg_decoration_mgr = wlr_xdg_decoration_manager_v1_create(dpy);
	wl_signal_add(&xdg_decoration_mgr->events.new_toplevel_decoration, &new_xdg_decoration);

	pointer_constraints = wlr_pointer_constraints_v1_create(dpy);
	wl_signal_add(&pointer_constraints->events.new_constraint, &new_pointer_constraint);

	relative_pointer_mgr = wlr_relative_pointer_manager_v1_create(dpy);

	/*
	 * Creates a cursor, which is a wlroots utility for tracking the cursor
	 * image shown on screen.
	 */
	cursor = wlr_cursor_create();
	wlr_cursor_attach_output_layout(cursor, output_layout);

	/* Creates an xcursor manager, another wlroots utility which loads up
	 * Xcursor themes to source cursor images from and makes sure that cursor
	 * images are available at all scale factors on the screen (necessary for
	 * HiDPI support). Scaled cursors will be loaded with each output. */
	cursor_mgr = wlr_xcursor_manager_create(NULL, 24);
	setenv("XCURSOR_SIZE", "24", 1);

	/*
	 * wlr_cursor *only* displays an image on screen. It does not move around
	 * when the pointer moves. However, we can attach input devices to it, and
	 * it will generate aggregate events for all of them. In these events, we
	 * can choose how we want to process them, forwarding them to clients and
	 * moving the cursor around. More detail on this process is described in
	 * https://drewdevault.com/2018/07/17/Input-handling-in-wlroots.html
	 *
	 * And more comments are sprinkled throughout the notify functions above.
	 */
	wl_signal_add(&cursor->events.motion, &cursor_motion);
	wl_signal_add(&cursor->events.motion_absolute, &cursor_motion_absolute);
	wl_signal_add(&cursor->events.button, &cursor_button);
	wl_signal_add(&cursor->events.axis, &cursor_axis);
	wl_signal_add(&cursor->events.frame, &cursor_frame);

	cursor_shape_mgr = wlr_cursor_shape_manager_v1_create(dpy, 1);
	wl_signal_add(&cursor_shape_mgr->events.request_set_shape, &request_set_cursor_shape);

	/*
	 * Configures a seat, which is a single "seat" at which a user sits and
	 * operates the computer. This conceptually includes up to one keyboard,
	 * pointer, touch, and drawing tablet device. We also rig up a listener to
	 * let us know when new input devices are available on the backend.
	 */
	wl_signal_add(&backend->events.new_input, &new_input_device);
	virtual_keyboard_mgr = wlr_virtual_keyboard_manager_v1_create(dpy);
	wl_signal_add(&virtual_keyboard_mgr->events.new_virtual_keyboard,
			&new_virtual_keyboard);
	virtual_pointer_mgr = wlr_virtual_pointer_manager_v1_create(dpy);
    wl_signal_add(&virtual_pointer_mgr->events.new_virtual_pointer,
            &new_virtual_pointer);
	text_input_mgr = wlr_text_input_manager_v3_create(dpy);
	wl_signal_add(&text_input_mgr->events.text_input, &new_text_input);

	seat = wlr_seat_create(dpy, "seat0");
	wl_signal_add(&seat->events.request_set_cursor, &request_cursor);
	wl_signal_add(&seat->events.request_set_selection, &request_set_sel);
	wl_signal_add(&seat->events.request_set_primary_selection, &request_set_psel);
	wl_signal_add(&seat->events.request_start_drag, &request_start_drag);
	wl_signal_add(&seat->events.start_drag, &start_drag);

	kb_group = createkeyboardgroup();
	wl_list_init(&kb_group->destroy.link);

	output_mgr = wlr_output_manager_v1_create(dpy);
	wl_signal_add(&output_mgr->events.apply, &output_mgr_apply);
	wl_signal_add(&output_mgr->events.test, &output_mgr_test);

	/* Make sure XWayland clients don't connect to the parent X server,
	 * e.g when running in the x11 backend or the wayland backend and the
	 * compositor has Xwayland support */
	unsetenv("DISPLAY");
#ifdef XWAYLAND
	/*
	 * Initialise the XWayland X server.
	 * It will be started when the first X client is started.
	 */
	if ((xwayland = wlr_xwayland_create(dpy, compositor, 1))) {
		wl_signal_add(&xwayland->events.ready, &xwayland_ready);
		wl_signal_add(&xwayland->events.new_surface, &new_xwayland_surface);

		setenv("DISPLAY", xwayland->display_name, 1);
	} else {
		wlr_log(WLR_ERROR, "failed to setup XWayland X server, continuing without it");
	}
#endif

	initial_status_refresh();
	if (status_timer)
		schedule_status_timer();
	if (status_cpu_timer) {
		init_status_refresh_tasks();
		schedule_next_status_refresh();
	}
	if (!wifi_scan_timer)
		wifi_scan_timer = wl_event_loop_add_timer(event_loop, wifi_scan_timer_cb, NULL);
	if (status_hover_timer)
		wl_event_source_timer_update(status_hover_timer, 0);
}

/* Detect all GPUs in the system */
static void
detect_gpus(void)
{
	DIR *dri_dir;
	struct dirent *ent;
	char path[256], link_target[256], driver_link[256];
	ssize_t len;
	int i;

	detected_gpu_count = 0;
	discrete_gpu_idx = -1;
	integrated_gpu_idx = -1;

	dri_dir = opendir("/sys/class/drm");
	if (!dri_dir) {
		wlr_log(WLR_ERROR, "Failed to open /sys/class/drm for GPU detection");
		return;
	}

	while ((ent = readdir(dri_dir)) != NULL && detected_gpu_count < MAX_GPUS) {
		int card_num;
		GpuInfo *gpu;

		/* Only process cardX entries (not renderDX or other entries) */
		if (sscanf(ent->d_name, "card%d", &card_num) != 1)
			continue;
		/* Skip card0-HDMI-A-1 style entries */
		if (strchr(ent->d_name, '-'))
			continue;

		gpu = &detected_gpus[detected_gpu_count];
		memset(gpu, 0, sizeof(*gpu));
		gpu->card_index = card_num;

		snprintf(gpu->card_path, sizeof(gpu->card_path), "/dev/dri/card%d", card_num);

		/* Find corresponding render node */
		snprintf(path, sizeof(path), "/sys/class/drm/card%d/device", card_num);
		DIR *dev_dir = opendir(path);
		if (dev_dir) {
			struct dirent *dev_ent;
			while ((dev_ent = readdir(dev_dir)) != NULL) {
				int render_num;
				if (sscanf(dev_ent->d_name, "drm/renderD%d", &render_num) == 1 ||
				    (strncmp(dev_ent->d_name, "drm", 3) == 0)) {
					/* Check for renderDXXX in drm subdirectory */
					char drm_path[300];
					snprintf(drm_path, sizeof(drm_path), "%s/drm", path);
					DIR *drm_dir = opendir(drm_path);
					if (drm_dir) {
						struct dirent *drm_ent;
						while ((drm_ent = readdir(drm_dir)) != NULL) {
							if (sscanf(drm_ent->d_name, "renderD%d", &render_num) == 1) {
								gpu->render_index = render_num;
								snprintf(gpu->render_path, sizeof(gpu->render_path),
									"/dev/dri/renderD%d", render_num);
								break;
							}
						}
						closedir(drm_dir);
					}
					break;
				}
			}
			closedir(dev_dir);
		}

		/* Get driver name from symlink */
		snprintf(driver_link, sizeof(driver_link),
			"/sys/class/drm/card%d/device/driver", card_num);
		len = readlink(driver_link, link_target, sizeof(link_target) - 1);
		if (len > 0) {
			link_target[len] = '\0';
			const char *driver_name = strrchr(link_target, '/');
			driver_name = driver_name ? driver_name + 1 : link_target;
			snprintf(gpu->driver, sizeof(gpu->driver), "%s", driver_name);
		}

		/* Get PCI slot from uevent */
		snprintf(path, sizeof(path), "/sys/class/drm/card%d/device/uevent", card_num);
		FILE *f = fopen(path, "r");
		if (f) {
			char line[256];
			while (fgets(line, sizeof(line), f)) {
				if (strncmp(line, "PCI_SLOT_NAME=", 14) == 0) {
					char *nl = strchr(line + 14, '\n');
					if (nl) *nl = '\0';
					snprintf(gpu->pci_slot, sizeof(gpu->pci_slot), "%s", line + 14);
					/* Create underscore version for DRI_PRIME */
					snprintf(gpu->pci_slot_underscore, sizeof(gpu->pci_slot_underscore),
						"pci-%s", gpu->pci_slot);
					for (char *p = gpu->pci_slot_underscore; *p; p++) {
						if (*p == ':' || *p == '.') *p = '_';
					}
					break;
				}
			}
			fclose(f);
		}

		/* Determine vendor and if discrete */
		if (strcmp(gpu->driver, "nvidia") == 0) {
			gpu->vendor = GPU_VENDOR_NVIDIA;
			gpu->is_discrete = 1;
		} else if (strcmp(gpu->driver, "nouveau") == 0) {
			gpu->vendor = GPU_VENDOR_NVIDIA;
			gpu->is_discrete = 1;
		} else if (strcmp(gpu->driver, "amdgpu") == 0 || strcmp(gpu->driver, "radeon") == 0) {
			gpu->vendor = GPU_VENDOR_AMD;
			/* Check if integrated (APU) or discrete - look at device class or boot_vga */
			snprintf(path, sizeof(path), "/sys/class/drm/card%d/device/boot_vga", card_num);
			f = fopen(path, "r");
			if (f) {
				int boot_vga = 0;
				if (fscanf(f, "%d", &boot_vga) == 1) {
					/* boot_vga=1 typically means primary/integrated on laptops */
					/* But for AMD, we also check if another GPU exists */
					gpu->is_discrete = !boot_vga;
				}
				fclose(f);
			} else {
				/* If no boot_vga, assume discrete */
				gpu->is_discrete = 1;
			}
		} else if (strcmp(gpu->driver, "i915") == 0 || strcmp(gpu->driver, "xe") == 0) {
			gpu->vendor = GPU_VENDOR_INTEL;
			gpu->is_discrete = 0; /* Intel iGPU */
		} else {
			gpu->vendor = GPU_VENDOR_UNKNOWN;
			gpu->is_discrete = 0;
		}

		wlr_log(WLR_INFO, "GPU %d: %s [%s] driver=%s discrete=%d pci=%s",
			detected_gpu_count, gpu->card_path, gpu->render_path,
			gpu->driver, gpu->is_discrete, gpu->pci_slot);

		detected_gpu_count++;
	}
	closedir(dri_dir);

	/* Find best discrete and integrated GPU */
	for (i = 0; i < detected_gpu_count; i++) {
		GpuInfo *gpu = &detected_gpus[i];
		if (gpu->is_discrete) {
			/* Prefer Nvidia > AMD for discrete */
			if (discrete_gpu_idx < 0 ||
			    (gpu->vendor == GPU_VENDOR_NVIDIA && detected_gpus[discrete_gpu_idx].vendor != GPU_VENDOR_NVIDIA)) {
				discrete_gpu_idx = i;
			}
		} else {
			if (integrated_gpu_idx < 0)
				integrated_gpu_idx = i;
		}
	}

	/* If AMD GPU was marked as not-discrete but no other integrated exists, it might be wrong */
	if (discrete_gpu_idx < 0 && detected_gpu_count > 1) {
		/* Multiple GPUs but none marked discrete - pick non-Intel as discrete */
		for (i = 0; i < detected_gpu_count; i++) {
			if (detected_gpus[i].vendor != GPU_VENDOR_INTEL) {
				discrete_gpu_idx = i;
				detected_gpus[i].is_discrete = 1;
				break;
			}
		}
	}

	if (discrete_gpu_idx >= 0) {
		GpuInfo *dgpu = &detected_gpus[discrete_gpu_idx];
		wlr_log(WLR_INFO, "Selected discrete GPU: card%d (%s) driver=%s",
			dgpu->card_index, dgpu->pci_slot, dgpu->driver);
	} else {
		wlr_log(WLR_INFO, "No discrete GPU detected");
	}
}

/* Programs that should use dedicated GPU */
static const char *dgpu_programs[] = {
	"steam", "gamescope", "mangohud",
	"blender", "freecad", "openscad", "kicad",
	"obs", "obs-studio", "kdenlive", "davinci-resolve",
	"godot", "unity", "unreal",
	"wine", "wine64", "proton",
	"vkcube", "vulkaninfo", "glxgears", "glxinfo",
	"darktable", "rawtherapee", "gimp",
	"prusa-slicer", "cura", "superslicer",
	NULL
};

static int
should_use_dgpu(const char *cmd)
{
	const char *base;
	int i;

	if (!cmd)
		return 0;

	/* Get basename of command */
	base = strrchr(cmd, '/');
	base = base ? base + 1 : cmd;

	for (i = 0; dgpu_programs[i]; i++) {
		if (strcasecmp(base, dgpu_programs[i]) == 0)
			return 1;
		/* Also check if command contains the program name (for wrappers) */
		if (strcasestr(cmd, dgpu_programs[i]))
			return 1;
	}
	return 0;
}

static void
set_dgpu_env(void)
{
	GpuInfo *dgpu;

	/* No discrete GPU detected - nothing to do */
	if (discrete_gpu_idx < 0 || discrete_gpu_idx >= detected_gpu_count)
		return;

	dgpu = &detected_gpus[discrete_gpu_idx];

	switch (dgpu->vendor) {
	case GPU_VENDOR_NVIDIA:
		/* PRIME render offload for NVIDIA proprietary driver */
		setenv("__NV_PRIME_RENDER_OFFLOAD", "1", 1);
		setenv("__NV_PRIME_RENDER_OFFLOAD_PROVIDER", "NVIDIA-G0", 1);
		setenv("__GLX_VENDOR_LIBRARY_NAME", "nvidia", 1);
		setenv("__VK_LAYER_NV_optimus", "NVIDIA_only", 1);
		/* Also set DRI_PRIME in case nouveau is used instead */
		if (dgpu->pci_slot_underscore[0])
			setenv("DRI_PRIME", dgpu->pci_slot_underscore, 1);
		else
			setenv("DRI_PRIME", "1", 1);
		break;

	case GPU_VENDOR_AMD:
		/* DRI_PRIME with specific PCI device for AMD */
		if (dgpu->pci_slot_underscore[0])
			setenv("DRI_PRIME", dgpu->pci_slot_underscore, 1);
		else
			setenv("DRI_PRIME", "1", 1);
		/* AMD Vulkan driver selection */
		setenv("AMD_VULKAN_ICD", "RADV", 1);
		break;

	case GPU_VENDOR_INTEL:
	case GPU_VENDOR_UNKNOWN:
	default:
		/* Generic DRI_PRIME for other cases */
		if (dgpu->pci_slot_underscore[0])
			setenv("DRI_PRIME", dgpu->pci_slot_underscore, 1);
		else
			setenv("DRI_PRIME", "1", 1);
		break;
	}

	/* Vulkan device selection - prefer discrete GPU */
	switch (dgpu->vendor) {
	case GPU_VENDOR_NVIDIA:
		setenv("VK_LOADER_DRIVERS_SELECT", "nvidia*", 1);
		break;
	case GPU_VENDOR_AMD:
		setenv("VK_LOADER_DRIVERS_SELECT", "radeon*,amd*", 1);
		break;
	default:
		setenv("VK_LOADER_DRIVERS_SELECT", "nvidia*,radeon*,amd*", 1);
		break;
	}
}

/* Set Steam-specific environment variables */
static void
set_steam_env(void)
{
	GpuInfo *dgpu;

	/*
	 * AUDIO: Ensure Steam and games use PipeWire for audio
	 *
	 * SDL_AUDIODRIVER=pipewire: Tell SDL (used by many games) to use PipeWire directly
	 * PULSE_SERVER: Point PulseAudio clients to PipeWire's pulse socket
	 * PIPEWIRE_RUNTIME_DIR: Ensure PipeWire socket is found
	 *
	 * Note: Modern PipeWire provides PulseAudio compatibility, so most games
	 * will work via the pulse socket even without explicit PipeWire support.
	 */
	setenv("SDL_AUDIODRIVER", "pipewire,pulseaudio,alsa", 0); /* Don't override if already set */

	/* Ensure XDG_RUNTIME_DIR is set (needed for PipeWire socket) */
	if (!getenv("XDG_RUNTIME_DIR")) {
		char runtime_dir[256];
		snprintf(runtime_dir, sizeof(runtime_dir), "/run/user/%d", getuid());
		setenv("XDG_RUNTIME_DIR", runtime_dir, 1);
	}

	/* For Proton/Wine games: use PipeWire via the PulseAudio interface */
	setenv("PULSE_LATENCY_MSEC", "60", 0); /* Reasonable latency for games */

	/* UI scaling fix for better Big Picture performance on hybrid systems */
	setenv("STEAM_FORCE_DESKTOPUI_SCALING", "1", 1);

	/* Tell Steam to prefer host libraries over runtime for better driver compat */
	setenv("STEAM_RUNTIME_PREFER_HOST_LIBRARIES", "1", 1);

	/* CEF/Chromium GPU override flags - force hardware acceleration
	 * These help bypass Steam's internal GPU blocklist on hybrid systems */
	setenv("STEAM_DISABLE_GPU_BLOCKLIST", "1", 1);
	setenv("STEAM_CEF_ARGS", "--ignore-gpu-blocklist --enable-gpu-rasterization --enable-zero-copy --enable-native-gpu-memory-buffers --disable-gpu-driver-bug-workarounds", 1);

	/* Override CEF webhelper flags - Steam internally adds --disable-gpu which kills performance
	 * STEAM_WEBHELPER_CEF_FLAGS can override/append to steamwebhelper arguments */
	setenv("STEAM_WEBHELPER_CEF_FLAGS", "--enable-gpu --enable-gpu-compositing --enable-accelerated-video-decode --ignore-gpu-blocklist", 1);

	/* If we have a discrete NVIDIA GPU, set PRIME offload vars for Steam itself */
	if (discrete_gpu_idx >= 0 && discrete_gpu_idx < detected_gpu_count) {
		dgpu = &detected_gpus[discrete_gpu_idx];
		if (dgpu->vendor == GPU_VENDOR_NVIDIA) {
			/* PRIME render offload for Steam process */
			setenv("__NV_PRIME_RENDER_OFFLOAD", "1", 1);
			setenv("__NV_PRIME_RENDER_OFFLOAD_PROVIDER", "NVIDIA-G0", 1);
			setenv("__GLX_VENDOR_LIBRARY_NAME", "nvidia", 1);
			setenv("__VK_LAYER_NV_optimus", "NVIDIA_only", 1);
			/* DRI_PRIME for Mesa fallback */
			if (dgpu->pci_slot_underscore[0])
				setenv("DRI_PRIME", dgpu->pci_slot_underscore, 1);
			else
				setenv("DRI_PRIME", "1", 1);
			/* Vulkan ICD selection for NVIDIA */
			setenv("VK_LOADER_DRIVERS_SELECT", "nvidia*", 1);

			/* NVIDIA-specific CEF args for better ANGLE/Vulkan support */
			setenv("STEAM_CEF_GPU_ARGS", "--use-angle=vulkan --enable-features=Vulkan,UseSkiaRenderer", 1);
		}
	}
}

/* Check if command is Steam */
static int
is_steam_cmd(const char *cmd)
{
	if (!cmd)
		return 0;
	return strcasestr(cmd, "steam") != NULL;
}

/* Launch Steam Big Picture mode if not already running */
static void
steam_launch_bigpicture(void)
{
	pid_t pid;

	/* Check if Steam is already running */
	if (is_process_running("steam")) {
		wlr_log(WLR_INFO, "Steam already running, not launching again");
		return;
	}

	wlr_log(WLR_INFO, "Launching Steam Big Picture mode");

	pid = fork();
	if (pid == 0) {
		setsid();
		set_dgpu_env();
		set_steam_env();
		execlp("steam", "steam", "-bigpicture", "-cef-force-gpu",
			"-cef-disable-sandbox", "steam://open/games", (char *)NULL);
		_exit(127);
	}
}

/* Kill Steam process immediately */
static void
steam_kill(void)
{
	pid_t pid;

	if (!is_process_running("steam")) {
		return;
	}

	wlr_log(WLR_INFO, "Killing Steam process");

	/* Use pkill to kill all steam processes */
	pid = fork();
	if (pid == 0) {
		setsid();
		execlp("pkill", "pkill", "-9", "steam", (char *)NULL);
		_exit(127);
	}
}

/* Kill streaming processes (mpv and Chrome kiosk for live TV) */
static void
live_tv_kill(void)
{
	pid_t pid;
	int status;

	/* Kill mpv if running */
	if (is_process_running("mpv")) {
		wlr_log(WLR_INFO, "Killing live TV mpv process");
		pid = fork();
		if (pid == 0) {
			setsid();
			execlp("pkill", "pkill", "-9", "mpv", (char *)NULL);
			_exit(127);
		}
		if (pid > 0)
			waitpid(pid, &status, 0);
	}

	/* Kill Chrome kiosk instances used for streaming (NRK, Netflix, Viaplay, TV2 Play, F1TV) */
	pid = fork();
	if (pid == 0) {
		setsid();
		execlp("pkill", "pkill", "-9", "-f", "chromium.*--kiosk.*(nrk\\.no|netflix\\.com|viaplay\\.no|tv2\\.no|f1tv)", (char *)NULL);
		_exit(127);
	}
	if (pid > 0)
		waitpid(pid, &status, 0);
}

/* Check if client is Steam main window */
static int
is_steam_client(Client *c)
{
	const char *app_id;
	if (!c)
		return 0;
	app_id = client_get_appid(c);
	if (!app_id)
		return 0;
	/* Steam main window app_id is "steam" */
	return strcasecmp(app_id, "steam") == 0;
}

/* Check if client is a Steam popup/dialog (not main window) */
static int
is_steam_popup(Client *c)
{
	const char *app_id;
	if (!c)
		return 0;
	app_id = client_get_appid(c);
	if (!app_id)
		return 0;
	/* Steam dialogs often have app_id starting with "steam" but may vary */
	if (strcasestr(app_id, "steam"))
		return 1;
	/* Also check for common game launcher popups */
	if (strcasestr(app_id, "steamwebhelper"))
		return 1;
	return 0;
}

/*
 * Check if a process is a child of Steam (i.e., a game launched by Steam).
 * This reads /proc/pid/stat to get the parent PID and checks recursively.
 */
static int
is_steam_child_process(pid_t pid)
{
	char path[64], buf[512], comm[64];
	FILE *f;
	pid_t ppid;
	int depth = 0;
	const int max_depth = 10; /* Prevent infinite loops */

	while (pid > 1 && depth < max_depth) {
		snprintf(path, sizeof(path), "/proc/%d/stat", pid);
		f = fopen(path, "r");
		if (!f)
			return 0;

		/* Format: pid (comm) state ppid ... */
		if (fscanf(f, "%*d (%63[^)]) %*c %d", comm, &ppid) != 2) {
			fclose(f);
			return 0;
		}
		fclose(f);

		/* Check if parent is steam, steam.sh, or reaper (Steam's process manager) */
		if (strcasestr(comm, "steam") || strcasestr(comm, "reaper"))
			return 1;

		pid = ppid;
		depth++;
	}
	return 0;
}

/*
 * Check if client is a Steam game (launched by Steam, not Steam itself).
 * Steam games are child processes of Steam and typically:
 * - Don't have "steam" in their app_id
 * - Are not floating (popups are floating)
 * - May request fullscreen after a delay
 */
static int
is_steam_game(Client *c)
{
	const char *app_id;
	pid_t pid;

	if (!c)
		return 0;

	/* Exclude Steam itself and its popups */
	app_id = client_get_appid(c);
	if (app_id && strcasestr(app_id, "steam"))
		return 0;

	/* Exclude floating windows (likely dialogs/launchers) */
	if (c->isfloating)
		return 0;

	/* Check if it's a child of Steam */
	pid = client_get_pid(c);
	if (pid > 1 && is_steam_child_process(pid)) {
		wlr_log(WLR_INFO, "Detected Steam game: app_id='%s', pid=%d",
			app_id ? app_id : "(null)", pid);
		return 1;
	}

	return 0;
}

/* Check if client is a browser (Chrome, Chromium, Firefox, etc.) */
static int
is_browser_client(Client *c)
{
	const char *app_id;
	if (!c)
		return 0;
	app_id = client_get_appid(c);
	if (!app_id)
		return 0;
	/* Check for common browser app_ids */
	if (strcasestr(app_id, "chrome") ||
	    strcasestr(app_id, "chromium") ||
	    strcasestr(app_id, "google-chrome") ||
	    strcasestr(app_id, "firefox") ||
	    strcasestr(app_id, "brave") ||
	    strcasestr(app_id, "vivaldi") ||
	    strcasestr(app_id, "opera") ||
	    strcasestr(app_id, "edge"))
		return 1;
	return 0;
}

/*
 * Check if client looks like a game based on various heuristics:
 * - Launched by Steam
 * - Has game-related app_id patterns
 * - Uses content-type game hint
 * - Requests tearing (for low latency)
 */
static int
looks_like_game(Client *c)
{
	if (!c)
		return 0;

	/* Check content-type protocol hint */
	if (is_game_content(c))
		return 1;

	/* Check if it wants tearing (games often request this) */
	if (client_wants_tearing(c))
		return 1;

	/* Check if it's a Steam game */
	if (is_steam_game(c))
		return 1;

	return 0;
}

void
spawn(const Arg *arg)
{
	if (fork() == 0) {
		dup2(STDERR_FILENO, STDOUT_FILENO);
		setsid();

		const char *cmd = (const char *)arg->v;
		if (!cmd || !cmd[0]) {
			_exit(1);
		}

		/* Detect if arg->v is a char** array (default keys) or string (runtime config).
		 * Runtime config strings are stored in runtime_spawn_cmds[] which are heap-allocated.
		 * Default keys use static char* arrays.
		 * We can check if the pointer is within runtime_spawn_cmds range. */
		int is_runtime_string = 0;
		for (int i = 0; i < runtime_spawn_cmd_count; i++) {
			if (arg->v == runtime_spawn_cmds[i]) {
				is_runtime_string = 1;
				break;
			}
		}

		if (!is_runtime_string) {
			/* Default keybindings: arg->v is char** array */
			char **argv = (char **)arg->v;
			if (argv[0] && argv[0][0] != '\0') {
				if (should_use_dgpu(argv[0]))
					set_dgpu_env();
				if (is_steam_cmd(argv[0])) {
					set_steam_env();
					/* Launch Steam - Big Picture in HTPC mode, normal otherwise */
					if (htpc_mode_active) {
						execlp("steam", "steam", "-bigpicture", "-cef-force-gpu", "-cef-disable-sandbox", "steam://open/games", (char *)NULL);
					} else {
						execlp("steam", "steam", "-cef-force-gpu", "-cef-disable-sandbox", (char *)NULL);
					}
				}
				execvp(argv[0], argv);
				/* If execvp fails, die */
				die("nixlytile: execvp %s failed:", argv[0]);
			}
		}

		/* Runtime config: arg->v is a string, execute via shell */
		if (should_use_dgpu(cmd))
			set_dgpu_env();
		if (is_steam_cmd(cmd)) {
			set_steam_env();
			/* If cmd is just "steam" or starts with "steam ", launch with GPU flags */
			if (strcmp(cmd, "steam") == 0) {
				/* Launch Steam - Big Picture in HTPC mode, normal otherwise */
				if (htpc_mode_active) {
					execlp("steam", "steam", "-bigpicture", "-cef-force-gpu", "-cef-disable-sandbox", "steam://open/games", (char *)NULL);
				} else {
					execlp("steam", "steam", "-cef-force-gpu", "-cef-disable-sandbox", (char *)NULL);
				}
			}
		}
		execl("/bin/sh", "sh", "-c", cmd, NULL);
		die("nixlytile: execl %s failed:", cmd);
	}
}

void
startdrag(struct wl_listener *listener, void *data)
{
	struct wlr_drag *drag = data;
	if (!drag->icon)
		return;

	drag->icon->data = &wlr_scene_drag_icon_create(drag_icon, drag->icon)->node;
	LISTEN_STATIC(&drag->icon->events.destroy, destroydragicon);
}

void
tag(const Arg *arg)
{
	Client *sel = focustop(selmon);
	if (!sel || (arg->ui & TAGMASK) == 0)
		return;

	sel->tags = arg->ui & TAGMASK;
	/* Switch to the new tag so we follow the window */
	selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
	focusclient(sel, 1);
	arrange(selmon);
	printstatus();
	/* Update game mode - fullscreen client visibility may have changed */
	update_game_mode();
}

void
tagmon(const Arg *arg)
{
	Client *sel = focustop(selmon);
	if (!sel)
		return;
	setmon(sel, dirtomon(arg->i), 0);
	free(sel->output);
	if (!(sel->output = strdup(sel->mon->wlr_output->name)))
		die("oom");
}

void
tile(Monitor *m)
{
	unsigned int h, r, e = m->gaps, mw, my, ty;
	int i, n = 0;
	Client *c;

	wl_list_for_each(c, &clients, link)
		if (VISIBLEON(c, m) && !c->isfloating && !c->isfullscreen)
			n++;
	if (n == 0)
		return;
	if (smartgaps == n)
		e = 0;

	/* When all windows fit in master area, arrange them horizontally as columns */
	if (n <= m->nmaster) {
		unsigned int w, mx = gappx * e;
		i = 0;
		wl_list_for_each(c, &clients, link) {
			if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
				continue;
			r = n - i;
			w = (m->w.width - mx - gappx * e - gappx * e * (r - 1)) / r;
			resize(c, (struct wlr_box){.x = m->w.x + mx, .y = m->w.y + gappx * e,
				.width = w, .height = m->w.height - 2 * gappx * e}, 0);
			mx += c->geom.width + gappx * e;
			i++;
		}
		return;
	}

	mw = m->nmaster ? (int)roundf((m->w.width + gappx * e) * m->mfact) : 0;
	i = 0;
	my = ty = gappx * e;
	wl_list_for_each(c, &clients, link) {
		if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
			continue;
		if (i < m->nmaster) {
			r = MIN(n, m->nmaster) - i;
			h = (m->w.height - my - gappx * e - gappx * e * (r - 1)) / r;
			resize(c, (struct wlr_box){.x = m->w.x + gappx * e, .y = m->w.y + my,
				.width = mw - 2 * gappx * e, .height = h}, 0);
			my += c->geom.height + gappx * e;
		} else {
			r = n - i;
			h = (m->w.height - ty - gappx * e - gappx * e * (r - 1)) / r;
			resize(c, (struct wlr_box){.x = m->w.x + mw, .y = m->w.y + ty,
				.width = m->w.width - mw - gappx * e, .height = h}, 0);
			ty += c->geom.height + gappx * e;
		}
		i++;
	}
}

void
togglefloating(const Arg *arg)
{
	Client *sel = focustop(selmon);
	/* return if fullscreen */
	if (sel && !sel->isfullscreen)
		setfloating(sel, !sel->isfloating);
}

void
togglefullscreen(const Arg *arg)
{
	Client *sel = focustop(selmon);
	if (sel)
		setfullscreen(sel, !sel->isfullscreen);
}

void
togglefullscreenadaptivesync(const Arg *arg)
{
	fullscreen_adaptive_sync_enabled = !fullscreen_adaptive_sync_enabled;
}

/* Stats panel animation duration in ms */
#define STATS_PANEL_ANIM_DURATION 250

/* Ease-out cubic for smooth deceleration */
static float
ease_out_cubic(float t)
{
	t = t - 1.0f;
	return t * t * t + 1.0f;
}

/* Animation timer callback - updates panel position */
static int
stats_panel_anim_cb(void *data)
{
	Monitor *m = data;
	uint64_t now_ns, elapsed_ms;
	float progress;
	int new_x;

	if (!m || !m->stats_panel_animating)
		return 0;

	now_ns = get_time_ns();
	elapsed_ms = (now_ns - m->stats_panel_anim_start) / 1000000;

	if (elapsed_ms >= STATS_PANEL_ANIM_DURATION) {
		/* Animation complete */
		m->stats_panel_current_x = m->stats_panel_target_x;
		m->stats_panel_animating = 0;

		/* If we slid out, hide the panel */
		if (m->stats_panel_target_x >= m->m.x + m->m.width) {
			wlr_scene_node_set_enabled(&m->stats_panel_tree->node, 0);
			m->stats_panel_visible = 0;
		}
	} else {
		/* Calculate eased position */
		progress = (float)elapsed_ms / (float)STATS_PANEL_ANIM_DURATION;
		progress = ease_out_cubic(progress);

		/* Determine start position based on target:
		 * If sliding in (target is on-screen), start from off-screen right
		 * If sliding out (target is off-screen), start from on-screen position */
		int off_screen_x = m->m.x + m->m.width;
		int on_screen_x = m->m.x + m->m.width - m->stats_panel_width;
		int sliding_in = (m->stats_panel_target_x < off_screen_x);
		int start_x = sliding_in ? off_screen_x : on_screen_x;
		int end_x = m->stats_panel_target_x;

		new_x = start_x + (int)((float)(end_x - start_x) * progress);
		m->stats_panel_current_x = new_x;

		/* Schedule next frame (~16ms for 60fps animation) */
		wl_event_source_timer_update(m->stats_panel_anim_timer, 16);
	}

	/* Update position */
	if (m->stats_panel_tree)
		wlr_scene_node_set_position(&m->stats_panel_tree->node,
			m->stats_panel_current_x, m->m.y);

	return 0;
}

/* Refresh timer callback - updates stats content */
static int
stats_panel_refresh_cb(void *data)
{
	Monitor *m = data;
	float display_hz = 0.0f;
	float native_hz = 0.0f;
	float avg_latency_ms = 0.0f;
	float commit_ms = 0.0f;
	float fps_diff = 0.0f;
	char line[128];
	int y_offset;
	int line_height;
	int padding = 16;
	int col2_x;
	StatusModule mod = {0};
	static const float panel_bg[4] = {0.05f, 0.05f, 0.08f, 0.85f};
	static const float header_color[4] = {0.4f, 0.8f, 1.0f, 1.0f};
	static const float section_color[4] = {0.6f, 0.9f, 1.0f, 1.0f};
	static const float label_color[4] = {0.7f, 0.7f, 0.7f, 1.0f};
	static const float value_color[4] = {1.0f, 1.0f, 1.0f, 1.0f};
	static const float good_color[4] = {0.4f, 1.0f, 0.4f, 1.0f};
	static const float warn_color[4] = {1.0f, 0.8f, 0.2f, 1.0f};
	static const float bad_color[4] = {1.0f, 0.3f, 0.3f, 1.0f};
	static const float sync_color[4] = {0.3f, 1.0f, 0.8f, 1.0f};
	static const float disabled_color[4] = {0.5f, 0.5f, 0.5f, 1.0f};
	struct wlr_scene_node *node, *tmp;
	int is_synced = 0;

	if (!m || !m->stats_panel_visible || !m->stats_panel_tree)
		return 0;

	if (!statusfont.font) {
		wlr_log(WLR_ERROR, "stats_panel_refresh_cb: statusfont not initialized!");
		return 0;
	}

	/* Calculate metrics */
	if (m->present_interval_ns > 0) {
		display_hz = 1000000000.0f / (float)m->present_interval_ns;
	} else if (m->wlr_output->current_mode) {
		display_hz = (float)m->wlr_output->current_mode->refresh / 1000.0f;
	}

	/* Get native/max refresh rate */
	if (m->wlr_output->current_mode) {
		native_hz = (float)m->wlr_output->current_mode->refresh / 1000.0f;
	}

	if (m->frames_presented > 0 && m->total_latency_ns > 0) {
		avg_latency_ms = (float)(m->total_latency_ns / m->frames_presented) / 1000000.0f;
	}

	commit_ms = (float)m->rolling_commit_time_ns / 1000000.0f;

	/* Check if screen and game are synced (within 2 Hz) */
	if (m->estimated_game_fps > 0.0f) {
		fps_diff = fabsf(display_hz - m->estimated_game_fps);
		is_synced = fps_diff < 2.0f;
	}

	/* Clear old content */
	wl_list_for_each_safe(node, tmp, &m->stats_panel_tree->children, link)
		wlr_scene_node_destroy(node);

	/* Draw background */
	drawrect(m->stats_panel_tree, 0, 0, m->stats_panel_width, m->m.height, panel_bg);

	/* Draw left border accent */
	static const float accent[4] = {0.3f, 0.6f, 1.0f, 1.0f};
	drawrect(m->stats_panel_tree, 0, 0, 3, m->m.height, accent);

	line_height = statusfont.height + 8;
	col2_x = m->stats_panel_width / 2;
	y_offset = padding;
	mod.tree = m->stats_panel_tree;

	/* Header */
	snprintf(line, sizeof(line), "PERFORMANCE MONITOR");
	tray_render_label(&mod, line, padding, y_offset + line_height, header_color);
	y_offset += line_height + 8;

	/* Monitor name */
	snprintf(line, sizeof(line), "%s", m->wlr_output->name);
	tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
	y_offset += line_height + 4;

	/* Separator */
	static const float sep_color[4] = {0.3f, 0.3f, 0.4f, 1.0f};
	drawrect(m->stats_panel_tree, padding, y_offset, m->stats_panel_width - padding * 2, 1, sep_color);
	y_offset += 12;

	/* ============ VRR STATUS SECTION ============ */
	snprintf(line, sizeof(line), "VRR / Adaptive Sync");
	tray_render_label(&mod, line, padding, y_offset + line_height, section_color);
	y_offset += line_height + 4;

	/* VRR Support status */
	snprintf(line, sizeof(line), "  Support:");
	tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
	if (m->vrr_capable) {
		snprintf(line, sizeof(line), "Yes");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, good_color);
	} else {
		snprintf(line, sizeof(line), "No");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, bad_color);
	}
	y_offset += line_height;

	/* VRR Enabled/Disabled status */
	snprintf(line, sizeof(line), "  Setting:");
	tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
	if (!fullscreen_adaptive_sync_enabled) {
		snprintf(line, sizeof(line), "DISABLED");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, bad_color);
	} else if (m->vrr_capable) {
		snprintf(line, sizeof(line), "ENABLED");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, good_color);
	} else {
		snprintf(line, sizeof(line), "N/A");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, disabled_color);
	}
	y_offset += line_height;

	/* VRR Active status */
	snprintf(line, sizeof(line), "  Status:");
	tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
	if (m->game_vrr_active) {
		snprintf(line, sizeof(line), "Game VRR Active");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, sync_color);
	} else if (m->vrr_active) {
		snprintf(line, sizeof(line), "Video VRR Active");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, sync_color);
	} else if (m->vrr_capable && fullscreen_adaptive_sync_enabled) {
		snprintf(line, sizeof(line), "Ready");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, value_color);
	} else {
		snprintf(line, sizeof(line), "Inactive");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, disabled_color);
	}
	y_offset += line_height + 8;

	/* Separator */
	drawrect(m->stats_panel_tree, padding, y_offset, m->stats_panel_width - padding * 2, 1, sep_color);
	y_offset += 12;

	/* ============ FRAME SMOOTHING SECTION ============ */
	static const float smooth_color[4] = {0.5f, 1.0f, 0.7f, 1.0f};  /* Mint green */
	snprintf(line, sizeof(line), "Frame Smoothing");
	tray_render_label(&mod, line, padding, y_offset + line_height, section_color);
	y_offset += line_height + 4;

	/* Frame repeat status */
	snprintf(line, sizeof(line), "  Repeat:");
	tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
	if (m->frame_repeat_enabled && m->frame_repeat_count > 1) {
		snprintf(line, sizeof(line), "%dx Active", m->frame_repeat_count);
		tray_render_label(&mod, line, col2_x, y_offset + line_height, smooth_color);
	} else if (m->game_vrr_active) {
		snprintf(line, sizeof(line), "VRR (better)");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, sync_color);
	} else {
		snprintf(line, sizeof(line), "1x (normal)");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, value_color);
	}
	y_offset += line_height;

	/* Show effective frame time when repeat is active */
	if (m->frame_repeat_enabled && m->frame_repeat_count > 1 && display_hz > 0.0f) {
		float effective_frame_time = 1000.0f / display_hz * (float)m->frame_repeat_count;
		snprintf(line, sizeof(line), "  Frame time:");
		tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
		snprintf(line, sizeof(line), "%.2f ms", effective_frame_time);
		tray_render_label(&mod, line, col2_x, y_offset + line_height, smooth_color);
		y_offset += line_height;
	}

	/* Judder score */
	snprintf(line, sizeof(line), "  Judder:");
	tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
	if (m->estimated_game_fps > 0.0f) {
		if (m->game_vrr_active || (m->frame_repeat_enabled && m->judder_score < 5)) {
			snprintf(line, sizeof(line), "None");
			tray_render_label(&mod, line, col2_x, y_offset + line_height, good_color);
		} else if (m->judder_score < 20) {
			snprintf(line, sizeof(line), "Low (%d%%)", m->judder_score);
			tray_render_label(&mod, line, col2_x, y_offset + line_height, good_color);
		} else if (m->judder_score < 50) {
			snprintf(line, sizeof(line), "Medium (%d%%)", m->judder_score);
			tray_render_label(&mod, line, col2_x, y_offset + line_height, warn_color);
		} else {
			snprintf(line, sizeof(line), "High (%d%%)", m->judder_score);
			tray_render_label(&mod, line, col2_x, y_offset + line_height, bad_color);
		}
	} else {
		snprintf(line, sizeof(line), "--");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, disabled_color);
	}
	y_offset += line_height;

	/* Frames repeated counter */
	if (m->frames_repeated > 0) {
		snprintf(line, sizeof(line), "  Repeated:");
		tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
		snprintf(line, sizeof(line), "%lu", m->frames_repeated);
		tray_render_label(&mod, line, col2_x, y_offset + line_height, smooth_color);
		y_offset += line_height;
	}
	y_offset += 8;

	/* Separator */
	drawrect(m->stats_panel_tree, padding, y_offset, m->stats_panel_width - padding * 2, 1, sep_color);
	y_offset += 12;

	/* ============ REAL-TIME COMPARISON SECTION ============ */
	snprintf(line, sizeof(line), "Real-Time Sync");
	tray_render_label(&mod, line, padding, y_offset + line_height, section_color);
	y_offset += line_height + 4;

	/* Two-column headers */
	snprintf(line, sizeof(line), "  SCREEN");
	tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
	snprintf(line, sizeof(line), "GAME");
	tray_render_label(&mod, line, col2_x, y_offset + line_height, label_color);
	y_offset += line_height;

	/* Refresh rates - big numbers */
	snprintf(line, sizeof(line), "  %.1f Hz", display_hz);
	tray_render_label(&mod, line, padding, y_offset + line_height,
		is_synced ? sync_color : value_color);

	if (m->estimated_game_fps > 0.0f) {
		snprintf(line, sizeof(line), "%.1f FPS", m->estimated_game_fps);
		tray_render_label(&mod, line, col2_x, y_offset + line_height,
			is_synced ? sync_color :
			(m->estimated_game_fps >= 55.0f ? good_color :
			(m->estimated_game_fps >= 30.0f ? warn_color : bad_color)));
	} else {
		snprintf(line, sizeof(line), "-- FPS");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, disabled_color);
	}
	y_offset += line_height;

	/* Sync status indicator */
	if (m->estimated_game_fps > 0.0f) {
		if (is_synced) {
			snprintf(line, sizeof(line), "  [SYNCED]");
			tray_render_label(&mod, line, padding, y_offset + line_height, sync_color);
		} else {
			snprintf(line, sizeof(line), "  Diff: %.1f Hz", fps_diff);
			tray_render_label(&mod, line, padding, y_offset + line_height,
				fps_diff < 5.0f ? warn_color : bad_color);
		}
		y_offset += line_height;
	}
	y_offset += 8;

	/* Separator */
	drawrect(m->stats_panel_tree, padding, y_offset, m->stats_panel_width - padding * 2, 1, sep_color);
	y_offset += 12;

	/* ============ RENDERING SECTION ============ */
	snprintf(line, sizeof(line), "Rendering");
	tray_render_label(&mod, line, padding, y_offset + line_height, section_color);
	y_offset += line_height + 4;

	snprintf(line, sizeof(line), "  Mode:");
	tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
	if (m->direct_scanout_active) {
		snprintf(line, sizeof(line), "Direct Scanout");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, good_color);
	} else {
		snprintf(line, sizeof(line), "Composited");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, value_color);
	}
	y_offset += line_height;

	snprintf(line, sizeof(line), "  Commit:");
	tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
	snprintf(line, sizeof(line), "%.2f ms", commit_ms);
	tray_render_label(&mod, line, col2_x, y_offset + line_height,
		commit_ms < 2.0f ? good_color : (commit_ms < 8.0f ? warn_color : bad_color));
	y_offset += line_height;

	if (avg_latency_ms > 0.0f) {
		snprintf(line, sizeof(line), "  Latency:");
		tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
		snprintf(line, sizeof(line), "%.1f ms", avg_latency_ms);
		tray_render_label(&mod, line, col2_x, y_offset + line_height,
			avg_latency_ms < 16.0f ? good_color :
			(avg_latency_ms < 33.0f ? warn_color : bad_color));
		y_offset += line_height;
	}
	y_offset += 8;

	/* Separator */
	drawrect(m->stats_panel_tree, padding, y_offset, m->stats_panel_width - padding * 2, 1, sep_color);
	y_offset += 12;

	/* ============ GAME MODE SECTION ============ */
	snprintf(line, sizeof(line), "Game Mode");
	tray_render_label(&mod, line, padding, y_offset + line_height, section_color);
	y_offset += line_height + 4;

	snprintf(line, sizeof(line), "  Status:");
	tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
	if (game_mode_ultra) {
		static const float ultra_color[4] = {1.0f, 0.2f, 0.8f, 1.0f};  /* Hot pink for ULTRA */
		snprintf(line, sizeof(line), "ULTRA");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, ultra_color);
	} else if (game_mode_active) {
		snprintf(line, sizeof(line), "Active");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, good_color);
	} else {
		snprintf(line, sizeof(line), "Inactive");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, disabled_color);
	}
	y_offset += line_height;

	/* Show what's optimized in game mode */
	snprintf(line, sizeof(line), "  Timers:");
	tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
	if (game_mode_ultra) {
		snprintf(line, sizeof(line), "All Stopped");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, good_color);
	} else if (game_mode_active) {
		snprintf(line, sizeof(line), "Some Paused");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, warn_color);
	} else {
		snprintf(line, sizeof(line), "Normal");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, value_color);
	}
	y_offset += line_height;

	snprintf(line, sizeof(line), "  Statusbar:");
	tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
	if (game_mode_ultra) {
		snprintf(line, sizeof(line), "Hidden");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, good_color);
	} else {
		snprintf(line, sizeof(line), "Visible");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, value_color);
	}
	y_offset += line_height;

	/* Show game client info if available */
	if (game_mode_client) {
		const char *app_id = client_get_appid(game_mode_client);
		if (app_id && strlen(app_id) > 0) {
			snprintf(line, sizeof(line), "  Game:");
			tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
			/* Truncate app_id if too long */
			char truncated[32];
			strncpy(truncated, app_id, sizeof(truncated) - 1);
			truncated[sizeof(truncated) - 1] = '\0';
			if (strlen(app_id) > 24) {
				truncated[21] = '.';
				truncated[22] = '.';
				truncated[23] = '.';
				truncated[24] = '\0';
			}
			tray_render_label(&mod, truncated, col2_x, y_offset + line_height, value_color);
			y_offset += line_height;
		}
	}

	/* Show priority boost if active */
	if (game_mode_nice_applied || game_mode_ioclass_applied) {
		snprintf(line, sizeof(line), "  Priority:");
		tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
		snprintf(line, sizeof(line), "Boosted");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, good_color);
		y_offset += line_height;
	}
	y_offset += 8;

	/* Separator */
	drawrect(m->stats_panel_tree, padding, y_offset, m->stats_panel_width - padding * 2, 1, sep_color);
	y_offset += 12;

	/* ============ INPUT LATENCY SECTION ============ */
	if (game_mode_ultra) {
		static const float latency_color[4] = {1.0f, 0.6f, 0.2f, 1.0f};  /* Orange */
		snprintf(line, sizeof(line), "Input Latency");
		tray_render_label(&mod, line, padding, y_offset + line_height, section_color);
		y_offset += line_height + 4;

		/* Current input-to-frame latency */
		snprintf(line, sizeof(line), "  Current:");
		tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
		if (m->input_to_frame_ns > 0) {
			float latency_ms = (float)m->input_to_frame_ns / 1000000.0f;
			snprintf(line, sizeof(line), "%.1f ms", latency_ms);
			tray_render_label(&mod, line, col2_x, y_offset + line_height,
				latency_ms < 8.0f ? good_color :
				(latency_ms < 16.0f ? latency_color : bad_color));
		} else {
			snprintf(line, sizeof(line), "-- ms");
			tray_render_label(&mod, line, col2_x, y_offset + line_height, disabled_color);
		}
		y_offset += line_height;

		/* Min/Max latency */
		if (m->min_input_latency_ns > 0) {
			snprintf(line, sizeof(line), "  Range:");
			tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
			snprintf(line, sizeof(line), "%.1f-%.1f ms",
				(float)m->min_input_latency_ns / 1000000.0f,
				(float)m->max_input_latency_ns / 1000000.0f);
			tray_render_label(&mod, line, col2_x, y_offset + line_height, value_color);
			y_offset += line_height;
		}

		/* Frame timing jitter/variance */
		if (m->frame_variance_ns > 0) {
			snprintf(line, sizeof(line), "  Jitter:");
			tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
			/* Convert variance to approximate jitter in ms (sqrt approximation) */
			float jitter_ms = 0.0f;
			uint64_t v = m->frame_variance_ns;
			uint64_t sqrt_approx = 0;
			while (sqrt_approx * sqrt_approx < v) sqrt_approx += 10000;
			jitter_ms = (float)sqrt_approx / 1000000.0f;
			snprintf(line, sizeof(line), "%.2f ms", jitter_ms);
			tray_render_label(&mod, line, col2_x, y_offset + line_height,
				jitter_ms < 1.0f ? good_color :
				(jitter_ms < 3.0f ? warn_color : bad_color));
			y_offset += line_height;
		}

		/* Prediction accuracy */
		if (m->prediction_accuracy > 0.0f) {
			snprintf(line, sizeof(line), "  Prediction:");
			tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
			snprintf(line, sizeof(line), "%.0f%% accurate", m->prediction_accuracy);
			tray_render_label(&mod, line, col2_x, y_offset + line_height,
				m->prediction_accuracy > 80.0f ? good_color :
				(m->prediction_accuracy > 50.0f ? warn_color : bad_color));
			y_offset += line_height;
		}
		y_offset += 8;

		/* Separator */
		drawrect(m->stats_panel_tree, padding, y_offset, m->stats_panel_width - padding * 2, 1, sep_color);
		y_offset += 12;
	}

	/* ============ SYSTEM HEALTH SECTION ============ */
	{
		int mem_pressure = get_memory_pressure();
		m->memory_pressure = mem_pressure;

		snprintf(line, sizeof(line), "System Health");
		tray_render_label(&mod, line, padding, y_offset + line_height, section_color);
		y_offset += line_height + 4;

		snprintf(line, sizeof(line), "  Memory:");
		tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
		snprintf(line, sizeof(line), "%d%% used", mem_pressure);
		tray_render_label(&mod, line, col2_x, y_offset + line_height,
			mem_pressure < 70 ? good_color :
			(mem_pressure < 90 ? warn_color : bad_color));
		y_offset += line_height;

		/* Show warning if memory pressure is high */
		if (mem_pressure >= 90) {
			snprintf(line, sizeof(line), "   Low memory!");
			tray_render_label(&mod, line, padding, y_offset + line_height, bad_color);
			y_offset += line_height;
		}
		y_offset += 8;
	}

	/* Separator */
	drawrect(m->stats_panel_tree, padding, y_offset, m->stats_panel_width - padding * 2, 1, sep_color);
	y_offset += 12;

	/* ============ FRAME STATS SECTION ============ */
	snprintf(line, sizeof(line), "Frame Statistics");
	tray_render_label(&mod, line, padding, y_offset + line_height, section_color);
	y_offset += line_height + 4;

	snprintf(line, sizeof(line), "  Presented:");
	tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
	snprintf(line, sizeof(line), "%lu", m->frames_presented);
	tray_render_label(&mod, line, col2_x, y_offset + line_height, value_color);
	y_offset += line_height;

	snprintf(line, sizeof(line), "  Dropped:");
	tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
	snprintf(line, sizeof(line), "%lu", m->frames_dropped);
	tray_render_label(&mod, line, col2_x, y_offset + line_height,
		m->frames_dropped == 0 ? good_color : bad_color);
	y_offset += line_height;

	snprintf(line, sizeof(line), "  Held:");
	tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
	snprintf(line, sizeof(line), "%lu", m->frames_held);
	tray_render_label(&mod, line, col2_x, y_offset + line_height,
		m->frames_held < 10 ? good_color : warn_color);
	y_offset += line_height + 8;

	/* Separator */
	drawrect(m->stats_panel_tree, padding, y_offset, m->stats_panel_width - padding * 2, 1, sep_color);
	y_offset += 12;

	/* ============ FPS LIMITER SECTION ============ */
	snprintf(line, sizeof(line), "FPS Limiter");
	tray_render_label(&mod, line, padding, y_offset + line_height, section_color);
	y_offset += line_height + 4;

	snprintf(line, sizeof(line), "  Status:");
	tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
	if (fps_limit_enabled) {
		snprintf(line, sizeof(line), "ON (%d FPS)", fps_limit_value);
		tray_render_label(&mod, line, col2_x, y_offset + line_height, warn_color);
	} else {
		snprintf(line, sizeof(line), "OFF");
		tray_render_label(&mod, line, col2_x, y_offset + line_height, value_color);
	}
	y_offset += line_height;

	/* Show effective limit vs actual */
	if (fps_limit_enabled && m->estimated_game_fps > 0.0f) {
		snprintf(line, sizeof(line), "  Effective:");
		tray_render_label(&mod, line, padding, y_offset + line_height, label_color);
		float effective = m->estimated_game_fps;
		if (effective > (float)fps_limit_value)
			effective = (float)fps_limit_value;
		snprintf(line, sizeof(line), "%.0f FPS", effective);
		tray_render_label(&mod, line, col2_x, y_offset + line_height,
			effective >= (float)fps_limit_value - 1.0f ? good_color : warn_color);
		y_offset += line_height;
	}
	y_offset += 8;

	/* Separator */
	drawrect(m->stats_panel_tree, padding, y_offset, m->stats_panel_width - padding * 2, 1, sep_color);
	y_offset += 12;

	/* ============ CONTROLS SECTION ============ */
	snprintf(line, sizeof(line), "Controls");
	tray_render_label(&mod, line, padding, y_offset + line_height, section_color);
	y_offset += line_height + 4;

	static const float hint_color[4] = {0.5f, 0.5f, 0.6f, 1.0f};
	static const float key_color[4] = {0.7f, 0.8f, 0.9f, 1.0f};

	snprintf(line, sizeof(line), "  [L]");
	tray_render_label(&mod, line, padding, y_offset + line_height, key_color);
	snprintf(line, sizeof(line), "Toggle FPS limit");
	tray_render_label(&mod, line, padding + 50, y_offset + line_height, hint_color);
	y_offset += line_height;

	snprintf(line, sizeof(line), "  [V]");
	tray_render_label(&mod, line, padding, y_offset + line_height, key_color);
	snprintf(line, sizeof(line), "Toggle VRR");
	tray_render_label(&mod, line, padding + 50, y_offset + line_height, hint_color);
	y_offset += line_height;

	snprintf(line, sizeof(line), "  [+/-]");
	tray_render_label(&mod, line, padding, y_offset + line_height, key_color);
	snprintf(line, sizeof(line), "Adjust +/- 10");
	tray_render_label(&mod, line, padding + 50, y_offset + line_height, hint_color);
	y_offset += line_height;

	snprintf(line, sizeof(line), "  [1-5]");
	tray_render_label(&mod, line, padding, y_offset + line_height, key_color);
	snprintf(line, sizeof(line), "30/60/90/120/144");
	tray_render_label(&mod, line, padding + 50, y_offset + line_height, hint_color);
	y_offset += line_height;

	snprintf(line, sizeof(line), "  [0]");
	tray_render_label(&mod, line, padding, y_offset + line_height, key_color);
	snprintf(line, sizeof(line), "Disable limit");
	tray_render_label(&mod, line, padding + 50, y_offset + line_height, hint_color);
	y_offset += line_height;

	snprintf(line, sizeof(line), "  [Esc]");
	tray_render_label(&mod, line, padding, y_offset + line_height, key_color);
	snprintf(line, sizeof(line), "Close panel");
	tray_render_label(&mod, line, padding + 50, y_offset + line_height, hint_color);
	y_offset += line_height;

	/* Schedule next refresh (100ms for smoother real-time updates) */
	wl_event_source_timer_update(m->stats_panel_timer, 100);

	return 0;
}

/* Toggle stats panel visibility with slide animation */
void
gamepanel(const Arg *arg)
{
	Monitor *m = selmon;

	wlr_log(WLR_INFO, "gamepanel() called, selmon=%p", (void*)m);

	if (!m)
		return;

	/* Calculate panel width (25% of screen) */
	m->stats_panel_width = m->m.width / 4;
	if (m->stats_panel_width < 200)
		m->stats_panel_width = 200;

	/* Create panel tree if needed - use LyrBlock to show over fullscreen */
	if (!m->stats_panel_tree) {
		m->stats_panel_tree = wlr_scene_tree_create(layers[LyrBlock]);
		if (!m->stats_panel_tree)
			return;
		m->stats_panel_visible = 0;
		m->stats_panel_animating = 0;
		/* Start off-screen */
		m->stats_panel_current_x = m->m.x + m->m.width;
	}

	/* Create timers if needed */
	if (!m->stats_panel_timer)
		m->stats_panel_timer = wl_event_loop_add_timer(event_loop,
			stats_panel_refresh_cb, m);
	if (!m->stats_panel_anim_timer)
		m->stats_panel_anim_timer = wl_event_loop_add_timer(event_loop,
			stats_panel_anim_cb, m);

	/* Toggle visibility */
	if (m->stats_panel_visible) {
		wlr_log(WLR_INFO, "gamepanel: sliding OUT, panel was visible");
		/* Slide out */
		m->stats_panel_target_x = m->m.x + m->m.width;
		m->stats_panel_anim_start = get_time_ns();
		m->stats_panel_animating = 1;
		/* Start animation from current position */
		wl_event_source_timer_update(m->stats_panel_anim_timer, 1);
		/* Cancel refresh timer */
		wl_event_source_timer_update(m->stats_panel_timer, 0);
	} else {
		wlr_log(WLR_INFO, "gamepanel: sliding IN, panel_tree=%p, width=%d, pos=(%d,%d)",
			(void*)m->stats_panel_tree, m->stats_panel_width,
			m->stats_panel_target_x, m->m.y);
		/* Slide in */
		m->stats_panel_visible = 1;
		m->stats_panel_target_x = m->m.x + m->m.width - m->stats_panel_width;
		m->stats_panel_current_x = m->m.x + m->m.width; /* Start off-screen */
		m->stats_panel_anim_start = get_time_ns();
		m->stats_panel_animating = 1;

		/* Enable and position */
		wlr_scene_node_set_enabled(&m->stats_panel_tree->node, 1);
		wlr_scene_node_set_position(&m->stats_panel_tree->node,
			m->stats_panel_current_x, m->m.y);
		/* Ensure panel is on top of other overlays in LyrBlock */
		wlr_scene_node_raise_to_top(&m->stats_panel_tree->node);

		wlr_log(WLR_INFO, "gamepanel: enabled node at x=%d y=%d, raised to top, starting animation",
			m->stats_panel_current_x, m->m.y);

		/* Initial render and start animation */
		stats_panel_refresh_cb(m);
		wl_event_source_timer_update(m->stats_panel_anim_timer, 1);
	}
}

/* Check if stats panel is visible on any monitor */
static Monitor *
stats_panel_visible_monitor(void)
{
	Monitor *m;

	wl_list_for_each(m, &mons, link) {
		if (m->stats_panel_visible)
			return m;
	}
	return NULL;
}

/* Handle keyboard input when stats panel is visible */
static int
stats_panel_handle_key(Monitor *m, xkb_keysym_t sym)
{
	char osd_msg[64];

	if (!m || !m->stats_panel_visible)
		return 0;

	switch (sym) {
	case XKB_KEY_l:
	case XKB_KEY_L:
		/* Toggle FPS limiter */
		fps_limit_enabled = !fps_limit_enabled;
		if (fps_limit_enabled) {
			snprintf(osd_msg, sizeof(osd_msg), "FPS Limit: %d", fps_limit_value);
		} else {
			snprintf(osd_msg, sizeof(osd_msg), "FPS Limit: OFF");
		}
		show_hz_osd(m, osd_msg);
		stats_panel_refresh_cb(m);
		return 1;

	case XKB_KEY_plus:
	case XKB_KEY_equal:
	case XKB_KEY_KP_Add:
		/* Increase FPS limit by 10 */
		fps_limit_value += 10;
		if (fps_limit_value > 500)
			fps_limit_value = 500;
		if (fps_limit_enabled) {
			snprintf(osd_msg, sizeof(osd_msg), "FPS Limit: %d", fps_limit_value);
			show_hz_osd(m, osd_msg);
		}
		stats_panel_refresh_cb(m);
		return 1;

	case XKB_KEY_minus:
	case XKB_KEY_KP_Subtract:
		/* Decrease FPS limit by 10 */
		fps_limit_value -= 10;
		if (fps_limit_value < 10)
			fps_limit_value = 10;
		if (fps_limit_enabled) {
			snprintf(osd_msg, sizeof(osd_msg), "FPS Limit: %d", fps_limit_value);
			show_hz_osd(m, osd_msg);
		}
		stats_panel_refresh_cb(m);
		return 1;

	case XKB_KEY_1:
		fps_limit_value = 30;
		fps_limit_enabled = 1;
		snprintf(osd_msg, sizeof(osd_msg), "FPS Limit: 30");
		show_hz_osd(m, osd_msg);
		stats_panel_refresh_cb(m);
		return 1;

	case XKB_KEY_2:
		fps_limit_value = 60;
		fps_limit_enabled = 1;
		snprintf(osd_msg, sizeof(osd_msg), "FPS Limit: 60");
		show_hz_osd(m, osd_msg);
		stats_panel_refresh_cb(m);
		return 1;

	case XKB_KEY_3:
		fps_limit_value = 90;
		fps_limit_enabled = 1;
		snprintf(osd_msg, sizeof(osd_msg), "FPS Limit: 90");
		show_hz_osd(m, osd_msg);
		stats_panel_refresh_cb(m);
		return 1;

	case XKB_KEY_4:
		fps_limit_value = 120;
		fps_limit_enabled = 1;
		snprintf(osd_msg, sizeof(osd_msg), "FPS Limit: 120");
		show_hz_osd(m, osd_msg);
		stats_panel_refresh_cb(m);
		return 1;

	case XKB_KEY_5:
		fps_limit_value = 144;
		fps_limit_enabled = 1;
		snprintf(osd_msg, sizeof(osd_msg), "FPS Limit: 144");
		show_hz_osd(m, osd_msg);
		stats_panel_refresh_cb(m);
		return 1;

	case XKB_KEY_0:
		/* Disable limiter */
		fps_limit_enabled = 0;
		show_hz_osd(m, "FPS Limit: OFF");
		stats_panel_refresh_cb(m);
		return 1;

	case XKB_KEY_v:
	case XKB_KEY_V:
		/* Toggle VRR */
		fullscreen_adaptive_sync_enabled = !fullscreen_adaptive_sync_enabled;
		if (fullscreen_adaptive_sync_enabled) {
			show_hz_osd(m, "VRR: ENABLED");
		} else {
			show_hz_osd(m, "VRR: DISABLED");
			/* Disable active VRR if it was on */
			if (m->game_vrr_active)
				disable_game_vrr(m);
		}
		stats_panel_refresh_cb(m);
		return 1;

	case XKB_KEY_Escape:
		/* Close panel */
		gamepanel(NULL);
		return 1;
	}

	return 0;
}

void
__attribute__((unused)) togglesticky(const Arg *arg)
{
	Client *c = focustop(selmon);

	if (!c)
		return;

	setsticky(c, !c->issticky);
}

void
togglegaps(const Arg *arg)
{
	if (!selmon)
		return;
	selmon->gaps = !selmon->gaps;
	arrangelayers(selmon);
	arrange(selmon);
}

void
togglestatusbar(const Arg *arg)
{
	(void)arg;
	if (!selmon)
		return;
	selmon->showbar = !selmon->showbar;
	arrangelayers(selmon);
}

void
toggletag(const Arg *arg)
{
	uint32_t newtags;
	Client *sel = focustop(selmon);
	if (!sel || !(newtags = sel->tags ^ (arg->ui & TAGMASK)))
		return;

	sel->tags = newtags;
	focusclient(focustop(selmon), 1);
	arrange(selmon);
	printstatus();
	/* Update game mode - fullscreen client visibility may have changed */
	update_game_mode();
}

void
toggleview(const Arg *arg)
{
	uint32_t newtagset;
	if (!(newtagset = selmon ? selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK) : 0))
		return;

	selmon->tagset[selmon->seltags] = newtagset;
	focusclient(focustop(selmon), 1);
	arrange(selmon);
	printstatus();
	/* Update game mode when toggling tag visibility */
	update_game_mode();
}

void
unlocksession(struct wl_listener *listener, void *data)
{
	SessionLock *lock = wl_container_of(listener, lock, unlock);
	destroylock(lock, 1);
}

void
unmaplayersurfacenotify(struct wl_listener *listener, void *data)
{
	LayerSurface *l = wl_container_of(listener, l, unmap);

	l->mapped = 0;
	wlr_scene_node_set_enabled(&l->scene->node, 0);
	if (l == exclusive_focus)
		exclusive_focus = NULL;
	if (l->layer_surface->output && (l->mon = l->layer_surface->output->data))
		arrangelayers(l->mon);
	if (l->layer_surface->surface == seat->keyboard_state.focused_surface)
		focusclient(focustop(selmon), 1);
	motionnotify(0, NULL, 0, 0, 0, 0);
}

void
unmapnotify(struct wl_listener *listener, void *data)
{
	/* Called when the surface is unmapped, and should no longer be shown. */
	Client *c = wl_container_of(listener, c, unmap);
	if (c == grabc) {
		cursor_mode = CurNormal;
		grabc = NULL;
	}

	if (client_is_unmanaged(c)) {
		if (c == exclusive_focus) {
			exclusive_focus = NULL;
			focusclient(focustop(selmon), 1);
		}
	} else {
		wl_list_remove(&c->link);
		/* Remove from layout tree and rebalance BEFORE setmon calls arrange() */
		if (c->mon)
			remove_client(c->mon, c);
		setmon(c, NULL, 0);
		wl_list_remove(&c->flink);
	}
	/* Toggle adaptive sync off and restore refresh rate when fullscreen client is unmapped */
	if (c->isfullscreen) {
		Monitor *m = c->mon ? c->mon : selmon;
		set_adaptive_sync(m, 0);
		restore_max_refresh_rate(m);
	}

	wlr_scene_node_destroy(&c->scene->node);
	printstatus();
	motionnotify(0, NULL, 0, 0, 0, 0);
	update_game_mode();
}

void
updatemons(struct wl_listener *listener, void *data)
{
	/*
	 * Called whenever the output layout changes: adding or removing a
	 * monitor, changing an output's mode or position, etc. This is where
	 * the change officially happens and we update geometry, window
	 * positions, focus, and the stored configuration in wlroots'
	 * output-manager implementation.
	 */
	struct wlr_output_configuration_v1 *config
			= wlr_output_configuration_v1_create();
	Client *c;
	struct wlr_output_configuration_head_v1 *config_head;
	Monitor *m;

	/* First remove from the layout the disabled monitors */
	wl_list_for_each(m, &mons, link) {
		if (m->wlr_output->enabled || m->asleep)
			continue;
		config_head = wlr_output_configuration_head_v1_create(config, m->wlr_output);
		config_head->state.enabled = 0;
		/* Remove this output from the layout to avoid cursor enter inside it */
		wlr_output_layout_remove(output_layout, m->wlr_output);
		closemon(m);
		m->m = m->w = (struct wlr_box){0};
	}
	/* Insert outputs that need to */
	wl_list_for_each(m, &mons, link) {
		if (m->wlr_output->enabled
				&& !wlr_output_layout_get(output_layout, m->wlr_output))
			wlr_output_layout_add_auto(output_layout, m->wlr_output);
	}

	/*
	 * Restore clients to their original monitor after suspend/resume.
	 * When a monitor is disabled (e.g., laptop suspend), closemon() moves
	 * all clients to another monitor. But c->output still remembers which
	 * monitor the client originally belonged to. When the monitor wakes up,
	 * we need to move clients back to their original monitor.
	 */
	wl_list_for_each(m, &mons, link) {
		if (!m->wlr_output->enabled)
			continue;
		wl_list_for_each(c, &clients, link) {
			if (c->output && c->mon != m
					&& strcmp(m->wlr_output->name, c->output) == 0) {
				c->mon = m;
			}
		}
	}

	/* Now that we update the output layout we can get its box */
	wlr_output_layout_get_box(output_layout, NULL, &sgeom);

	wlr_scene_node_set_position(&root_bg->node, sgeom.x, sgeom.y);
	wlr_scene_rect_set_size(root_bg, sgeom.width, sgeom.height);

	/* Make sure the clients are hidden when dwl is locked */
	wlr_scene_node_set_position(&locked_bg->node, sgeom.x, sgeom.y);
	wlr_scene_rect_set_size(locked_bg, sgeom.width, sgeom.height);

	wl_list_for_each(m, &mons, link) {
		if (!m->wlr_output->enabled)
			continue;
		config_head = wlr_output_configuration_head_v1_create(config, m->wlr_output);

		/* Get the effective monitor geometry to use for surfaces */
		wlr_output_layout_get_box(output_layout, m->wlr_output, &m->m);
		m->w = m->m;
		wlr_scene_output_set_position(m->scene_output, m->m.x, m->m.y);

		wlr_scene_node_set_position(&m->fullscreen_bg->node, m->m.x, m->m.y);
		wlr_scene_rect_set_size(m->fullscreen_bg, m->m.width, m->m.height);

		if (m->lock_surface) {
			struct wlr_scene_tree *scene_tree = m->lock_surface->surface->data;
			wlr_scene_node_set_position(&scene_tree->node, m->m.x, m->m.y);
			wlr_session_lock_surface_v1_configure(m->lock_surface, m->m.width, m->m.height);
		}

		/* Calculate the effective monitor geometry to use for clients */
		arrangelayers(m);
		/* Don't move clients to the left output when plugging monitors */
		arrange(m);
		/* make sure fullscreen clients have the right size */
		if ((c = focustop(m)) && c->isfullscreen)
			resize(c, m->m, 0);

		/* Try to re-set the gamma LUT when updating monitors,
		 * it's only really needed when enabling a disabled output, but meh. */
		m->gamma_lut_changed = 1;

		config_head->state.x = m->m.x;
		config_head->state.y = m->m.y;

		if (!selmon) {
			selmon = m;
		}
	}

	if (selmon && selmon->wlr_output->enabled) {
		wl_list_for_each(c, &clients, link) {
			if (!c->mon && client_surface(c)->mapped)
				setmon(c, selmon, c->tags);
		}
		focusclient(focustop(selmon), 1);
		if (selmon->lock_surface) {
			client_notify_enter(selmon->lock_surface->surface,
					wlr_seat_get_keyboard(seat));
			client_activate_surface(selmon->lock_surface->surface, 1);
		}
	}

	/* FIXME: figure out why the cursor image is at 0,0 after turning all
	 * the monitors on.
	 * Move the cursor image where it used to be. It does not generate a
	 * wl_pointer.motion event for the clients, it's only the image what it's
	 * at the wrong position after all. */
	wlr_cursor_move(cursor, NULL, 0, 0);

	wlr_output_manager_v1_set_configuration(output_mgr, config);
}

void
updatetitle(struct wl_listener *listener, void *data)
{
	Client *c = wl_container_of(listener, c, set_title);
	if (c == focustop(c->mon))
		printstatus();
}

void
urgent(struct wl_listener *listener, void *data)
{
	struct wlr_xdg_activation_v1_request_activate_event *event = data;
	Client *c = NULL;
	toplevel_from_wlr_surface(event->surface, &c, NULL);
	if (!c || c == focustop(selmon))
		return;

	c->isurgent = 1;
	printstatus();

	if (client_surface(c)->mapped)
		client_set_border_color(c, urgentcolor);
}

void
view(const Arg *arg)
{
	Client *c, *fullscreen_c = NULL;

	if (!selmon || (arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
		return;
	selmon->seltags ^= 1; /* toggle sel tagset */
	if (arg->ui & TAGMASK)
		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;

	/*
	 * Check if there's a fullscreen client on the new tag.
	 * If so, focus it directly instead of using focustop() which relies on
	 * the focus stack order. This fixes the bug where switching tags and back
	 * causes fullscreen games to lose keyboard focus.
	 */
	wl_list_for_each(c, &clients, link) {
		if (c->isfullscreen && VISIBLEON(c, selmon)) {
			fullscreen_c = c;
			break;
		}
	}

	if (fullscreen_c) {
		exclusive_focus = NULL;  /* Clear any exclusive focus that might block */
		focusclient(fullscreen_c, 1);
	} else {
		focusclient(focustop(selmon), 1);
	}

	arrange(selmon);
	printstatus();
	/* Update game mode when switching tags - a fullscreen game may become visible/hidden */
	update_game_mode();
	/* Update gamepad grab state - grab for HTPC views, release for Steam */
	gamepad_update_grab_state();
}

void
virtualkeyboard(struct wl_listener *listener, void *data)
{
	struct wlr_virtual_keyboard_v1 *kb = data;
	/* virtual keyboards shouldn't share keyboard group */
	KeyboardGroup *group = createkeyboardgroup();
	/* Set the keymap to match the group keymap */
	wlr_keyboard_set_keymap(&kb->keyboard, group->wlr_group->keyboard.keymap);
	LISTEN(&kb->keyboard.base.events.destroy, &group->destroy, destroykeyboardgroup);

	/* Add the new keyboard to the group */
	wlr_keyboard_group_add_keyboard(group->wlr_group, &kb->keyboard);

	/* IMPORTANT: Restore global keyboard group as seat keyboard.
	 * createkeyboardgroup() sets seat keyboard to the new group, but for virtual
	 * keyboards we must keep the global kb_group as seat keyboard to avoid
	 * use-after-free when the virtual keyboard is destroyed */
	wlr_seat_set_keyboard(seat, &kb_group->wlr_group->keyboard);
}

/* Text input support for virtual keyboard */

static void
textinput_enable(struct wl_listener *listener, void *data)
{
	TextInput *ti_wrap = wl_container_of(listener, ti_wrap, enable);
	struct wlr_text_input_v3 *ti = ti_wrap->text_input;
	(void)data;

	wlr_log(WLR_INFO, "Text input enabled for surface %p", (void*)ti->focused_surface);
	active_text_input = ti;

	/* Show OSK in HTPC mode when text input is enabled */
	if (htpc_mode_active && selmon) {
		osk_show(selmon, ti->focused_surface);
	}
}

static void
textinput_disable(struct wl_listener *listener, void *data)
{
	TextInput *ti_wrap = wl_container_of(listener, ti_wrap, disable);
	struct wlr_text_input_v3 *ti = ti_wrap->text_input;
	(void)data;

	wlr_log(WLR_INFO, "Text input disabled");
	if (active_text_input == ti) {
		active_text_input = NULL;
		/* Hide OSK when text input is disabled */
		if (htpc_mode_active) {
			osk_hide_all();
		}
	}
}

static void
textinput_commit(struct wl_listener *listener, void *data)
{
	(void)listener;
	(void)data;
	/* Text input committed - nothing to do here for now */
}

static void
textinput_destroy(struct wl_listener *listener, void *data)
{
	TextInput *ti_wrap = wl_container_of(listener, ti_wrap, destroy);
	struct wlr_text_input_v3 *ti = ti_wrap->text_input;
	(void)data;

	wlr_log(WLR_INFO, "Text input destroyed");
	if (active_text_input == ti) {
		active_text_input = NULL;
		if (htpc_mode_active) {
			osk_hide_all();
		}
	}

	/* Remove listeners and free */
	wl_list_remove(&ti_wrap->enable.link);
	wl_list_remove(&ti_wrap->disable.link);
	wl_list_remove(&ti_wrap->commit.link);
	wl_list_remove(&ti_wrap->destroy.link);
	wl_list_remove(&ti_wrap->link);
	free(ti_wrap);
}

void
textinput(struct wl_listener *listener, void *data)
{
	struct wlr_text_input_v3 *ti = data;
	TextInput *ti_wrap;
	(void)listener;

	wlr_log(WLR_INFO, "New text input created");

	ti_wrap = ecalloc(1, sizeof(*ti_wrap));
	ti_wrap->text_input = ti;

	/* Set up listeners for this text input */
	LISTEN(&ti->events.enable, &ti_wrap->enable, textinput_enable);
	LISTEN(&ti->events.disable, &ti_wrap->disable, textinput_disable);
	LISTEN(&ti->events.commit, &ti_wrap->commit, textinput_commit);
	LISTEN(&ti->events.destroy, &ti_wrap->destroy, textinput_destroy);

	wl_list_insert(&text_inputs, &ti_wrap->link);

	/* If a surface already has keyboard focus, send enter to this text input
	 * but only if the text input belongs to the same client as the surface */
	struct wlr_surface *focused = seat->keyboard_state.focused_surface;
	if (focused) {
		struct wl_client *ti_client = wl_resource_get_client(ti->resource);
		struct wl_client *surface_client = wl_resource_get_client(focused->resource);
		if (ti_client == surface_client) {
			wlr_text_input_v3_send_enter(ti, focused);
		}
	}
}

/* Notify all text inputs about focus change */
static void
text_input_focus_change(struct wlr_surface *old, struct wlr_surface *new)
{
	TextInput *ti_wrap;

	wl_list_for_each(ti_wrap, &text_inputs, link) {
		struct wlr_text_input_v3 *ti = ti_wrap->text_input;
		if (!ti || !ti->resource)
			continue;

		/* Send leave if text input has any focused surface */
		if (ti->focused_surface) {
			wlr_text_input_v3_send_leave(ti);
		}

		/* Send enter for new surface - only if text input belongs to same client */
		if (new && new->resource) {
			struct wl_client *ti_client = wl_resource_get_client(ti->resource);
			struct wl_client *surface_client = wl_resource_get_client(new->resource);
			if (ti_client == surface_client) {
				wlr_text_input_v3_send_enter(ti, new);
			}
		}
	}
}

void
virtualpointer(struct wl_listener *listener, void *data)
{
	struct wlr_virtual_pointer_v1_new_pointer_event *event = data;
	struct wlr_input_device *device = &event->new_pointer->pointer.base;

	wlr_cursor_attach_input_device(cursor, device);
	if (event->suggested_output)
		wlr_cursor_map_input_to_output(cursor, device, event->suggested_output);
}

void
warpcursor(const Client *c)
{
	(void)c;
	/* Intentionally do not warp the cursor; keep it exactly where the user left it. */
}

Monitor *
xytomon(double x, double y)
{
	struct wlr_output *o = wlr_output_layout_output_at(output_layout, x, y);
	return o ? o->data : NULL;
}

void
xytonode(double x, double y, struct wlr_surface **psurface,
		Client **pc, LayerSurface **pl, double *nx, double *ny)
{
	struct wlr_scene_node *node, *pnode;
	struct wlr_surface *surface = NULL;
	Client *c = NULL;
	LayerSurface *l = NULL;
	int layer;

	for (layer = NUM_LAYERS - 1; !surface && layer >= 0; layer--) {
		if (!(node = wlr_scene_node_at(&layers[layer]->node, x, y, nx, ny)))
			continue;

		if (node->type == WLR_SCENE_NODE_BUFFER) {
			struct wlr_scene_surface *scene_surface =
				wlr_scene_surface_try_from_buffer(
						wlr_scene_buffer_from_node(node));
			if (scene_surface)
				surface = scene_surface->surface;
		}
		/* Walk the tree to find a node that knows the client */
		for (pnode = node; pnode && !c; pnode = &pnode->parent->node)
			c = pnode->data;
		if (c && c->type == LayerShell) {
			c = NULL;
			l = pnode->data;
		}
	}

	if (psurface) *psurface = surface;
	if (pc) *pc = c;
	if (pl) *pl = l;
}

void
zoom(const Arg *arg)
{
	Client *c, *sel = focustop(selmon);

	if (!sel || !selmon || !selmon->lt[selmon->sellt]->arrange || sel->isfloating)
		return;

	/* Search for the first tiled window that is not sel, marking sel as
	 * NULL if we pass it along the way */
	wl_list_for_each(c, &clients, link) {
		if (VISIBLEON(c, selmon) && !c->isfloating) {
			if (c != sel)
				break;
			sel = NULL;
		}
	}

	/* Return if no other tiled window was found */
	if (&c->link == &clients)
		return;

	/* If we passed sel, move c to the front; otherwise, move sel to the
	 * front */
	if (!sel)
		sel = c;
	wl_list_remove(&sel->link);
	wl_list_insert(&clients, &sel->link);

	focusclient(sel, 1);
	arrange(selmon);
}

static void rotate_clients(const Arg *arg) {
	Monitor* m = selmon;
	Client *c;
	Client *first = NULL;
	Client *last = NULL;

	if (arg->i == 0)
		return;

	wl_list_for_each(c, &clients, link) {
		if (VISIBLEON(c, m) && !c->isfloating && !c->isfullscreen) {
			if (first == NULL) first = c;
			last = c;
		}
	}
	if (first != last) {
		struct wl_list *append_to = (arg->i > 0) ? &last->link : first->link.prev;
		struct wl_list *elem = (arg->i > 0) ? &first->link : &last->link;
		wl_list_remove(elem);
		wl_list_insert(append_to, elem);
		arrange(selmon);
	} 
}

#ifdef XWAYLAND
void
activatex11(struct wl_listener *listener, void *data)
{
	Client *c = wl_container_of(listener, c, activate);

	/* Only "managed" windows can be activated */
	if (!client_is_unmanaged(c))
		wlr_xwayland_surface_activate(c->surface.xwayland, 1);
}

void
associatex11(struct wl_listener *listener, void *data)
{
	Client *c = wl_container_of(listener, c, associate);

	LISTEN(&client_surface(c)->events.map, &c->map, mapnotify);
	LISTEN(&client_surface(c)->events.unmap, &c->unmap, unmapnotify);
}

void
configurex11(struct wl_listener *listener, void *data)
{
	Client *c = wl_container_of(listener, c, configure);
	struct wlr_xwayland_surface_configure_event *event = data;
	if (!client_surface(c) || !client_surface(c)->mapped) {
		wlr_xwayland_surface_configure(c->surface.xwayland,
				event->x, event->y, event->width, event->height);
		return;
	}
	if (client_is_unmanaged(c)) {
		wlr_scene_node_set_position(&c->scene->node, event->x, event->y);
		wlr_xwayland_surface_configure(c->surface.xwayland,
				event->x, event->y, event->width, event->height);
		return;
	}
	if ((c->isfloating && c != grabc) || !c->mon->lt[c->mon->sellt]->arrange) {
		resize(c, (struct wlr_box){.x = event->x - c->bw,
				.y = event->y - c->bw, .width = event->width + c->bw * 2,
				.height = event->height + c->bw * 2}, 0);
	} else {
		arrange(c->mon);
	}
}

void
minimizenotify(struct wl_listener *listener, void *data)
{
	Client *c = wl_container_of(listener, c, minimize);
	struct wlr_xwayland_surface *xsurface = c->surface.xwayland;
	struct wlr_xwayland_minimize_event *e = data;
	int focused;

	if (xsurface->surface == NULL || !xsurface->surface->mapped)
		return;

	focused = seat->keyboard_state.focused_surface == xsurface->surface;
	wlr_xwayland_surface_set_minimized(xsurface, !focused && e->minimize);
}

void
createnotifyx11(struct wl_listener *listener, void *data)
{
	struct wlr_xwayland_surface *xsurface = data;
	Client *c;

	/* Allocate a Client for this surface */
	c = xsurface->data = ecalloc(1, sizeof(*c));
	c->surface.xwayland = xsurface;
	c->type = X11;
	c->bw = client_is_unmanaged(c) ? 0 : borderpx;

	/* Listen to the various events it can emit */
	LISTEN(&xsurface->events.associate, &c->associate, associatex11);
	LISTEN(&xsurface->events.destroy, &c->destroy, destroynotify);
	LISTEN(&xsurface->events.dissociate, &c->dissociate, dissociatex11);
	LISTEN(&xsurface->events.request_activate, &c->activate, activatex11);
	LISTEN(&xsurface->events.request_minimize, &c->minimize, minimizenotify);
	LISTEN(&xsurface->events.request_configure, &c->configure, configurex11);
	LISTEN(&xsurface->events.request_fullscreen, &c->fullscreen, fullscreennotify);
	LISTEN(&xsurface->events.set_hints, &c->set_hints, sethints);
	LISTEN(&xsurface->events.set_title, &c->set_title, updatetitle);
}

void
dissociatex11(struct wl_listener *listener, void *data)
{
	Client *c = wl_container_of(listener, c, dissociate);
	wl_list_remove(&c->map.link);
	wl_list_remove(&c->unmap.link);
}

void
sethints(struct wl_listener *listener, void *data)
{
	Client *c = wl_container_of(listener, c, set_hints);
	struct wlr_surface *surface = client_surface(c);
	if (c == focustop(selmon) || !c->surface.xwayland->hints)
		return;

	c->isurgent = xcb_icccm_wm_hints_get_urgency(c->surface.xwayland->hints);
	printstatus();

	if (c->isurgent && surface && surface->mapped)
		client_set_border_color(c, urgentcolor);
}

void
xwaylandready(struct wl_listener *listener, void *data)
{
	struct wlr_xcursor *xcursor;

	/* assign the one and only seat */
	wlr_xwayland_set_seat(xwayland, seat);

	/* Set the default XWayland cursor to match the rest of dwl. */
	if ((xcursor = wlr_xcursor_manager_get_xcursor(cursor_mgr, "default", 1)))
		wlr_xwayland_set_cursor(xwayland,
				xcursor->images[0]->buffer, xcursor->images[0]->width * 4,
				xcursor->images[0]->width, xcursor->images[0]->height,
				xcursor->images[0]->hotspot_x, xcursor->images[0]->hotspot_y);
}
#endif

int
main(int argc, char *argv[])
{
	const char *startup_cmd = NULL;
	int c;

	while ((c = getopt(argc, argv, "s:hdv")) != -1) {
		if (c == 's')
			startup_cmd = optarg;
		else if (c == 'd')
			log_level = WLR_DEBUG;
		else if (c == 'v')
			die("nixlytile " VERSION);
		else
			goto usage;
	}
	if (optind < argc)
		goto usage;

	/* Load runtime config before applying defaults */
	load_config();
	init_keybindings();

	/* Detect available GPUs for PRIME offloading */
	detect_gpus();

	/* Build autostart command with wallpaper path if not overridden */
	{
		char expanded_wp[PATH_MAX];
		config_expand_path(wallpaper_path, expanded_wp, sizeof(expanded_wp));
		/* Only rebuild if autostart_cmd still has the default wallpaper reference */
		if (strstr(autostart_cmd, ".nixlyos/wallpapers/beach.jpg")) {
			snprintf(autostart_cmd, sizeof(autostart_cmd),
				"eval $(gnome-keyring-daemon --start --components=secrets,ssh,pkcs11) & "
				"thunar --daemon & swaybg -i \"%s\" -m fill <&-", expanded_wp);
		}
	}

	if (!startup_cmd)
		startup_cmd = autostart_cmd;

	/* Wayland requires XDG_RUNTIME_DIR for creating its communications socket */
	if (!getenv("XDG_RUNTIME_DIR"))
		die("XDG_RUNTIME_DIR must be set");
	setup();
	setup_config_watch();
	gamepad_setup();
	bt_controller_setup();
	pc_gaming_cache_watch_setup();

	/* Set GE-Proton as default Steam compatibility tool */
	steam_set_ge_proton_default();

	/* Enter HTPC mode at startup if always-on (mode 2), or on controller if mode 1 */
	if (htpc_mode == 2 || (htpc_mode == 1 && !wl_list_empty(&gamepads)))
		htpc_mode_enter();

	/* Start only git cache immediately, stagger others via timer
	 * Phase 0=git (done), 1=file (in 30s), 2=gaming (in 60s) */
	git_cache_update_start();
	cache_update_phase = 1; /* Next: file cache */
	if (cache_update_timer)
		wl_event_source_timer_update(cache_update_timer, 30000); /* 30 seconds */
	schedule_nixpkgs_cache_timer();
	run(startup_cmd);
	cleanup();
	return EXIT_SUCCESS;

usage:
	die("Usage: %s [-v] [-d] [-s startup command]", argv[0]);
}
